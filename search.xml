<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ES6常用语法规范</title>
      <link href="2021/05/25/ES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/"/>
      <url>2021/05/25/ES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><ul><li>以后定义变量的时候不要用var了, 尽量使用ES6语法的let</li><li>var的设计有错误, 但是这种错误不好去修复和移除, 于是就有了新的关键字let</li><li>let是更完美的var</li><li>let的完美之处在于拥有块级作用域</li><li>var是没有作用域的</li><li>变量作用域: 就是指变量在什么范围内是可用的</li><li>if和for是没有块级作用域的,造成的问题是, if 和for 大括号中的变量可以被外面访问到， 所以ES5之前都是借助闭包(function的作用域)来解决外面可以访问内部变量的问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题</span></span><br><span class="line"><span class="comment">// 需求是点击按钮的时候, 输出该按钮的索引号</span></span><br><span class="line"><span class="comment">// 假如有4个按钮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码并不能满足需求, 每次点击按钮的时候输出的都是5</span></span><br><span class="line"><span class="comment">// 因为输出的i因为没有块级作用域,被for中的i++改变了</span></span><br></pre></td></tr></table></figure><ul><li>以前解决这种问题使用的是引入第三变量记录每一个btn的索引, 或者使用闭包, 用function的作用域来限制i的访问</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; btns.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; <span class="comment">// 这个i是一个形参</span></span><br><span class="line">    btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)  <span class="comment">// 函数里面的i就有作用域了，不会被外面访问到</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(i) <span class="comment">// 这个i是每一次传入的实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有了let后，简直爽到！</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 这里的i就不需要借助function的作用域了!</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><ul><li>const关键字定义的变量不可以再次赋值, 称为常量</li><li>当我们的变量不需要再赋值的时候, 用const来定义可以保证安全性, 而且不需要内存区监听这个变量, 提高效率</li><li>建议在开发中优先使用const定义变量, 在遇到需要重新赋值的标识符才使用let</li><li>const定义的标识符不能重新赋值</li><li>const定义标识符的时候, 必须同时赋值</li><li>常量的定义是指向的对象不能被改变, 而对象内部的属性可以被改变</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意点3, 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="attr">tall</span>: <span class="number">170</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部的属性可以被修改</span></span><br><span class="line">    obj.name = <span class="string">&quot;xiaoLamLam&quot;</span>;</span><br><span class="line">    obj.age = <span class="number">21</span>;</span><br><span class="line">    obj.tall = <span class="number">171</span>;</span><br></pre></td></tr></table></figure><h3 id="ES6-对象字面量增强写法"><a href="#ES6-对象字面量增强写法" class="headerlink" title="ES6 对象字面量增强写法"></a>ES6 对象字面量增强写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> tall = <span class="number">1.70</span>;</span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">  <span class="attr">age</span>: age,</span><br><span class="line">  <span class="attr">tall</span>: tall,</span><br><span class="line">  <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I can run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 属性增强写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  tall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 函数增强写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I can run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-for…in-循环遍历数组"><a href="#ES6-for…in-循环遍历数组" class="headerlink" title="ES6 for…in 循环遍历数组"></a>ES6 for…in 循环遍历数组</h3><ul><li>for(let index in arr) {}  这里的index拿到的是arr里面数据的下标</li><li>与for(let i =0; i &lt;arr.length; i++) 其实很相似, 就是代码更加简洁了</li></ul><h3 id="ES6-for…of-循环遍历数组"><a href="#ES6-for…of-循环遍历数组" class="headerlink" title="ES6 for…of 循环遍历数组"></a>ES6 for…of 循环遍历数组</h3><ul><li>for(let item of arr) {} 这里的item拿到的式arr中的数据</li></ul><h3 id="编程范式-命令式编程-声明式编程"><a href="#编程范式-命令式编程-声明式编程" class="headerlink" title="编程范式: 命令式编程/声明式编程"></a>编程范式: 命令式编程/声明式编程</h3><h3 id="编程范式-面向对象编程-第一公民-对象-面向函数编程-第一共鸣-函数"><a href="#编程范式-面向对象编程-第一公民-对象-面向函数编程-第一共鸣-函数" class="headerlink" title="编程范式: 面向对象编程(第一公民: 对象) / 面向函数编程(第一共鸣: 函数)"></a>编程范式: 面向对象编程(第一公民: 对象) / 面向函数编程(第一共鸣: 函数)</h3><h3 id="高阶函数-高阶函数的阅读性很强"><a href="#高阶函数-高阶函数的阅读性很强" class="headerlink" title="高阶函数 高阶函数的阅读性很强"></a>高阶函数 高阶函数的阅读性很强</h3><ul><li>filter/map/reduce</li><li>filter<ul><li>filter中传入一个回调函数, 这个回调函数有一个要求, 必须返回一个Boolean值</li><li>当这个boolean值为true时, 函数内部会自动将这个回调的数据添加到一个新的数组中 这个新数组要定义一个数组来接</li><li>当这个boolean值为false时, 函数内部会过滤掉这次的数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">445</span>,<span class="number">412</span>,<span class="number">4546</span>,<span class="number">1231</span>,<span class="number">44</span>];</span><br><span class="line"><span class="keyword">let</span> newArr1 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">100</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr1);</span><br></pre></td></tr></table></figure><ul><li>map<ul><li>map中也是传入一个回调函数</li><li>对数组中的每一项都运行传入的函数, 返回由每次函数调用的结果构成的数组 也定义一个数组来接</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr2 = newArr1.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr2);</span><br></pre></td></tr></table></figure><ul><li>reduce方法<ul><li>reduce()中接收两个参数, 第一个参数是会对每一项都会运行的归并函数, 第二个参数是可选的参数,为归并起点的初始值</li><li>归并函数可以接收四个参数, 第一个参数是上一个归并值, 第二个参数是当前项, 第三个参数是当前项的索引值, 第四个参数是数组本身</li><li>函数返回的任何值都会作为下一次调用同一个函数的第一个参数</li><li>如果reduce()中没有传入可选的第二个参数作为归并起点值, 那么第一次迭代将从数组的第二项开始,因此第一次迭代传给归并函数的第一个参数是数组的第一项,第二个参数是数组的第二项, 所以第二个参数通常会传入一个0</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = newArr2.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + cur;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><ul><li>以上的高级函数用法可以使用链式编程写法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum2 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">100</span>;</span><br><span class="line">&#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum2);</span><br></pre></td></tr></table></figure><ul><li>配合箭头函数可以一行代码写完</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum3 = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="number">100</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>).reduce(<span class="function">(<span class="params">preValue,cur</span>) =&gt;</span> preValue + cur,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum3);</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 基本使用</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">参数列表</span>) =&gt;</span> &#123;函数体&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 参数问题</span></span><br><span class="line"><span class="comment">// 2.1 放入多个参数</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2 &#125;</span><br><span class="line"><span class="comment">// 2.2 放入一个参数 (可以将小括号省略掉)</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function"><span class="params">num</span> =&gt;</span> &#123; <span class="keyword">return</span> num * <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数体中代码数量问题</span></span><br><span class="line"><span class="comment">// 3.1有多行代码</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第二行代码&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;第三行代码&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 3.2 只有一行代码 (花括号和return可以省略)</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;省略花括号&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure><h3 id="什么时候使用箭头函数"><a href="#什么时候使用箭头函数" class="headerlink" title="什么时候使用箭头函数"></a>什么时候使用箭头函数</h3><ul><li>在普通的情况下, 使用箭头函数的情况并不多</li><li>在当我们将一个函数作为一个参数传入另外一个函数的情况下, 使用箭头函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="箭头函数中的this指向问题"><a href="#箭头函数中的this指向问题" class="headerlink" title="箭头函数中的this指向问题"></a>箭头函数中的this指向问题</h3><ul><li>普通函数中的this, 是谁调用指向谁</li><li>箭头函数中的this, 是指向最近一层作用域的this<ul><li>也就是说, 箭头函数中的this, 会想外层作用域中,一层层查找this, 直到找到有this的定义</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里是因为setTimeout是由window调用的</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为test中的this是指向obj对象的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// obj对象</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// obj对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><ul><li>Promise是ES6中的一个非常重要和好用的特性</li><li>Promise是做什么的<ul><li>Promise是一个异步编程的解决方案</li></ul></li><li>在什么时候我们会处理异步事件呢?<ul><li>在网络请求中我们会大量处理异步事件</li><li>比如, 我们封装了一个网络请求函数, 向服务器请求数据是不能立即拿到结果的</li><li>所以我们往往会传入另外一个函数, 在数据请求成功的时候, 将数据通过传入的函数回调出去, 简单来说就是在网络请求函数中嵌套另外一个函数</li><li>如果只是一个简单的网络请求, 那么这种方案还是可行的</li></ul></li><li>但是, 当网络请求非常复杂的时候, 就会出现回调地狱</li><li>回调地狱是指: 如果很多的异步操作需要安装顺序来的时候, 就需要回调函数的嵌套, 如果过多的函数嵌套会造成回调地狱, 这样不利于后期代码的维护</li><li>可以使用promise对象来解决这个问题</li></ul><h3 id="Promise的基本语法"><a href="#Promise的基本语法" class="headerlink" title="Promise的基本语法"></a>Promise的基本语法</h3><ul><li>创建一个Promise实例</li><li>在这个实例中传入一个函数, 这个函数包含两个参数, resolve 和 reject</li><li>resolve 和 reject 分贝是两个函数</li><li>resolve函数会在异步操作执行成功后调用, 这个函数中也可以传入参数, 一般是异步操作中获得的数据data</li><li>reject函数会在异步操作执行失败后调用, 这个函数中也是可以传入参数的, 一般是异步操作失败后的错误信息err</li><li>在调用resolve函数后, 后续的then函数会被回调, then中还是传入一个函数, 函数中也是传入一个参数data, 这个data就是resolve中的data数据</li><li>在调用reject函数后, 后续的catch函数会被回调, catch中也是传入一个函数, 函数中也是传入一个参数err, 这个err就是reject中的err错误信息</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;再见再见&quot;</span>)</span><br><span class="line">      reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实可以简单理解为</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行异步操作</span></span><br><span class="line">  <span class="comment">// 异步操作成功后调用</span></span><br><span class="line">  resolve(data) <span class="comment">// data为操作成功后传入的数据</span></span><br><span class="line">  <span class="comment">// 异步操作失败后调用</span></span><br><span class="line">  reject(err) <span class="comment">// err为操作失败后传入的错误信息</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用resolve后会进入这个函数中进行下面的操作</span></span><br><span class="line">  <span class="comment">// 这个函数中的data是由resolve中传过来的data</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用reject后会进入这个函数中进行下面的操作</span></span><br><span class="line">  <span class="comment">// 这个函数中的err错误信息是从reject中传过来的err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise补充知识点"><a href="#Promise补充知识点" class="headerlink" title="Promise补充知识点"></a>Promise补充知识点</h3><ul><li>Promise中的then回调函数其实可以传入两个参数的</li><li>这两个参数都是函数, 第一个函数会在resolve执行后回调, 第二个函数会在reject执行后回调, 这样就省略了catch回调函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">          reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// then传入两个函数, 第一个函数会在resolve执行后调用, 第二个含税会在reject执行后调用</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="comment">// 这样写就省略了catch回调函数</span></span><br></pre></td></tr></table></figure><h3 id="Promise的链式操作"><a href="#Promise的链式操作" class="headerlink" title="Promise的链式操作"></a>Promise的链式操作</h3><ul><li>可以在then回调函数中 return一个new Promise 来进行下一步的异步操作</li><li>如果每次执行成功想要进行下一步异步操作的话, 都要return 一个new Promise, 很麻烦, 所以ES6提供了简写方法和超级简写方法</li><li>如果想要进入catch回调函数的话, 就要使用 return Promise.reject(“错误信息”) 或者 throw “错误信息”</li><li>具体看代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次进行下一步操作的时候都要return 一个new Promise很麻烦, 所以ES6提供简写模式</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span></span><br><span class="line">  <span class="comment">// return Promise.resolve(res) // 简写模式</span></span><br><span class="line">  <span class="comment">// 如果是要进入catch回调的话, 就用 return Promise.reject()</span></span><br><span class="line">  <span class="comment">// return Promise.reject(&quot;错误错误&quot;)</span></span><br><span class="line">  <span class="comment">// 或者使用 throw &quot;错误信息&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;错误错误&quot;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行成功后每次都要写Promise.resolve, ES6觉得也很麻烦, 所以还可以更简写</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 超级简写模式, 只能在then中使用</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise中的all方法"><a href="#Promise中的all方法" class="headerlink" title="Promise中的all方法"></a>Promise中的all方法</h3><ul><li>如果有一个需求, 需要两个异步请求都完成了, 才能执行</li><li>如果用普通的方法</li></ul><ul><li>定义第三变量, 来记录异步请求是否完成</li><li>定义一个函数, 在进入函数体之前通过第三变量来判断异步请求是否都完成了, 如果都完成了就执行</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">false</span>;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;url1&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    result1 = <span class="literal">true</span>;</span><br><span class="line">    resulthandle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;url2&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    result2 = <span class="literal">true</span>;</span><br><span class="line">    resulthandle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resulthandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result1 &amp;&amp; result2) &#123;</span><br><span class="line">    <span class="comment">// 执行需求的操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果使用Promise.all方法就可以轻松完成需求</li><li>Promise.all() 方法要求传入一个数组, 这个数组包含你想要进行的异步操作</li><li>当数组中的异步操作都完成的时候会调用then回调函数, 这个then中传入一个函数, 函数中又一个参数</li><li>这个函数的参数是一个数组, 数组中包含的是异步操作中返回的data数据</li><li>如果有异步请求失败的话就会进入catch回调函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;url1&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">      <span class="function"><span class="title">success</span>(<span class="params">data1</span>)</span> &#123;</span><br><span class="line">        resolve(data1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;url2&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">      <span class="function"><span class="title">success</span>(<span class="params">data2</span>)</span> &#123;</span><br><span class="line">        resolve(data2)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 这个result就是一个数组, 数组中是异步操作中返回的数据data</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 如果有异步操作失败的话, 就会进入catch, err是返回的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for-in 和 for-of的区别"></a>for-in 和 for-of的区别</h3><ul><li>for-in 遍历的item是 元素的键</li><li>for-of 遍历的item是 元素的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 前端小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="2021/05/25/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>2021/05/25/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript原始功能"><a href="#JavaScript原始功能" class="headerlink" title="JavaScript原始功能"></a>JavaScript原始功能</h3><ul><li>在早期的网页开发时期, js的代码很少, 都是直接将js代码写到html代码中的script标签中就可以了</li><li>随着ajax异步请求的出现, 慢慢形成了前后端分离<ul><li>用户需求越来越多, 代码与日俱增</li><li>为了应对代码量的剧增, 我们将代码写到多个js文件中, 进行维护</li><li>但是这样容易引起变量泄露等等的严重问题</li><li>可以使用匿名函数闭包来解决变量泄露的问题<ul><li>但是这样又引入了另外的一个问题, 代码不能复用了</li></ul></li></ul></li></ul><h3 id="如何使用闭包防止变量泄露"><a href="#如何使用闭包防止变量泄露" class="headerlink" title="如何使用闭包防止变量泄露"></a>如何使用闭包防止变量泄露</h3><ul><li>原理<ul><li>利用函数自身的块级作用域特性, 函数内部的变量, 外部无法访问</li><li>将想要暴露出去的变量和函数, 打包在一个对象中</li><li>通过return 的方法 将打包好的对象暴露出去</li><li>在函数的外面用一个变量接收这一个对象</li><li>在其他的模块中引用</li></ul></li><li>具体代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ModuleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这些是函数内部的变量和函数, 外部无法访问</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将变量和函数放入变量中</span></span><br><span class="line">  obj.sum = sum;</span><br><span class="line">  obj.flag = flag;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将这个对象暴露出去</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码是在其他模块中引用</span></span><br><span class="line">ModuleA.sum() <span class="comment">// 这样就调用了ModelA的sum方法</span></span><br><span class="line">ModuleA.flag;  <span class="comment">// 这样就访问了ModelA的flag变量</span></span><br></pre></td></tr></table></figure><ul><li>以上的代码就是模块最基础的封装了, 事实上模块的封装还有很多高级的写法</li><li>很幸运的是, 前端模块化的开发已经又很多的既有规范, 已经对应的实现方案</li></ul><h3 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h3><ul><li>CommonJS AMD CMD 还有ES6的Modules</li><li>开发常用的是NodeJS中的CommonJS 和 ES6中的Modules</li></ul><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><ul><li>模块化规范都是围绕两个核心来进行的, 导出和导入</li><li>CommonJS的导出和导入基本雏形</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS的导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">flag</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS的导入</span></span><br><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123;flag,test&#125; = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h3><ul><li>在引入js文件的script标签中, 定义type属性, 值为module, 来模块化js文件</li><li>在各个模块中通过export导出信息, import导入信息</li><li>注意事项<ul><li>导入默认的信息时, 不需要加大括号, 而且名字可以自定义</li><li>通过通配符 * 导入所有被导出的信息 import * as 自定义名字 from “模块地址”<ul><li>这个自定义名字就是 * 的别名, 方便后续的使用</li><li>实际上就是将 ModuleA 中导出的所有信息 * , 集合到 自定义名字 这个对象中</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ES6中的模块化, 引入模块的script标签必须添上值为module的type类型属性,使js文件模块化 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在添加上值为module的type类型属性后, 各个模块之间的就不会有变量泄露的问题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ModuleA.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ModuleB.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模块A ModuleA</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这个模块中定义变量, 函数, 类等</span></span><br><span class="line"><span class="comment">// 1. 通过对象的形式导出</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;flag, name, sum&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 单独形式导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我在跑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 导出一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我在走&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 默认导出 default</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="comment">// 注意一个模块内只能由一个默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> me;</span><br></pre></td></tr></table></figure><ul><li>模块B ModuleB</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这个模块中导入ModuleA中的变量 函数 类 等</span></span><br><span class="line"><span class="comment">// 通过import导入</span></span><br><span class="line"><span class="keyword">import</span> &#123;flag, name,sum&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(flag);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;age, run&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Person&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xiaoLam = <span class="keyword">new</span> Person();</span><br><span class="line">xiaoLam.walk();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认导出</span></span><br><span class="line"><span class="comment">// 导入默认的信息时, 不需要加大括号, 而且名字可以自定义</span></span><br><span class="line"><span class="keyword">import</span> you <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(you);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通配符 * 导入所有被导出的信息 import * as 自定义名字 from &quot;模块地址&quot;;</span></span><br><span class="line"><span class="comment">// 这个自定义名字就是 * 的别名, 方便后续的使用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> objA <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="comment">// 实际上就是将 ModuleA 中导出的所有信息, 集合到objA这个对象中</span></span><br><span class="line"><span class="built_in">console</span>.log(objA);</span><br><span class="line"><span class="built_in">console</span>.log(objA.name);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack项目打包工具详解</title>
      <link href="2021/05/25/webpack%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/webpack%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="认识webpack"><a href="#认识webpack" class="headerlink" title="认识webpack"></a>认识webpack</h3><ul><li><p>webpack是什么</p><ul><li>本质上来说, webpack是一个现代的javaScript应用的静态模块打包工具</li><li>实质上, webpack就是 将代码进行模块化和打包的工具</li></ul></li><li><p>前端模块化</p><ul><li>前端模块化的一些方案有, AMD CMD CommonJS ES6</li><li>在ES6之前, 我们想要进行模块化开发, 就必须借助于其他的工具进行</li><li>而且在通过模块化开发完成项目后, 还需要处理模块和模块之间的各种依赖, 进行整合打包</li><li>而webpack和其中一个核心就是帮助我们进行模块化开发, 并且帮助我们处理模块之间的依赖关系</li><li>不仅仅时JS文件, CSS, 图片, json文件等等都可以被webpack中当作模块来使用</li><li>这就是webpack中模块化的概念</li></ul></li><li><p>什么是打包</p><ul><li>webpack可以帮助我们进行模块化, 并且处理模块之间的各种复杂关系</li><li>打包就是将webpack中的各种资源模块进行打包, 合并成一个或者多个包(bundle)</li><li>在打包的过程中,还可以对资源进行处理, 比如压缩图片, scss转换为css, 将ES6语法转化为ES5语法进行兼容, 将TypeScript 转换成JavaScript语法等等的操作</li><li>这种打包的操作, grunt/gulp 也可以完成, 他们有什么区别呢?</li></ul></li><li><p>webpack和grunt/gulp的区别</p><ul><li><p>grunt/gulp 的核心是 task</p><ul><li>我们可以配置一系列的task代码, 并且定义task要处理的事物(ES6转化, ts转化, 图片压缩, scss转化等)</li><li>然后让grunt/gulp 来依次执行task, 并且让整个流程自动化</li><li>所以grunt/gulp 也被称为前端自动化任务管理工具</li></ul></li><li><p>什么时候用grunt/gulp 呢?</p><ul><li>工程模块依赖非常简单, 甚至没有用到模块化的概念</li><li>只需要进行简单的合并, 压缩, 就只使用grunt/gulp就可以了</li><li>当项目使用了模块化管理, 而且模块之间的相互依赖非常强, 就要使用功能更加强大的webpack了</li></ul></li><li><p>所以grunt/gulp 和 webpack的区别</p><ul><li>grunt/gulp 更加强调的是前端流程的自动化, 模块化并不是它的和兴</li><li>webpack更加强调的是模块化开发管理, 而文件压缩合并, 代码预处理等功能是附加功能</li></ul></li></ul></li></ul><h3 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h3><ul><li>安装webpack需要安装Node.js 建议使用8.0以上的Node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--查看自己的node版本,终端输入命令行 --&gt;</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><ul><li>全局安装 webpack (这里使用的版本是3.6.0 因为vue cli2 依赖这个版本, 如果版本过高, webpack底层代码被隐藏起来不利于学习, 所以这里使用3.6.0版本)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 -g</span><br></pre></td></tr></table></figure><ul><li>局部安装webpack (后续需要)<ul><li>–save-dev 是开发时依赖, 项目打包后不需要继续使用, -save 是运行时依赖, 项目打包后也是要继续使用的</li><li>一般webpack时 开发时依赖安装 </li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 对应的目录路径</span><br><span class="line">npm install webpack@3.6.0 --save-dev</span><br></pre></td></tr></table></figure><ul><li>为什么全局安装后, 还需要局部安装?<ul><li>在终端直接执行webpack命令, 使用的是全局安装的webpack</li><li>当在package.json中定义script时, 其中包含了webpack命令, 那么使用的是局部webpack</li></ul></li></ul><h3 id="准备工作-文件和文件夹的创建"><a href="#准备工作-文件和文件夹的创建" class="headerlink" title="准备工作, 文件和文件夹的创建"></a>准备工作, 文件和文件夹的创建</h3><ul><li>文件和文件夹解析<ul><li>dist 文件夹, 里面的代码是经过处理的, 最终上传到服务器的代码</li><li>src 文件夹, 里面的代码源码, 所有的源码都应该在src文件夹里面<ul><li>main.js : 项目的入口文件</li><li>其他的js文件, 通常一个js文件就是一个模块</li></ul></li><li>index.html文件, 浏览器打开展示的首页html</li><li>package.json: 通过npm init 生成的, 里面记录了这个项目所需要的包的信息</li></ul></li><li>注意作为入口的文件, 不需要放到文件夹中, 放在文件夹外面是最合适的</li></ul><h3 id="JS文件的打包"><a href="#JS文件的打包" class="headerlink" title="JS文件的打包"></a>JS文件的打包</h3><ul><li>现在的js文件中使用了模块化的方式进行开发, 是不可以直接使用的<ul><li>因为直接在index.html文件中引入模块化开发的js文件, 浏览器是不会识别里面的模块化代码的</li><li>另外, 项目中有很多的js模块文件, 如果一个一个地按照顺序在html文件中引用是非常麻烦, 而且不利于后期的维护和管理的</li></ul></li><li>使用webpack工具, 对多个js文件进行打包<ul><li>webpack是一个模块化打包工具, 所以它支持我们在代码中写模块化代码, 而且是各种各样的模块化, 混合使用都可以</li><li>处理完各个模块之间的关系后, 只需要将多个js打包到一个js文件中, 引入的时候就变得非常方便了</li><li>打包的命令行</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/bundle.js</span><br><span class="line">&lt;!-- 这段代码的意思是将src目录下的main.js和其导入的所有模块文件, 打包到dist目录下的一个叫bundle.js的文件中, 如果没有这个文件, 则会自动创建该文件 --&gt;</span><br></pre></td></tr></table></figure><ul><li><p>使用打包后的文件</p><ul><li>打包后会在dist文件夹下生成一个bundle.js文件<ul><li>这个文件是webpack处理了项目直接文件依赖生成的一个js文件, 现在只需要将这个js文件在index.html中引入即可</li></ul></li></ul></li><li><p>具体代码如下</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js的代码</span></span><br><span class="line"><span class="comment">// 1. 使用CommonJS规范 导入信息</span></span><br><span class="line"><span class="keyword">const</span> &#123;sum, mul&#125; = <span class="built_in">require</span>(<span class="string">&quot;./mathUtils.js&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用ES6规范 导入信息</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, age, height&#125; <span class="keyword">from</span> <span class="string">&quot;./info.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用webpack 打包模块</span></span><br><span class="line"><span class="comment">// 终端命令行输入 webpack 路径1 路径2</span></span><br><span class="line"><span class="comment">// 路径1 为想要打包的模块main 代码</span></span><br><span class="line"><span class="comment">// 路径2 为目标的js</span></span><br><span class="line"><span class="comment">// 例如 webpack ./src/main.js ./dist/bundle.js</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mathUtils.js 的代码</span></span><br><span class="line"><span class="comment">// 1. 使用CommonJS规范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS规范导出信息</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;sum, mul&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// info.js 的代码</span></span><br><span class="line"><span class="comment">// 2. 使用ES6 规范导出信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html 的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><ul><li>如果每次使用webpack的命令都需要写上入口和出口作为参数, 这样是很麻烦的, 特别是真实开发的时候这些参数都很长</li><li>解决方法, 在项目根目录中创建一个叫 webpack.config.js 的文件<ul><li>在文件内编写入口和出口的参数</li><li>然后再命令行中直接输入 webpack 命令, node就会找到这个文件按照里面编写好的的参数来运行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 的代码</span></span><br><span class="line"><span class="comment">// path模块是node中的内置模块, 是用于处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 编写入口</span></span><br><span class="line">  <span class="attr">entry</span> : <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 编写出口, output 是一个对象, 对象包含两个属性, path 路径 和fliename 文件名, 其中path路径必须是绝对路径</span></span><br><span class="line">  <span class="comment">// path绝对路径, 借助了node中的内置模块 path 的resolve方法 这个方法是用来拼接路径的</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>), <span class="comment">// __dirname 指的是当前文件的绝对路径</span></span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span> <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h3><ul><li>目前使用的webpack都是全局安装的webpack, 那么就会有问题出现了<ul><li>一般来说, 一个项目往往依赖某个特定版本的webpack, 全局的版本可能与当前项目的webpack版本不一致, 导出打包的时候就会出现问题</li><li>所以通常来说, 一个项目都有自己的局部webpack</li></ul></li><li>所以要安装局部webpack<ul><li>在项目根目录的路径下, 命令行输入 npm install <a href="mailto:&#119;&#101;&#98;&#112;&#97;&#99;&#x6b;&#x40;&#51;&#46;&#x36;&#x2e;&#48;">&#119;&#101;&#98;&#112;&#97;&#99;&#x6b;&#x40;&#51;&#46;&#x36;&#x2e;&#48;</a> –save-dev (–save-dev 就是局部安装, 并且是开发依赖的意思)</li></ul></li><li>运行局部webpack<ul><li>只要是在终端中直接输入 webpack 命令 都是运行的全局安装的webpack</li><li>如何运行局部webpack呢?<ul><li>第一种方法, 通过路径运行启动webpack打包<ul><li>在项目的根目录下 命令行输入 node_modules/.bin/webpack 启动webpack打包 (太繁琐不推荐)</li></ul></li><li>第二种方法 package.json中定义启动</li></ul></li></ul></li></ul><h3 id="在package-json中定义启动局部安装的webpack"><a href="#在package-json中定义启动局部安装的webpack" class="headerlink" title="在package.json中定义启动局部安装的webpack"></a>在package.json中定义启动局部安装的webpack</h3><ul><li>在package.json文件中的 scripts中定义自己的执行脚本</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="comment">// 下面这个就是自定义的执行脚本</span></span><br><span class="line">    <span class="comment">// 这句话的意思是 在命令行中输入 npm run build 的时候就会执行对应的代码</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span> : <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li><p>package.json中的scripts脚本在执行时, 会按照一定的顺序寻找命令对应的位置</p><ul><li>首先 会寻找本地的node_modules/.bin 路径中对应的命令</li><li>如果没有找到, 会在全局的环境变量中寻找</li></ul></li><li><p>执行build指令</p><ul><li>在项目根目录路径下, 命令行输入 npm run build 即可执行指令</li></ul></li></ul><h3 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h3><ul><li>loader是webpack中一个非常核心的概念<ul><li>它是用来扩展webpack的功能的, webpack自身是不会处理css, 图片, typeScript等等的文件的, 也就是说webpack本身只会处理js的文件</li></ul><ul><li>但是我们在开发中不仅仅需要有基本的js代码管理, 还需要夹中css, 图片, ES6转换ES5, TypeScript转换ES5代码等等等等的需求</li></ul><ul><li>那么就需要用loader来扩展webpack的功能</li></ul></li><li>loader的使用过程<ul><li>步骤一: 通过npm安装需要使用的loader<ul><li>可以通过查阅webpack官方文档来查询各种loader的功能</li></ul></li><li>步骤二: 在webpack.config.js 中的module关键字中进行配置<ul><li>具体配置方法可以查阅webpack官方文档</li></ul></li></ul></li><li>大部分loader都可以在webpack官网中找到用法</li></ul><h3 id="通过loader处理css文件"><a href="#通过loader处理css文件" class="headerlink" title="通过loader处理css文件"></a>通过loader处理css文件</h3><ul><li><p>第一步: npm局部安装css-loader和style-loader</p></li><li><p>第二步: 在入口js文件中编写css文件依赖 require=(“css文件的路径”)</p><ul><li>不需要用变量去接收这个css文件, 只需要让js文件依赖这个css文件就行, 实际上就是让css文件与项目有了联系</li></ul></li><li><p>第三步: 在webpack.config.js 的module关键字下进行配置</p><ul><li>webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</li></ul></li><li><p>注意点:</p><ul><li>css-loader 只负责加载css文件, 但是不会负责将css具体样式嵌入到DOM中</li><li>style-loader 会负责将css具体样式嵌入到DOM中</li><li>所以这两个loader 是一起使用的, 用来处理css文件的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 局部安装css-loader和 style-loader 命令行输入--&gt;</span><br><span class="line">npm install css-loader@需要的版本号 --save-dev</span><br><span class="line">npm install style-loader@需要的版本号 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口的js文件中编写css文件依赖</span></span><br><span class="line"><span class="built_in">require</span> = (<span class="string">&quot;css文件的路径&quot;</span>) <span class="comment">// 不需要用变量去接收这个css文件, 只需要让js文件依赖这个css文件就行, 实际上就是让css文件与项目有了联系</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js 中的module关键字中编写配置</span></span><br><span class="line"><span class="comment">// 可以在webpack官网中查阅各个loader的用法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span> : &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 这个test的作用为导入以 .css结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">        <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="less文件处理"><a href="#less文件处理" class="headerlink" title="less文件处理"></a>less文件处理</h3><ul><li>准备工作<ul><li>在css文件夹中创建less文件</li></ul></li><li>局部安装less-loader 和 less<ul><li>这里不仅安装了less-loader 还安装了less<ul><li>因为webpack并不会编译less文件, 需要借助less来进行编译</li></ul></li></ul></li><li>根据官方文档修改对应的配置文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js文件中新增的代码</span></span><br><span class="line"><span class="comment">// 4. 在这里依赖一下less文件, 让less文件与项目有关系</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./css/special.less&quot;</span>)</span><br><span class="line"><span class="comment">// 为了可以看到效果, 给页面中填写一些文字</span></span><br><span class="line"><span class="built_in">document</span>.writeln(<span class="string">&quot;&lt;h2&gt;你好你好&lt;/h2&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是webpack.config.js 中的修改后的module对象, 其实就是按照官方文档复制粘贴就行</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">      <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">      use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h3><ul><li>资源准备阶段<ul><li>在src文件夹中的img文件夹中准备两张图片, 一张大于设定的limit大小, 一张小于设定的limit大小</li></ul></li><li>局部安装url-loader<ul><li>按照webpack官网设置webpack.config.js文件</li><li>先在css文件中引用小于设定的limit大小的图片作为页面背景</li><li>命令行输入 npm run build 进行打包</li><li>浏览器运行后发现, 小于limit大小的图片是经过base64编码成字符串后渲染出来的</li></ul></li><li>现在用大于设定的limit大小的图片作为页面背景<ul><li>命令行输入 npm run build 进行打包</li><li>会发现报错, 提示项目中没有file-loader模块</li><li>安装file-loader模块后 再次进行打包</li><li>会发现dist文件夹下多了一个图片文件<ul><li>原理: 如果图片的大小大于webpack.config.js中limit设定的大小的话, webpack会用file-loader模块进行图片文件的导出</li></ul></li></ul></li></ul><h3 id="图片文件处理-修改文件名称"><a href="#图片文件处理-修改文件名称" class="headerlink" title="图片文件处理-修改文件名称"></a>图片文件处理-修改文件名称</h3><ul><li>我们会webpack 通过file-loader导出的图片的名字是一个很长的名字<ul><li>这是一个32位hash值, 目的是为了防止名字的重复</li><li>但是, 真实开发中, 我们可能对打包的图片名字有一定的要求</li><li>比如, 将图片放到一个文件夹中, 跟上图片原来的名字, 同时要防止文件名的重复</li></ul></li><li>所以在webpack.config.js 中de1options中添加如下选项<ul><li>name : “img.[name].[hash:8].[ext]”</li><li>img : 文件要打包到的文件夹</li><li>[name] : 获取图片原来的名字,放在该位置</li><li>[hash:8] : 防止图片名称冲突,依然使用hash,但是保留8位,以免文件名字过长</li><li>[ext] : 使用图片原来的扩展名</li></ul></li><li>做完以上处理后, 再次打包, 会发现图片并没有显示出来, 这是因为图片使用的路径不正确<ul><li>默认情况下, webpack会将生成的路径直接返回给使用者</li><li>但是, 我们整个程序打包是在dist文件夹下的, 所以在这里我们需要在路径下再添加一个dist/</li><li>在实际开发中并不需要添加在路径下再添加dist/ ,因为项目最终入口文件都会放到dist文件夹中, 现在是在学习阶段, 所以需要添加, 到后面要删除整个多余的dist/路径的</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里是css中引入的两张图片 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* background: pink; */</span></span><br><span class="line">  <span class="comment">/* 这是一张小于limit 大小的图片 */</span></span><br><span class="line">  <span class="comment">/* background: url(../img/OIP.jfif) */</span></span><br><span class="line">  <span class="comment">/* 这是一张大于limit 大小的图片 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../img/sunlogo.jpg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里是webpack.config.js 代码 */</span></span><br><span class="line"><span class="comment">/* 引用内置的path模块 */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 编写入口</span></span><br><span class="line">  <span class="attr">entry</span> : <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 编写出口, output 是一个对象, 对象包含两个属性, path 路径 和fliename 文件名, 其中path路径必须是绝对路径</span></span><br><span class="line">  <span class="comment">// path绝对路径, 借助了node中的内置模块 path 的resolve方法</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">    <span class="comment">// 设置publicPath, 让导出的每一个url地址在开头都添加上一个前缀地址</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;dist/&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 引入css文件需要局部安装 css-loader 和 style-loader</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">        <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// 设置limit 限制图片的大小, 单位是B, 一般设置位8Kb, </span></span><br><span class="line">            <span class="attr">limit</span>: <span class="number">16000</span>,</span><br><span class="line">            <span class="comment">// 设置name属性, 来设置导出的图片名字</span></span><br><span class="line">            <span class="attr">name</span> : <span class="string">&quot;img/[name].[hash:8].[ext]&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6语法处理"><a href="#ES6语法处理" class="headerlink" title="ES6语法处理"></a>ES6语法处理</h3><ul><li>如果仔细阅读webpack打包的js文件, 会发现写的ES6语法并没有转换成ES5语法, 这就意味着我们的代码不能兼容一些对ES6还不支持的浏览器</li><li>如果要将ES6语法转换为ES5, 那么就需要使用babel<ul><li>命令行输入 npm install –save-dev <a href="mailto:&#98;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#x37;&#46;&#49;&#x2e;&#x35;">&#98;&#97;&#x62;&#x65;&#x6c;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#x37;&#46;&#49;&#x2e;&#x35;</a> babel-core@6.26.3 <a href="mailto:&#98;&#x61;&#98;&#101;&#108;&#45;&#112;&#x72;&#x65;&#x73;&#x65;&#x74;&#x2d;&#101;&#x73;&#x32;&#48;&#x31;&#53;&#x40;&#54;&#46;&#50;&#52;&#x2e;&#x31;">&#98;&#x61;&#98;&#101;&#108;&#45;&#112;&#x72;&#x65;&#x73;&#x65;&#x74;&#x2d;&#101;&#x73;&#x32;&#48;&#x31;&#53;&#x40;&#54;&#46;&#50;&#52;&#x2e;&#x31;</a> (这里是为了模块版本的兼容, 所以需要安装特定版本号的模块)</li><li>配置webpack.config.js文件</li><li>打包即可</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这句是匹配所有.js结尾的文件</span></span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="comment">// 这句是表示除了 node_modules|bower_components 文件夹内的文件</span></span><br><span class="line">  exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">  use: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="comment">// 这里是转换位 ES5代码 的意思</span></span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入Vue-js"><a href="#引入Vue-js" class="headerlink" title="引入Vue.js"></a>引入Vue.js</h3><ul><li>在后续的项目中, 我们会使用Vuejs进行开发, 而且会以特殊的文件来组织Vue的组件<ul><li>所以需要在webpack环境中集成Vuejs</li></ul></li><li>利用npm安装Vue<ul><li>在项目文件目录下, 命令行输入 npm install vue –save</li><li>注意这里要使用 运行时依赖安装 –save<ul><li>因为项目在浏览器中运行的时候要依赖vue的</li></ul></li></ul></li><li>在需要的js文件中引入vue, 并且按照之前学习的语法使用Vue</li><li>编写好vue代码后, 进行打包, 浏览器运行, 会发现报错<ul><li>错误信息提示, 我们使用的时runtime-only(运行时版本)的vue<ul><li>按照vue官网的意思是, 运行时版本的vue比runtime-compiler(完整版的vue)的文件大小要小30%, 所以默认vue是使用运行时版本的, 但是运行时版本的vue不包括编译template模块的功能, 而我们的root组件其实就算是一个template模块, 所以这里会报错</li><li>解决方法, 在webpack.config.js打包工具中配置别名即可(其实就是将默认vue使用的版本修改问完整版的版本)</li></ul></li></ul></li><li>重新打包, 浏览器运行, 就不会报错了</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目文件夹下, 终端输入命令行安装vue --&gt;</span><br><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要使用vue的js文件中的js代码</span></span><br><span class="line"><span class="comment">// 5. 使用Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span> : &#123;</span><br><span class="line">    <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时webpack.config.js中配置Vue的别名</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span> <span class="comment">// 用 webpack 1 时需用 &#x27;vue/dist/vue.common.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="el和template的区别"><a href="#el和template的区别" class="headerlink" title="el和template的区别"></a>el和template的区别</h3><ul><li>如果我们希望修改页面中由vue解析的数据, 那么就必须修改index.html的代码</li><li>如果我们后面自定义了组件, 也必须修改index.html的代码来使用组件</li><li>但是html模板在之后的开发中, 我们不会频繁地修改</li><li>这个时候就需要给Vue实例定义template属性了<ul><li>在Vue实例中,我们定义了el属性, 用域与index.html中的节点进行绑定, 让Vue实例之后可以管理节点中的内容</li><li>在这里我们再给Vue实例再定义一个template属性, 并且编写渲染在页面中的模板</li><li>如果Vue实例中同时定义了template和el, 那么template模板的内容就会替换掉挂载的对应的el的模板</li></ul></li><li>这样做的好处<ul><li>这样做只会, 就不需要再开发中操作index.html了, 只需要再template中写入对应的标签, Vue编译的时候就会将template中的模板替换掉index.html中被el挂载的标签</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 使用Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="comment">// 这个template中的模板,在Vue编译的时候,会替换el绑定的标签</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">data</span> : &#123;</span><br><span class="line">    <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span>,</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue组件化开发引入"><a href="#Vue组件化开发引入" class="headerlink" title="Vue组件化开发引入"></a>Vue组件化开发引入</h3><ul><li>Vue开发过程中, 我们都会采用组件化开发的思想<ul><li>在当前项目中, 我们也可以采用组件化的形式开发</li></ul></li><li>这里是将Vue实例中的emplate, data 抽取出来作为一个js文件模块, 同理也可以抽取实例中的其他option的, 例如 computed, methods等等</li><li>然后再在main中导入这个js文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">template</span> : <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span>,</span><br><span class="line">      <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main中导入上面的js文件</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./vue/test.js&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="vue文件的封装处理"><a href="#vue文件的封装处理" class="headerlink" title=".vue文件的封装处理"></a>.vue文件的封装处理</h3><ul><li>一个组件以一个对象的形式进行组织和使用是非常不方便的<ul><li>一方面编写template模块很麻烦, 模块的代码写在ES6中的模板字符串中, 代码会很乱</li><li>另外, 如果元素有样式的话, 也不知道应该写在哪一个地方</li></ul></li><li>所以现在, 使用一个全新的组件来组织Vue的组件<ul><li>.vue文件就可以解决这个问题</li><li>.vue文件 由三个标签组成<ul><li><template>标签, 里面编写组件模板</li><li><script>标签, 里面编写组件的组件构造器</li><li><style>标签, 里面编写组件模板的样式</li></ul></li></ul></li><li>这是一个新的文件类型, 所以我们需要用webpack中新的loader来处理这类文件</li><li>在项目文件目录下, 命令行输入 npm install –save-dev vue-loader vue-template-compiler  (开发时依赖安装) 注意:这里使用的两个模块的版本分别是 <a href="mailto:&#x76;&#117;&#101;&#x2d;&#108;&#111;&#x61;&#100;&#x65;&#x72;&#64;&#x31;&#x33;&#46;&#48;&#46;&#48;">&#x76;&#117;&#101;&#x2d;&#108;&#111;&#x61;&#100;&#x65;&#x72;&#64;&#x31;&#x33;&#46;&#48;&#46;&#48;</a> 和 <a href="mailto:&#x76;&#117;&#x65;&#45;&#116;&#x65;&#109;&#x70;&#108;&#97;&#116;&#x65;&#45;&#99;&#111;&#109;&#112;&#105;&#108;&#x65;&#114;&#x40;&#x32;&#46;&#x35;&#x2e;&#50;&#x31;">&#x76;&#117;&#x65;&#45;&#116;&#x65;&#109;&#x70;&#108;&#97;&#116;&#x65;&#45;&#99;&#111;&#109;&#112;&#105;&#108;&#x65;&#114;&#x40;&#x32;&#46;&#x35;&#x2e;&#50;&#x31;</a>版本</li><li>在webpack.config.js 文件中修改配置</li><li>然后在main.js文件中引用模块</li><li>并且在Vue实例的components中注册, 这样就可以在Vue实例中的template中使用该组件模块了, 再进行打包即可</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 再项目文件目录下, 命令行输入以下代码, 安装模块 --&gt;</span><br><span class="line">npm install --save-dev vue-loader vue-template-compiler</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是.vue文件</span><br><span class="line">// template标签内编写组件模板</span><br><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;test2&gt;&lt;/test2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// script标签内编写组件构造器, 如果有其他依赖的模块, 也可以用import导入其他的模块</span><br><span class="line">import test2 from &quot;./Test2.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;test&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;你好你好,我是Vue&quot;,</span><br><span class="line">      name: &quot;xiaoLam&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      console.log(&quot;我被点击了&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    test2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">/* style标签内编写样式 */</span><br><span class="line">.title &#123;</span><br><span class="line">  color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后在main.js中导入模块</span></span><br><span class="line"><span class="comment">// 并且在Vue实例的components中注册, 这样就可以在Vue实例中的template中使用该组件模块了</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./vue/Test.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;test&gt;&lt;/test&gt;`</span>,</span><br><span class="line">  <span class="attr">components</span> : &#123;</span><br><span class="line">    test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="认识plugin"><a href="#认识plugin" class="headerlink" title="认识plugin"></a>认识plugin</h3><ul><li><p>什么时plugin</p><ul><li>plugin的意思时插件的意思, 通常是用于对某个现有的架构进行的扩展</li><li>webpack中的插件, 就是对webpack现有功能的各种扩展,比如打包优化,文件压缩等等</li></ul></li><li><p>loader和plugin的区别</p><ul><li>loader主要用于转换某些类型的模块, 他是一个转换器</li><li>而plugin是插件, 是对webpack本事的扩展, 是一个扩展器</li></ul></li><li><p>plugin的使用过程:</p><ul><li>步骤一: 通过npm安装需要使用的plugins(有一写plugin在webpack已经内置了,就不需要安装)</li><li>步骤二: 在webpack.config.js中的plugins中配置插件</li></ul></li></ul><h3 id="添加版权的plugin"><a href="#添加版权的plugin" class="headerlink" title="添加版权的plugin"></a>添加版权的plugin</h3><ul><li>我们可以给打包的文件添加版权声明<ul><li>什么是版权声明<ul><li>百度五分钟</li></ul></li></ul></li><li>添加版权的插件名为BannerPlugin, 属于webpack的内置插件(所以不需要npm安装)</li><li>按照下列代码配置webpack.config.js中的plugins后重新打包程序, 就可以看到打包出来的文件头部多了版权的注释</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用webpack内置的模块</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 在plugins中编写版权plugin</span></span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&quot;最终版权归xiaoLam所有&quot;</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h3><ul><li><p>目前, 我们的index.html文件时存放在项目的根目录中的</p><ul><li>但是,当我们要发布项目到服务器中的时候, 发布的是dist文件夹中的内容, 但是dist文件夹中没有index.html文件, 那么打包的js文件就没有意义了</li><li>所以我们要将index.html文件打包到dist文件夹中, 这个时候就需要用到webpack中的HtmlWebpackPlugin插件了</li></ul></li><li><p>HtmlWebpackPlugin插件有什么用?</p><ul><li>可以自动生成一个index.html文件(并且可以指定模板)</li><li>会将打包的js文件,自动通过script标签插入到body中, 所以原本的index.html文件就不需要script标签了</li></ul></li><li><p>htmlwebpackplugin插件的使用</p><ul><li>安装<ul><li>当前项目目录下 命令行输入 npm install html-webpack=plugin –save-dev (开发时依赖安装)</li></ul></li><li>在webpack.config.js文件中引用插件</li><li>编辑webpack.config.js文件中的plugins部分的内容<ul><li>template填入一个html文件的路径, 表示根据什么模板来生成index.html</li><li>注意, 我们从现在开始就不需要output中以前添加的publicPath属性了, 因为已经将html打包进dist文件夹中了, 否则html文件中的路径引用会有问题</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--在当前项目目录下命令行输入  --&gt;</span><br><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js 文件</span></span><br><span class="line"><span class="comment">// 引入webpack中的html-webpack-plugin模块</span></span><br><span class="line"><span class="keyword">const</span> htmlwebpackplugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">output : &#123;</span><br><span class="line">  <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  <span class="comment">// 设置publicPath, 让导出的每一个url地址在开头都添加上一个前缀地址</span></span><br><span class="line">  <span class="comment">// 在将index.html也一起打包到dist文件夹中的时候, 这句代码就要去掉了 把它注释掉</span></span><br><span class="line">  <span class="comment">// publicPath: &quot;dist/&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span> : [</span><br><span class="line">  <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&quot;最终版权归xiaoLam所有&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> htmlwebpackplugin(&#123;</span><br><span class="line">  <span class="comment">// 给htmlwebpackplugin实例添加一个对象, 对象里面包含template,值为html模板的路径</span></span><br><span class="line">  <span class="attr">template</span> : <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="压缩js的Plugin"><a href="#压缩js的Plugin" class="headerlink" title="压缩js的Plugin"></a>压缩js的Plugin</h3><ul><li>在项目发布的时候, 我们必然需要将js等文件进行压缩<ul><li>将所有的注释, 空格, 换行删除, 并将变量名和函数名转换为最简单的字符串</li><li>以达到文件最小化, 增加传输加载效率</li><li>所以在这里我们使用一个第三方插件uglifyjs-webpack-plugin, 并且为了与接下来学习的脚手架CLI2保持一致, 使用的版本号为 1.1.1</li></ul></li><li>安装uglifyjs-webpack-plugin<ul><li>在项目目录下, 命令行输入, npm install <a href="mailto:&#117;&#103;&#108;&#105;&#102;&#x79;&#x6a;&#115;&#45;&#119;&#101;&#98;&#x70;&#97;&#x63;&#x6b;&#45;&#x70;&#108;&#x75;&#103;&#x69;&#x6e;&#x40;&#49;&#46;&#49;&#46;&#x31;">&#117;&#103;&#108;&#105;&#102;&#x79;&#x6a;&#115;&#45;&#119;&#101;&#98;&#x70;&#97;&#x63;&#x6b;&#45;&#x70;&#108;&#x75;&#103;&#x69;&#x6e;&#x40;&#49;&#46;&#49;&#46;&#x31;</a> –save-dev (使用开发依赖安装)</li></ul></li><li>修改webpack.config.js 配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下， 命令行输入 --&gt;</span><br><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js 中进行配置</span></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">const</span> uglifyjswebpackplugin = requrie(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在plugins中使用该模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> uglifyjswebpackplugin();</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><ul><li>本地服务器的原理<ul><li>在开发过程中，新增的代码代码是经常需要调试的</li><li>但是如果我们每次调试代码的时候, 都要将所有文件打包一次到本地磁盘中, 再在浏览器中运行, 这样的效率是十分低的</li><li>我们可以搭建一个本地服务器, 将这个服务器服务于我们的某个文件夹, 此时这个服务器就会实时地监听代码有没有发生改变</li><li>如果有发生改变的时候, 就会对改变的代码进行编译</li><li>编译后并不会立即生成最终的文件, 也就是不会将编译好的代码存入硬盘中</li><li>而是会将编译好的代码先放入内存中, 让我们进行测试 (这一点很重要), 内存的读取速度是远远大于硬盘的<ul><li>实际上本地服务器的作用就是, 将编写的代码先放入内存中, 而不是原来的放入某个文件夹中, 在测试的时候调用的是内存中的代码, 这样就不需要, 调试新增或者修改的代码的时候, 都要将代码打包到某个文件夹中, 再进行调试, 本地服务器可以实时地监听代码地更新  </li></ul></li><li>在最终想要发布的时候, 再打包一次代码即可</li></ul></li><li>如何搭建本地服务器<ul><li>webpack提供了一个本地开发服务器, 这个本地服务器是基于node.js搭建地, 内部使用express框架, 可以实现我们想要的浏览器自动刷新显示修改代码地效果</li><li>webpack-dev-server 是一个单独的模块, 在webpack中使用需要先安装<ul><li>命令行输入 npm install <a href="mailto:&#x77;&#101;&#x62;&#112;&#97;&#x63;&#x6b;&#x2d;&#x64;&#101;&#118;&#x2d;&#x73;&#x65;&#114;&#x76;&#x65;&#114;&#x40;&#x32;&#x2e;&#57;&#x2e;&#49;">&#x77;&#101;&#x62;&#112;&#97;&#x63;&#x6b;&#x2d;&#x64;&#101;&#118;&#x2d;&#x73;&#x65;&#114;&#x76;&#x65;&#114;&#x40;&#x32;&#x2e;&#57;&#x2e;&#49;</a> –save-dev (为了配合其他模块指定版本问2.9.1, 开发时依赖安装)</li></ul></li><li>在webpack.config.js中配置webpack-dev-server<ul><li>devserver是webpack中的一个option选项, 所以不需要引用</li><li>devserver选项本身可以设置如下属性:<ul><li>contentBase: 填写一个路径, 表示为哪一个文件夹提供本地服务, 默认是根文件夹, 这里我们填写 ./dist</li><li>port : 端口号, 默认是8080</li><li>inline : 设置页面是否实时刷新, 填入一个布尔值</li><li>historyApiFallback: 在SPA页面中, 依赖HTML5的history模式</li></ul></li></ul></li></ul></li><li>运行服务器<ul><li>配置好以上文件后, 在命令行输入 webpack-dev-server 来运行服务器<ul><li>会发现报错, 说没有找到该模块</li><li>原因是, 在命令行直接输入模块名来运行模块, 终端会在全局中寻找该模块, 而我们的webpack-dev-server是局部安装的,所以会报错</li></ul></li><li>局部运行模块的两种方法<ul><li>第一种, 在命令行中完整输入模块路径</li><li>第二种, 配置package.json中的scripts脚本属性<ul><li>–open参数表示, 运行同时直接打开浏览器</li></ul></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下 命令行输入 --&gt;</span><br><span class="line">npm install webpack-dev-server@2.9.1 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span> : &#123;</span><br><span class="line">    <span class="comment">// 指定建立本地服务器的文件夹</span></span><br><span class="line">    <span class="attr">contentBase</span> : <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定是否进行实时刷新页面</span></span><br><span class="line">    <span class="attr">inline</span> : <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置package.json文件中的 scripts脚本属性</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 配置好后, 在命令行输入 npm run dev 就可以运行本地服务器了</span></span><br><span class="line">    <span class="comment">// --open是指, 能够在运行本地服务器的同时打开浏览器</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="webpack的webpack-config-js配置分离"><a href="#webpack的webpack-config-js配置分离" class="headerlink" title="webpack的webpack.config.js配置分离"></a>webpack的webpack.config.js配置分离</h3><ul><li>在实际开发过程中<ul><li>开发时用的配置文件, 和 最终打包的配置文件是不一样的<ul><li>比如说, 在开发中,我们不需要用到uglifyjs-webpack-plugin压缩js这个插件, 在最终打包中不需要用到webpack-dev-server构建本地服务器这个插件</li></ul></li><li>所以我们应该将webpack.config.js中的配置进行抽取分离, 实现在开发中使用一套配置文件, 在打包时使用另一套配置文件</li></ul></li><li>进行配置分离的详细过程<ul><li>第一步, 创建配置文件的文件夹<ul><li>分离出来的配置文件会由一份变成好几份, 所以我们需要用一个新的文件夹来存储它们</li><li>在项目根目录中创建名为build的文件夹, 里面存储配置文件</li></ul></li><li>第二步, 创建配置文件<ul><li>base.config.js 这个配置文件里面包含的是公共的配置</li><li>prod.config.js 这个配置文件里面包含的是打包的时候使用的配置</li><li>dev.config.js 这个配置文件里面包含的是开发的时候使用的配置</li></ul></li><li>第三步, 下载合并配置文件的模块, webpack-merge , 这个模块用于将公共的配置和需要使用的配置合并在一起<ul><li>命令行输入 npm install <a href="mailto:&#x77;&#101;&#x62;&#x70;&#97;&#99;&#107;&#45;&#109;&#101;&#x72;&#x67;&#x65;&#64;&#x34;&#46;&#49;&#46;&#x35;">&#x77;&#101;&#x62;&#x70;&#97;&#99;&#107;&#45;&#109;&#101;&#x72;&#x67;&#x65;&#64;&#x34;&#46;&#49;&#46;&#x35;</a> –save-dev (开发依赖安装)</li></ul></li><li>第四步, 配置webpack-merge模块, 就是简单的引用模块, 使用模块</li><li>第五步, 调整原本配置的出口, 因为将配置文件放在了不同的位置, 所以要将原本配置中的路径修改一下</li><li>第六步, 调整package.json中的scripts脚本, 因为npm执行配置文件的时候, 默认是寻找webpack.config.js文件的, 现在我们修改了文件的名称, 所以要修改scripts脚本</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下, 命令行输入 --&gt;</span><br><span class="line">npm install webpack-merge@4.1.5 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是base.config.js 中的代码</span></span><br><span class="line"><span class="comment">// 其余的代码不变, 只保留公共的部分</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="comment">// 修改了path</span></span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是prod.config.js的代码</span></span><br><span class="line"><span class="comment">// 将只在打包时需要的配置抽取到这里</span></span><br><span class="line"><span class="comment">// 引入压缩js的webpack-plugin的模块</span></span><br><span class="line"><span class="keyword">const</span> uglifyjswebpackplugin = <span class="built_in">require</span>(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入webpack-merge 配置文件合并模块</span></span><br><span class="line"><span class="keyword">const</span> webpackmerge = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入base基本配置文件</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&quot;./base.config.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackmerge(baseConfig, &#123;</span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="keyword">new</span> uglifyjswebpackplugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是dev.config.js的代码</span></span><br><span class="line"><span class="comment">// 将开发时需要的配置抽取到这里</span></span><br><span class="line"><span class="comment">// 引入配置文件合并模块</span></span><br><span class="line"><span class="keyword">const</span> webpackmerge = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入base基本配置文件</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&quot;./base.config.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackmerge(baseConfig, &#123;</span><br><span class="line">  <span class="attr">devServer</span> : &#123;</span><br><span class="line">    <span class="comment">// 指定建立本地服务器的文件夹</span></span><br><span class="line">    <span class="attr">contentBase</span> : <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定是否进行实时刷新页面</span></span><br><span class="line">    <span class="attr">inline</span> : <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时package.json的代码</span></span><br><span class="line"><span class="comment">// 修改scripts</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="comment">// --config 可以将默认使用的webpack.config.js配置文件修改为自定义的配置文件</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./build/prod.config.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> webpack </category>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-Vue的响应式原理</title>
      <link href="2021/05/25/15-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/25/15-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue是如何实现响应式的"><a href="#Vue是如何实现响应式的" class="headerlink" title="Vue是如何实现响应式的"></a>Vue是如何实现响应式的</h3><ul><li>Vue实现响应式要了解两个核心<ul><li>第一个: Vue如何监听data数据的改变</li><li>第二个: data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</li></ul></li></ul><h3 id="Vue如何监听data数据的改变"><a href="#Vue如何监听data数据的改变" class="headerlink" title="Vue如何监听data数据的改变"></a>Vue如何监听data数据的改变</h3><ul><li>实质上vue是通过 defineProperty 方法来监听data数据的改变的</li><li>defineProperty方法需要传入三个参数<ul><li>第一个参数是需要监听的对象(目标对象)</li><li>第二个参数是监听对象的值(引用的目标对象上的字符串键属性)</li><li>第三个参数是一个对象, 对象中编写对应事件</li></ul></li></ul><h3 id="data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素"><a href="#data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素" class="headerlink" title="data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素"></a>data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</h3><ul><li>vue是通过一种名叫 “发布者订阅者” 的模式来知道当data数据修改的时候, 应该修改哪一个使用了data数据的元素的</li></ul><h3 id="代码简单模拟vue的响应式原理"><a href="#代码简单模拟vue的响应式原理" class="headerlink" title="代码简单模拟vue的响应式原理"></a>代码简单模拟vue的响应式原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是简单地模拟一下vue的响应式原理</span></span><br><span class="line"><span class="comment">// vue实现响应式核心为两个</span></span><br><span class="line"><span class="comment">// 第一个: vue如何监听data数据的更改</span></span><br><span class="line"><span class="comment">// 第二个: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来解决第一个问题</span></span><br><span class="line"><span class="comment">// 实质上vue是通过defineProperty方法来监听数据的更改的</span></span><br><span class="line"><span class="comment">// 比如这里的obj对象就是vue中的data对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaolam&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue中会获得这个obj对象, 然后遍历里面的键</span></span><br><span class="line"><span class="comment">// 通过 Object.keys(obj) 来获取obj中的键并组成一个数组</span></span><br><span class="line"><span class="comment">// 然后通过forEach 遍历这个数组, 给数组中的键通过defineProperty方法监听里面的所有key</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 通过defineProperty中的set方法就可以监听obj对象中数据的更改了</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的set&quot;</span>);</span><br><span class="line">      <span class="comment">// 在更改obj中的数据的时候, 调用发布者中的notify方法, 这个方法会调用所有订阅者中的update方法</span></span><br><span class="line">      <span class="comment">// 而update方法里面可以编写更新页面的代码</span></span><br><span class="line">      dep.notify()</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过defineProperty中的get方法就可以监听页面中什么元素的通过mustache语法取用obj数据</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的get&quot;</span>);</span><br><span class="line">      <span class="comment">// 在使用obj的数据后, 将使用数据的元素做一个记录</span></span><br><span class="line">      <span class="comment">// 存储在发布者中</span></span><br><span class="line">      <span class="keyword">const</span> w1 = <span class="keyword">new</span> Watcher(<span class="string">&quot;w1&quot;</span>)</span><br><span class="line">      dep.addSub(w1)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过上面的过程就可以实现第一个问题: vue如何实现监听data数据的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在解决第二个问题: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"><span class="comment">// 实质上vue使用的是一个 发布者订阅者 的技术</span></span><br><span class="line"><span class="comment">// 发布者就是指vue实例</span></span><br><span class="line"><span class="comment">// 而订阅者就是指使用mustache语法的元素</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个数组用于存储订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在元素取用data数据的时候调用Dep中的这个方法, 来将元素(订阅者)加入到subs数组中用于记录订阅者都有谁</span></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">watcher</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里做更新页面的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br></pre></td></tr></table></figure><ul><li>思路为: 订阅者和发布者是两个类, 在项目运行的时候, 就new对应的data属性发布者出来(一个data属性对应一个发布者), 在当有页面元素使用了data数据的时候, 触发了defineProperty中的get, 在get中new一个对应的订阅者出来, 并把这个订阅者通过对应发布者中的addSub方法记录在发布者中, 在data数据中某个属性发生改变的时候, 触发defineProperty中的set方法, 在set方法中调用对应发布者的notify方法, 这个方法会调用其中的每个订阅者中的update方法, 在update方法中就编写更新页面的操作, 就是这样发布者就知道应该让哪个订阅者更新自身的展示数据了, 从而实现响应式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-Vue中axios网络模块封装思路</title>
      <link href="2021/05/25/14-Vue%E4%B8%ADaxios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E6%80%9D%E8%B7%AF/"/>
      <url>2021/05/25/14-Vue%E4%B8%ADaxios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的网络请求模块-以及它们的优缺点对比"><a href="#常见的网络请求模块-以及它们的优缺点对比" class="headerlink" title="常见的网络请求模块, 以及它们的优缺点对比"></a>常见的网络请求模块, 以及它们的优缺点对比</h3><ul><li>传统Ajax请求<ul><li>缺点: 配置和调用方式等非常混乱</li><li>真实开发中真的很少直接使用, 而是使用Jquery-Ajax</li></ul></li><li>Jquery-ajax<ul><li>相对于传统的Ajax非常好用</li><li>但是我们在整个vue的开发中都是不需要使用Jquery的</li><li>那么就意味着为了方便我们进行一个网络请求, 特意引用了一个jQuery, 这显然不合理, Vue的代码才一万多行, jQuery的代码就一万多行了</li><li>完全没有必要为了使用网络请求就引用jQuery这个框架</li></ul></li><li>官方在Vue1.x的时候, 推出了Vue-resource<ul><li>Vue-resource的体积相对于jQuery小很多</li><li>而且Vue-resource是Vue官方推出的</li><li>但是在Vue2.0以后, Vue-resource就不再更新了</li><li>这就意味着如果继续使用Vue-resource的话对项目的开发和维护都存在很大的隐患</li></ul></li><li>axios<ul><li>在尤雨溪宣布不再更新vue-resource的时候, 推荐使用axios</li><li>所以就选axios了</li><li>vue作者都让你选这个了, 你还想啥呢?</li><li>可能你会说, 尤雨溪只是个写轮子的, 他懂个P的vue(/滑稽)</li></ul></li></ul><h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><ul><li>安装axios 在项目根目录下, 命令行输入<ul><li>npm install axios –save (运行时依赖)</li></ul></li><li>导入axios, 直接通过 axios() 使用, 并不需要使用Vue.use(axios) 来install, 因为axios本身并不是vue中的模块, vue并不具有axios的install方法</li><li>axios支持多种请求方式<ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li><li>但是我们一般使用第一个 axios(config) 因为这个灵活, 可以在config里面设置请求方式</li><li>axios的特点: axios() 在网络请求完成后会返回一个Promise对象, 所以我们可以在axios() 后直接使用then() 和catch() </li><li>请看下列代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios 是不需要使用 Vue.use() 方法, 因为axios并不是vue中的模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios有很多种请求方式, 默认的请求方式为get请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 提问这里为什么没有跨域问题?</span></span><br><span class="line">  <span class="comment">// 因为在后端已经处理过跨域了</span></span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;请求的url&quot;</span>,</span><br><span class="line">  <span class="comment">// 可以通过 method 属性来指定请求方式</span></span><br><span class="line">  <span class="attr">method</span> : <span class="string">&quot;post&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用get请求的话, 如果带有参数的话, 需要拼接到url上, 这样会导致url很长, 所以axios提供了一个parmas对象, 用于参数的拼接</span></span><br><span class="line">  <span class="attr">params</span> : &#123;</span><br><span class="line">    <span class="attr">type</span> : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    <span class="attr">page</span> : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios 在网络请求操作完成之后会返回一个 new Promise 对象, 所以这里可以使用then 和catch</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios处理并发请求"><a href="#axios处理并发请求" class="headerlink" title="axios处理并发请求"></a>axios处理并发请求</h3><ul><li>如果我们需要多个axios请求完成后, 再进行下一步的操作</li><li>axios提供了一个 axios.all() 方法, 用于处理这种需求</li><li>这个方法里面传入一个数组, 数组中传入axios请求</li><li>在axios请求都完成后, axios.all() 方法会调用then(), then()中传入一个函数, 函数中有一个result参数</li><li>result是一个数组, 数组中第一个数据即是第一个axios请求返回的数据, 依此类推</li><li>如果想要将各个返回的数据分开的话, then() 中还可以传入一个 axios.spread() 方法, 方法中传入一个函数</li><li>该函数的参数就是对应的axios请求返回的数据</li><li>看以下实例代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios处理并发请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6/home/data&quot;</span>,</span><br><span class="line">    <span class="attr">params</span> : &#123;</span><br><span class="line">      <span class="attr">type</span> : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      <span class="attr">page</span> : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="comment">/* .then((result =&gt; &#123;</span></span><br><span class="line"><span class="comment">  // 这里的result是一个数组, 里面按顺序存放了各个axios请求返回的数据</span></span><br><span class="line"><span class="comment">  console.log(result);</span></span><br><span class="line"><span class="comment">  console.log(result[0]);</span></span><br><span class="line"><span class="comment">  console.log(result[1]);</span></span><br><span class="line"><span class="comment">&#125;)) */</span></span><br><span class="line">.then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios设置全局配置信息"><a href="#axios设置全局配置信息" class="headerlink" title="axios设置全局配置信息"></a>axios设置全局配置信息</h3><ul><li>其实我们的请求中有很多东西都是相同的, 比如url中的baseURL, 和设置的请求超时时间等等</li><li>如果我们每次请求都要重写这些config, 这样代码就很重复了</li><li>所以我们会将固定的参数抽取出来</li><li>axios提供了一个 defaults 对象用于进行全局配置</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span> <span class="comment">// 这里设置了baseURL</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span>  <span class="comment">// 这里设置了请求超时时间</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">    <span class="attr">params</span> : &#123;</span><br><span class="line">      <span class="attr">type</span> :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      <span class="attr">page</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常见的axios配置项"><a href="#常见的axios配置项" class="headerlink" title="常见的axios配置项"></a>常见的axios配置项</h3><ul><li>请求地址<ul><li>url: ‘/user’,</li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象 (注意只有get请求方式才用params)<ul><li>params:{ id: 12 }</li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body (注意只用post请求方式才用这个)<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / + stream<ul><li>responseType: ‘json’,</li></ul></li></ul><h3 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h3><ul><li>在实际开发中, 很有可能会遇到这种状况</li><li>网络请求的baseURL是不一样的, 或者说不同的网络请求设置的请求超时时间是不一样的</li><li>这个时候, 如果我们还是使用全局配置的 axios.default 就无法正确地请求正确的数据了</li><li>所以我们要创建axios实例</li><li>创建axios实例, 通过axios.create创建</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如这里的网络请求, 需要设置的请求超时时间为 5000毫秒</span></span><br><span class="line"><span class="keyword">const</span> instans1 = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 在这里设置配置</span></span><br><span class="line">  <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span> : <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用axios实例</span></span><br><span class="line"><span class="comment">// 与全局中使用axios基本一致</span></span><br><span class="line">instans1(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如这里需要设置请求超时时间为10000</span></span><br><span class="line"><span class="keyword">const</span> instans2 = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span> : <span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用instans2进行网络请求</span></span><br><span class="line">instans2(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">  <span class="attr">params</span> : &#123;</span><br><span class="line">    <span class="attr">type</span> :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    <span class="attr">page</span> : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h3><ul><li>如果我们没有把axios封装到一个文件中, 而是在需要用到axios的组件中都引用axios</li><li>那么如果在未来的某一天, axios突然宣布不再更新</li><li>那我们的项目想要使用另外的替代品将会变得十分困难, 因为我们每个组件都依赖了axios</li><li>为了降低我们各个组件对axios的依赖性</li><li>我们要将axios封装在一个独立的文件中</li><li>封装过程及引用方法请看下列示例代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件 src/network/request.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例并导出</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">    <span class="attr">timeout</span> : <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过组件传入一个函数, 然后回调这个函数返回数据给组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 通过组件传入一个函数, 然后回调这个函数返回数据给组件的另外一种形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config.baseConfig)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    config.success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    config.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">baseConfig</span>: &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实际上, 我们并不会使用以上的两种方法, 而是使用 Promise来返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    instans(config)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 实际上, 我们也不会像上面那样, 因为axios本身就返回一个Promise, 没有必要再包一层</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.res = res;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h3><ul><li>axios提供了拦截器, 用于我们再发送每次请求或者得到相应数据后, 进行对应的处理</li><li>拦截器分为: 请求拦截器 interceptors.request 和 响应拦截器 interceptors.response</li><li>请求拦截器主要用法<ul><li>1.当发送网络请求的时候, 在页面中添加一个loading组件, 作为动画</li><li>2.某些请求是要求用户必须登陆的, 这是请求拦截器就可以判断请求是否带有token(令牌), 如果没有token就跳转到login页面</li><li>3.对请求的参数进行序列化, 就是对请求的参数做一些修改或者添加一些参数</li></ul></li><li>响应拦截器主要用法<ul><li>1.响应的成功拦截中,主要是对数据进行过滤</li><li>2.响应失败的拦截中, 跨域根据status判断报错的错误码, 跳转到不同的错误提示页面</li></ul></li><li>拦截器使用注意事项, 使用拦截器后, 一定要将数据 return 出去, 否则, 拦截器会把数据拦截住</li><li>基本使用方法看下列代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 使用拦截器</span></span><br><span class="line">  <span class="comment">// 请求拦截器</span></span><br><span class="line">  instans.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config  <span class="comment">// 将数据在return出去</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">  instans.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> res.data  <span class="comment">// 将数据进行过滤, 只返回data</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真实的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-Vue-Vuex全局状态管理详解</title>
      <link href="2021/05/25/13-Vue-Vuex%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/13-Vue-Vuex%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h3><ul><li>官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式<ul><li>采用集中式存储管理应用的所有组件的状态, 并以相应的规则保证状态以一种可以预测的方式发生变化</li><li>Vuex 也继承到Vue官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试 状态快照导入导出等高级调试功能</li></ul></li><li>官方解释其实有点晦涩难懂<ul><li>状态管理模式, 集中式存储管理其实</li><li>就是将需要多个组件共享的变量存储在一个对象中</li><li>然后将这个对象放在顶层的Vue实例中,让其他组件也可以使用</li><li>而且这个对象是响应式的, 这个优点是最牛逼的优点</li></ul></li><li>什么状态需要我们在多个组件间共享呢?<ul><li>用户的登陆状态,用户名称,头像,地理位置信息等等</li><li>商品的收藏,购物车中的物品</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们可以尝试一下自己写一下这个共享的对象</span></span><br><span class="line"><span class="comment">// 通过将数据集成在一个共享对象中, 然后将这个对象加入到Vue.prototype 原型对象中, 可以做到将对象中的数据共享出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用给Vue.prototype Vue的原型对象添加一个对象来达到所有组件都可以访问这个对象</span></span><br><span class="line"><span class="keyword">const</span> shareObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">  <span class="attr">age</span> : <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.shareObj = shareObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是有一个问题, 这个共享对象不是响应式的, 所以我说vuex的共享数据是响应式的是最牛逼的优点</span></span><br></pre></td></tr></table></figure><h3 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h3><ul><li>vuex的安装<ul><li>在项目根目录下命令行输入 npm install vuex –save (运行时依赖安装)</li></ul></li><li>不建议在main.js中使用vuex</li><li>在项目目录下创建一个叫 store的文件夹, 里面创建一个名为 index.js 的文件, 在这个文件中编写vuex的代码</li><li>vuex插件基本使用 在store/index.js文件中<ul><li>引入 vue 和 vuex 因为vuex是依赖vue的</li><li>执行 Vue.use(Vuex) 执行 Vuex中的 install</li><li>创建Vuex实例: 注意,这里创建的是 Vuex.Store实例</li><li>在实例中创建一个 state对象, 在这个对象中写入想要共享的数据</li><li>导出实例</li></ul></li><li>在组件中使用vuex中的共享数据<ul><li>在main.js 中导入上面的实例</li><li>在根组件中注册store , 这样才可以在所有组件中通过 $store 获得store这个对象</li><li>在组件中使用 $store.state 获得这个包含共享数据的对象</li></ul></li><li>修改vuex中的共享数据<ul><li>其实我们可以通过 $store.state 来修改数据</li><li>但是vue官方不建议这样做</li><li>因为 State -&gt; Vue Components -&gt; Actions -&gt; Mutations -&gt; State 是一个单向循环</li><li>官方推荐做法是 我们通过 Vue Components 去修改 Actions 来修改 Mutations 最终达到修改 State 的目的</li><li>因为我们会需要知道是哪一个组件修改了State, 如果直接从 Vue Components 修改State的话就不能追踪是哪个组件修改了State</li><li>Backend API 会监测 Action的改变, Devtools 会监测 Mutations的改变, 按照官方的推荐做法就可以追踪是哪个组件修改了State</li><li>当然也可以跳过Actions, 通过 Vue Components -&gt; Mutations -&gt; State 修改 </li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 文件的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步: 引入插件后, 调用Vue.use() 来进行install Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步: 创建Vuex实例: 注意这里创建的是 Vuex中的Store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步: 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js中的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 在根组件中注册 store, 这样就可以在所用组件通过 $store 来获得store这个对象</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用过$store.state 来获得store对象中的state中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>------------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;hello-vuex :count=&quot;count&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面会讲如何正确地修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-devtools-和-mutations"><a href="#vue-devtools-和-mutations" class="headerlink" title="vue-devtools 和 mutations"></a>vue-devtools 和 mutations</h3><ul><li>什么是vuex-devtools<ul><li>这是一个vue官方的浏览器插件, 用于调试vue应用</li><li>这个插件可以用于监控mutations操作</li></ul></li><li>什么是mutations操作<ul><li>其实就是使用同步的操作去修改state共享数据</li></ul></li><li>简单来说, 浏览器插件vuex-devtools可以监控mutations操作, 达到追踪是什么组件修改了state共享数据的效果</li></ul><h3 id="vue-devtools-和-mutations-的使用的注意事项"><a href="#vue-devtools-和-mutations-的使用的注意事项" class="headerlink" title="vue-devtools 和 mutations 的使用的注意事项"></a>vue-devtools 和 mutations 的使用的注意事项</h3><ul><li><p>浏览器安装vue-devtools</p><ul><li>chrome应用商店搜索, vue.js devtools 安装即可</li><li>如果进入不了chrome应用商店, 可以离线下载谷歌访问助手</li><li>安装完成后会在浏览器开发者工具中多了一个”vue”选项卡</li></ul></li><li><p>通过mutations来修改state共享数据</p><ul><li>在 store/index.js 中的Vuex.Store实例中创建 mutations对象</li><li>在对象中编写方法</li><li>mutations中的方法默认会有一个名为state的参数, 这个state就是 state共享数据对象</li><li>定义好方法后, 通过提交的方式来调用方法</li><li>具体看以下代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是组件中定义的methods</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span><br><span class="line">    <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="以上就是Vuex最简单的使用了"><a href="#以上就是Vuex最简单的使用了" class="headerlink" title="以上就是Vuex最简单的使用了"></a>以上就是Vuex最简单的使用了</h3><ul><li>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</li><li>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</li><li>3.在其他组件中使用store对象中保存的状态即可<ul><li>通过this.$store.state.属性的方式来访问状态</li><li>通过this.$store.commit(‘mutation中方法’)来修改状态</li></ul></li><li>注意事项：<ul><li>我们通过提交mutation的方式，而非直接改变store.state.count。</li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li></ul></li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State, Getters, Mutation, Action, Module</li></ul><h3 id="Vuex概念理解-State单一状态树"><a href="#Vuex概念理解-State单一状态树" class="headerlink" title="Vuex概念理解-State单一状态树"></a>Vuex概念理解-State单一状态树</h3><ul><li>Vuex提出单一状态树, 什么是单一状态树呢?<ul><li>单一状态树英文名称为 Single Source of Truth 也可以翻译成单一数据源</li></ul></li><li>简单来说, 就是将所有的数据都放在同一个Store对象中, 不要因为数据的类型不同, 数据量多而分开放</li><li>如果我们将数据保存在多个Store对象中的话, 那么之后的管理和维护等都会变得特别困难</li><li>所以Vuex推荐使用单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们用最直接的方式找到某个状态的片段,而且在以后的维护和调试过程中, 也可以非常方便地管理和维护</li><li>总的来说, 就是不要创建多个Store对象, 只创建一个!!! 所有数据, 所有方法, 都放在这个Store对象中</li></ul><h3 id="Vuex核心概念之-getters"><a href="#Vuex核心概念之-getters" class="headerlink" title="Vuex核心概念之 getters"></a>Vuex核心概念之 getters</h3><ul><li>如果我们需要将state中的共享数据经过处理后再将其渲染在页面中的话, 就需要使用 Vuex中的getters对象</li><li>实质上, getters 相当于Vue中的计算属性 computed</li><li>getters的使用<ul><li>在Vue.store实例中定义getters对象</li><li>在getters对象中定义方法</li><li>在getters对象中的方法都具有两个参数, state 和 getters<ul><li>state参数指向state对象</li><li>getters参数指向getters对象</li></ul></li><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li><li>在组件中通过 $store.getters 来获得这个getters对象</li></ul></li><li>具体使用方法看下列代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是 store/index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="attr">students</span> : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span> : &#123;</span><br><span class="line">    <span class="comment">// 在我们需要将共享数据进行处理后再展示在页面的情况下, 就需要使用getters对象, 相当于计算属性computed</span></span><br><span class="line">    <span class="comment">// getters中的方法也是有一个state参数, 指向state对象</span></span><br><span class="line">    <span class="function"><span class="title">powerCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求1, 过滤state中的students, 取出年龄大于15的</span></span><br><span class="line">    <span class="function"><span class="title">getAge15</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; <span class="number">15</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求2, 获得年龄大于15的student的个数</span></span><br><span class="line">    <span class="function"><span class="title">getAge15Num</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// return state.students.filter(students =&gt; students.age &gt; 15).length</span></span><br><span class="line">      <span class="comment">// getters对象中的方法, 除了state这个参数外, 还有getters参数, 这个参数指向getters对象</span></span><br><span class="line">      <span class="comment">// 所以上面的写法可以写成</span></span><br><span class="line">      <span class="keyword">return</span> getters.getAge15.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求3, 想要通过用户输入的年龄, 来决定输出大于该年龄的student</span></span><br><span class="line">    <span class="comment">// getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">    <span class="comment">// 要达到这个需求的话, 需要在方法中返回一个函数, 具体如下</span></span><br><span class="line">    <span class="comment">// 思路是return出去一个函数, 这个函数有一个形参, 这个形参由用户来决定</span></span><br><span class="line">    <span class="function"><span class="title">getAge</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过$store.getters 来获取getters中的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.powerCount &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15Num &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge(17) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vuex核心概念之-mutations"><a href="#Vuex核心概念之-mutations" class="headerlink" title="Vuex核心概念之 mutations"></a>Vuex核心概念之 mutations</h3><ul><li>Vuex的store状态的更新唯一方式是: 提交 Muattion</li><li>Mutation主要包括两个部分<ul><li>字符串的事件类型(type)</li><li>一个回调函数是(handler), 这个回调函数的第一个参数就是state 指向state对象</li></ul></li><li>mutation的基本使用<ul><li>在 store/index.js 中的Vue.store实例中创建 mutations对象</li><li>这个对象中编写方法</li><li>这个对象中的方法中的第一个参数为 state , 指向state对象</li><li>后面的参数是Vue Components传递过来的额外参数(称为载荷Payload)</li><li>定义好方法后, 在组件中使用 $state.commit(“事件类型”) 提交, 达到更新状态的效果</li><li>具体使用看下列代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是 store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="attr">students</span> : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">      state.count += count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果参数的个数不是一个的时候, 我们可以传入一个对象</span></span><br><span class="line">    <span class="function"><span class="title">addStudent</span>(<span class="params">state,student</span>)</span> &#123;</span><br><span class="line">      state.students.push(student)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这些是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count++&quot;&gt;+&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 官方建议这样来修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addtion&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;subtraction&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(10)&quot;</span>&gt;</span>+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addStudent&quot;</span>&gt;</span>添加学生<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// ..</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果带有参数(载荷)， 则在 $store.commit(&quot;事件类型&quot;, 载荷)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$store.commit(&quot;incrementCount&quot;, count);</span></span></span><br><span class="line"><span class="javascript">      </span></span><br><span class="line"><span class="javascript">      <span class="comment">// </span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> student = &#123; <span class="attr">id</span>: <span class="number">115</span>, <span class="attr">name</span>: <span class="string">&quot;wuming&quot;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果参数不止一个, 载荷也可以是一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, student);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mutation提交风格"><a href="#Mutation提交风格" class="headerlink" title="Mutation提交风格"></a>Mutation提交风格</h3><ul><li>上面的通过commit进行提交时一种普通的方式</li><li>Vue还提供了另外一种风格, 它是一个包含type属性的对象</li><li>提交的风格不同, Mutation中的处理方式也会不同<ul><li>普通的提交方式, mutations中的payload就是传入的参数</li><li>包含type属性的对象提交风格, mutations中的payload是整个commit提交的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 普通的提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;incrementCount&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个包含type属性的对象提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;incrementCount&quot;</span>, <span class="comment">// type属性, 值为 &quot;事件类型&quot;</span></span><br><span class="line">        count, <span class="comment">// 后面跟的是需要传入的参数</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下文的 payload 指 count形参</span></span><br><span class="line">    <span class="comment">// 普通的提交风格接收参数, 这个 payload 就是传入的参数</span></span><br><span class="line">    <span class="comment">// state.count += count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含type属性的对象提交的时候, 这个payload就不是传入的参数了, 而是整个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(count); <span class="comment">// &#123;type: &quot;incrementCount&quot;, count: 5&#125;</span></span><br><span class="line">    <span class="comment">// 要获得传入的参数, 则是 payload.count</span></span><br><span class="line">    state.count += count.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation的响应式规则"><a href="#Mutation的响应式规则" class="headerlink" title="Mutation的响应式规则"></a>Mutation的响应式规则</h3><ul><li>Vuex的store中的state是响应式的, 当state中的数据发生改变的时候, Vue组件也会跟着自动更新</li><li>如果我们想要使用响应式, 那么我们必须遵守一些Vuex的规则<ul><li>拥有响应式的数据必须提前在state中初始化所需的属性</li></ul></li><li>例如: 如果我们给一个对象添加一个新属性的话, 这个操作不是响应式的, 因为这个新属性没有提前在state中初始化</li><li>又例如: 我们给一个对象删除一个属性, 这个操作也不是响应式的</li><li>那么我们如何让这些操作达到响应式的效果呢?<ul><li>这是要是用 Vue.set() 和 Vue.delete() 这两个方法了<ul><li>Vue.set(要修改的数组或对象, Number/String, 修改后的值)</li><li>Vue.delete(要修改的数组或对象, Number/String)</li></ul></li><li>这两个方法Vue中的内部操作就是, 将要修改的属性添加到 Vue中的响应式系统中</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">info</span> : &#123; <span class="attr">id</span> : <span class="number">102</span>, <span class="attr">name</span> : <span class="string">&quot;fanghuonv&quot;</span>, <span class="attr">age</span> : <span class="number">16</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">infoUpdate</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果给state中的对象属性修改值, 这个操作是响应式的, 因为修改的属性提前在state种初始化了</span></span><br><span class="line">      <span class="comment">// state.info.age = 19;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象添加新的属性, 这个操作不是响应式的, 因为这个新属性并没有提前在state中初始化</span></span><br><span class="line">      <span class="comment">// state.info[&quot;address&quot;] = &quot;jisichang&quot;</span></span><br><span class="line">      <span class="comment">// 如果要想这个操作也变成响应式的话, 就要使用Vue.set(要修改的数组或对象, Number/String, 修改后的值)</span></span><br><span class="line">      <span class="comment">// Vue.set(state.info, &quot;address&quot;, &quot;jisichang&quot;) </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象删除属性, 这个操作也不是响应式的</span></span><br><span class="line">      <span class="comment">// delete state.info.id;</span></span><br><span class="line">      <span class="comment">// 如果想要这个操作也变成响应式的话, 就要使用Vue.delete(要修改的数组或对象, Number/String)</span></span><br><span class="line">      Vue.delete(state.info, <span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Vue.set() 和 Vue.delete() 这两个方法内部会将 要修改的属性也一起添加到Vue的响应式系统里面了 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation常量类型"><a href="#Mutation常量类型" class="headerlink" title="Mutation常量类型"></a>Mutation常量类型</h3><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)</li><li>当我们的项目越来越大的时候, Vuex管理的状态越来越多, 需要更新状态的情况也越来越多, 那么就意味着Mutation中的方法越来越多</li><li>方法过多的时候, 使用者需要花费大量的精力去记住这些方法,甚至是多个文件间切换, 查看方法名称, 甚至如果不是复制方法名称的时候, 还有可能出现写错的情况</li><li>那么如何解决上述的问题呢?<ul><li>一种常见的方案就是使用常量替代Mutation事件类型</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型都一目了然</li></ul></li><li>具体做法<ul><li>在store文件夹中创建一个名为 mutations-type.js 的文件</li><li>定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是store/mutations-type.js中的代码</span></span><br><span class="line"><span class="comment">// 在这里定义常量 用于 替代Mutation事件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&quot;increment&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT =<span class="string">&quot;decrement&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT_COUNT =<span class="string">&quot;incrementCount&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_STUDENT = <span class="string">&quot;addStudent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INFO_UPDATE = <span class="string">&quot;infoUpdate&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 引入定义常量名称的文件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line"><span class="javascript">  INCREMENT,</span></span><br><span class="line"><span class="javascript">  DECREMENT,</span></span><br><span class="line"><span class="javascript">  INCREMENT_COUNT,</span></span><br><span class="line"><span class="javascript">  ADD_STUDENT,</span></span><br><span class="line"><span class="javascript">  INFO_UPDATE,</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-type&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里就可以直接使用常量名字代替mutation事件类型了</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 中的文件</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-type&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// 定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><ul><li>通常情况下, Vuex要求我们的Mutation中的方法必须都是同步方法<ul><li>原因是, 当我们使用devtools时, devtools可以帮助我们捕捉mutation的快照</li><li>但是如果时异步操作的话, devtools就不能追踪这个异步操作是什么时候被完成</li></ul></li><li>所以, 通常情况下, 不能在mutation种进行异步操作</li></ul><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li>如果我们需要在Vuex中进行一些异步操作, 比如网络请求</li><li>这个时候我们就要将异步操作在actions中进行</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的<ul><li>actions中定义方法与在mutation中定义方法的方式基本一样</li><li>要注意的是, actions中的方法中第一个参数不是state 而是 context<ul><li>context 意为 上下文, 指向store 对象</li></ul></li><li>还有一点, 组件中向actions提交事件类型, 并不是通过 commit, 而是通过 dispatch</li></ul></li><li>actions的基本使用<ul><li>注意: 我们不可以直接在actions中通过异步操作直接更新store的状态</li><li>更新store的状态的唯一方式为 mutations</li><li>所以actions中的方法实质上只是一个中转站, 更新store的状态这个操作最终还是要在mutations中进行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是store/index.js中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    [INFO_UPDATE](state) &#123;</span><br><span class="line">      <span class="comment">// actions中的方法最终还是要回到mutations中来更新store的状态</span></span><br><span class="line">      state.info.name = <span class="string">&quot;huixinge&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span> : &#123;</span><br><span class="line">    <span class="comment">// 在actions中编写方法, 跟在mutations中编写方法差不多, 但是方法中传入的第一个参数并不是state, 而是 context</span></span><br><span class="line">    <span class="comment">// context意为 上下文, 可以理解为store这个对象</span></span><br><span class="line">    <span class="comment">// 如果想要传入参数, 也是跟mutations中的方法一样, 也是有普通方式, 和传入一个包含type属性的对象方式</span></span><br><span class="line">    [A_INFO_UPDATE](context) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求, 需要异步操作完成后, 给组件返回一个信息</span></span><br><span class="line">    <span class="comment">// 第一种方式, 通过组件传参的时候传入一个函数, 在actions中进行异步操作, 异步操作完成后回调这个函数</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">        <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">        payload.finsh();</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式不够优雅, vue官方推荐我们通过 return 一个new Promise 对象来实现</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="comment">// 在这里return 出去的是回到组件那里的, 所以组件那里的代码可以用then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(INFO_UPDATE)</span><br><span class="line">          <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">          resolve(<span class="string">&quot;完成了完成了&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是组件中的代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">aInfoUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 提交给actions 要用 dispatch 而不是commit</span></span><br><span class="line">      <span class="comment">// commit是提交给mutations的</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(A_INFO_UPDATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一种方式: 通过传入一个函数, 在异步操作完成后进行回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>: A_INFO_UPDATE,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">finsh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;完成了&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二种方式: 通过 Promise 对象</span></span><br><span class="line">      <span class="built_in">this</span>.$store</span><br><span class="line">        .dispatch(&#123;</span><br><span class="line">          <span class="attr">type</span>: A_INFO_UPDATE,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// actions中return回来的 Promise 是在这里的, 所以这里能用then</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><ul><li>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<ul><li>Vue使用单一状态树, 那就意味着很多状态都会交给同一个store管理</li><li>当应用变得非常复杂的时候, store对象就会变得十分臃肿</li><li>为了解决这个问题啊,Vuex允许我们将store分割成模块(Module), 而每个模块都拥有自己的state, mutations, actions, getters</li></ul></li><li>实质就是将共性多的store抽离出去, 这样易于后期维护</li><li>在Module中的 state, mutations, actions, getters 和原来的没有什么区别</li><li>只是有一些需要注意的点<ul><li><ol><li>在组件中想要使用模块中的state共享数据, 通过 $store.state.模块名.数据名 , 来获取</li></ol></li><li><ol start="2"><li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象.</li></ol></li><li><ol start="3"><li>在actions中的第一个参数里面 可以通过 context.rootState 来获取根的state</li></ol></li><li><ol start="4"><li>在actions中使用 context.commit(“事件类型”) 是提交给模块中的mutations, 而不是根的</li></ol></li><li><ol start="5"><li>在getters的方法中, 拥有第三个参数 rootState, 这个参数指向根的state</li></ol></li><li><ol start="6"><li>其余大多数使用方法与原本的一致</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 在组件中如果要获取这个name, 则是通过 $store.state.ModuleA.name 来获取</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="number">111</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullName2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName + <span class="number">222</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 除了基本的写法外, 模块中的getters中的函数还有第三个参数, 为 rootState, 指向根的state</span></span><br><span class="line">    <span class="function"><span class="title">fullName3</span>(<span class="params">state,getters,rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName2 + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">nameUpdate</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span> : &#123;</span><br><span class="line">    <span class="comment">// context 意为上下文 所以这里指向这个模块</span></span><br><span class="line">    <span class="function"><span class="title">AnameUpdate</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(context);</span></span><br><span class="line">        context.commit(<span class="string">&quot;nameUpdate&quot;</span>, payload)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">modules</span> : &#123;</span><br><span class="line">    ModuleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>当我们Vuex帮助我们管理过多内容的时候, 会发现index.js文件变得很乱, 我们要将index.js文件解构, 让我们的代码更加清晰</li><li>以下操作都在store文件夹中进行<ul><li>创建getters.js文件, 将index.js中的getters对象抽取到这个文件中</li><li>创建mutations.js文件, 将index.js中的mutations对象抽取到这个文件中</li><li>创建actions.js文件, 将index.js中的actions对象抽取到这个文件中</li><li>创建modules文件夹, 里面创建ModuleA.js文件, 将ModuleA模块抽取到这个文件中</li></ul></li><li>这样我们的代码就变得很清晰了, 方便后期的维护和更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-Vue-Router路由详解</title>
      <link href="2021/05/25/12-Vue-Router%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/12-Vue-Router%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><ul><li>路由是一个网络工程中的一个术语<ul><li>路由(routing) 就是通过互联的网络把信息从源地址传输到目的地址的活动</li></ul></li><li>路由器提供了两种机制: 路由和传送<ul><li>路由是绝对数据包从来源到目的地的路径</li><li>传送将输入端的数据转移到合适的输出段</li></ul></li><li>路由中有一个非常重要的概念叫路由表<ul><li>路由表本质就是一个映射表, 决定了数据包的指向</li></ul></li><li>相关概念<ul><li>内网IP, 每一个链接上网络的设备都有一个内网IP, 这个内网IP是为了区分链接同一个局域网的不同设备, 在同一个局域网中的每个设备的内网IP是唯一的</li><li>公网IP, 公网IP是一个局域网对外链接是用于区分不同局域网的, 每一个局域网的公网IP都是唯一的</li><li>路由中有一个映射表, 将局域网中的内网IP和设备的mac地址对应起来</li></ul></li><li>举个例子<ul><li>现在有一条信息从北京发到广东</li><li>这条信息途中会进过很多路由, 并根据公网IP找到对应的局域网</li><li>再通过路由中的映射表, 找到要传送的设备mac地址对应的内网IP, 再传送给正确的设备</li></ul></li></ul><h3 id="认识web开发的三个阶段"><a href="#认识web开发的三个阶段" class="headerlink" title="认识web开发的三个阶段"></a>认识web开发的三个阶段</h3><h4 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h4><ul><li>在早期的网站开发中, 整个HTML页面都是由服务器渲染出来的</li><li>用户在浏览器中输入URL后, 浏览器向服务器发出请求</li><li>服务器直接生产整个渲染好的html页面, 返回给客户端进行展示</li><li>一个网站有那么多个页面, 服务器是怎么处理的呢?<ul><li>一个页面对应一个URL</li><li>URL会发送给服务器, 服务器通过正则对URL进行匹配, 并且最后交给一个Controller进行处理</li><li>Controller进行各种各样的处理后, 将最终生成的HTML页面, 返回给前端</li><li>这就完成了一个IO(input/output)操作</li></ul></li><li>以上的操作就是后端路由(也称为后端渲染)<ul><li>当页面需要请求不同的页面路径内容的时候, 全部交给后端服务器处理, 后端服务器渲染好整个页面后, 将页面返回给客户端</li><li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 因为在后端服务器已经加载完毕了, 可以直接交给浏览器展示, 这样的操作有利于SEO(搜索优化)</li></ul></li><li>后端路由(后端渲染)的缺点<ul><li>整个页面的模块由后端人员来编写和维护</li><li>前端开发人员如果要开发页面, 需要通过PHP和java等语言来编写页面代码</li><li>而且通常情况下, HTML代码和数据以及它们的对应逻辑会混合在一起, 编写和维护都是非常糟糕的事情</li></ul></li><li>总流程就是, 后端路由就是, 客户端输入URL请求页面, 服务器端接收URL, 服务器端处理URL和页面的映射关系, 服务器端通过java从数据库中读取数据结合html和css加载整个页面, 将整个页面返回给客户端</li></ul><h4 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h4><ul><li>随着Ajax的出现, 就有了前后端分离的开发模式</li><li>前端通过Ajax请求数据, 后端提供API来返回数据, 前端通过JavaScript将返回来的数据渲染到页面中</li><li>这样做的最大优点就是将前后端的责任清晰化, 前端专注于交互和可视化, 后端专注于数据</li><li>并且在移动端(IOS/Android)出现后, 后端不需要再开发其他的接口, 依然使用之前的一套API即可</li><li>目前很多网站都是采用这种开发模式</li><li>总流程是, 前后端分离就是, 客户端输入URL请求页面的时候, 服务器会先从静态资源服务器中返回html+css+js, 然后在前端使用js代码通过Ajax请求API数据, 服务器端再提供API接口服务, 在前端接收到API数据后渲染页面</li><li>大部分代码都是在前端执行并渲染的, 所以叫前端渲染</li></ul><h4 id="单页面富应用-SPA-阶段"><a href="#单页面富应用-SPA-阶段" class="headerlink" title="单页面富应用(SPA)阶段"></a>单页面富应用(SPA)阶段</h4><ul><li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</li><li>也就是前端来维护一套路由规则</li><li>静态资源服务器中的html+css+js代码只有一套, 这一套代码包含了很多的组件, 用户在客户端请求页面的时候, 会将这一套代码全部返回给客户端, 用户在该页面请求其他页面的时候, 通过前端路处理URL和页面映射关系, 然后通过Ajax请求API数据, 实现显示不同的组件</li></ul><h4 id="一些概念问题"><a href="#一些概念问题" class="headerlink" title="一些概念问题"></a>一些概念问题</h4><ul><li>如何区分前端渲染和后端渲染<ul><li>前端渲染就是大部分代码都是在前端执行并且渲染</li><li>后端渲染是指客户端请求页面时, 后端服务器渲染整个页面并返回,称为后端渲染</li></ul></li><li>什么是前后端分离<ul><li>前端负责页面交互和可视化, 通过Ajax来请求数据, 后端专注于数据</li></ul></li><li>什么是前端路由,什么是后端路由<ul><li>前端路由是指, 在前端处理URL和页面的映射关系</li><li>后端路由是指, 在客户端发送URL请求后, 在后端服务器处理URL和页面的映射关系</li></ul></li></ul><h3 id="前端路由的核心-改变URL-但是页面不进行整体的刷新"><a href="#前端路由的核心-改变URL-但是页面不进行整体的刷新" class="headerlink" title="前端路由的核心: 改变URL, 但是页面不进行整体的刷新"></a>前端路由的核心: 改变URL, 但是页面不进行整体的刷新</h3><ul><li>通过改变URL的hash值<ul><li>URL的hash也就是锚点(#), 本质是改变window.loaction和href属性</li><li>我们可以通过直接复制loaction.hash来改变href, 但是页面不发生刷新</li></ul></li><li>通过HTML5的history模式: pushState<ul><li>history接口时HTML5新增的, 它有五种模式改变URL而不刷新页面<ul><li>history.pushState(state, title, url), 通过栈结构压入一个新的URL</li><li>history.replaceState(), 修改当前的 history 实体。通过这个接口改变的URL, 不能使用history.back() 后退历史记录</li><li>history.go(num) 前进或者后退指定数量历史记录 num可以时负数, 代表后退</li><li>history.back() 后退, 相当于history.go(-1)</li><li>history.forward() 前进, 相当于history.go(1)</li></ul></li></ul></li></ul><h3 id="vue-router的安装"><a href="#vue-router的安装" class="headerlink" title="vue-router的安装"></a>vue-router的安装</h3><ul><li>我们已经学习过webpack了, 后续开发都是通过工程化的方式进行开发<ul><li>所以在后续, 我们直接使用npm进行安装路由即可</li></ul></li><li>步骤一: 安装路由vue-router (在使用脚手架初始化项目的时候, 会询问是否安装vue-router, 如果安装过了可以在package.json中看到已经有vue-router模块了, 那就不需要再安装了, 如果当时没有安装, 那么现在就可以用npm安装)<ul><li>在当前项目目录下, 命令行输入 npm install vue-router –save(注意时运行时依赖安装)</li></ul></li><li>步骤二: 在模块化工程中使用路由(因为vue-router是一个插件, 所以要通过Vue.use()来安装路由功能)<ul><li>第一步: 在src文件夹中的router文件夹中的index.js文件中(遵循模块化管理代码), 导入vue-router和vue, 并且调用Vue.use()来安装路由功能<ul><li>为什么要使用Vue.ues(), Vue.use() 会去执行插件中的 install方法</li></ul></li><li>第二步: 创建路由实例, 并且编写路由映射配置</li><li>第三步: 在Vue实例中挂载创建的路由实例 </li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是src/router/index.js 中的代码</span></span><br><span class="line"><span class="comment">// 引入路由需要的相关模块 vue 和 vue-router</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建路由需要三步</span></span><br><span class="line"><span class="comment">// 1. 通过Vue.use() 使用路由</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个路由实例</span></span><br><span class="line"><span class="comment">// 抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  <span class="comment">// 注意这个option名 必须是routes</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将路由导出, 并在main.js中的Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main.js中导入并在Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="comment">// 导入router路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 挂载路由实例</span></span><br><span class="line">  <span class="comment">// router : router  可以简写成, 对象增强语法</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vue-router的使用"><a href="#vue-router的使用" class="headerlink" title="vue-router的使用"></a>vue-router的使用</h3><ul><li>第一步: 创建路由组件, 因为路由时一个一个的url和组件的映射关系, 所以先创建好路由组件</li><li>第二步: 配置路由映射, 在router文件夹中的index.js 中配置组件和路径的映射关系</li><li>第三步: 在根组件中, 通过标签 router-link  和  router-view 使用路由<ul><li>router-link&gt;: 这个标签是一个vue-router中内置的组件, 它最终会被渲染成一个 a 标签</li><li>router-view&gt;: 这个标签会根据当前的路径, 动态渲染出不同的组件</li><li>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等等回合 router-view&gt; 处于同一个等级</li><li>在路由切换的时候, 切换的是 router-view&gt; 中挂载的组件, 其他内容是不会发生改变的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时在src/components文件夹中的两个子组件</span></span><br><span class="line"><span class="comment">// 这些是Home组件中的代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是Home内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时About组件的代码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是关于里面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;About&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">message</span>: <span class="string">&quot;这里是关于&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是src/router文件夹中的index.js代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;../components/Home.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;../components/About.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 一条映射信息就是一个对象, 对象中的path和component构成一个映射</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    <span class="attr">component</span>: Home <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 在根组件中的template中使用<span class="tag">&lt;<span class="name">router-link</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 来使用路由</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> // 这个标签会根据 to属性中的值来修改 url, 此时<span class="tag">&lt;<span class="name">router-view</span>&gt;</span>显示对应的组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>  // 这个标签是用来决定组件显示的位置的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><ul><li>在通常情况下, 我们输入网站URL, 进入网站的首页, 我们希望 router-view  直接渲染出首页的内容</li><li>但是现在, 默认是没有显示首页的组件内容的, 而是要用户点击了首页的 router-link 标签才会显示</li><li>那么如何让路径默认跳转到首页, 而且 router-view  渲染首页组件呢?<ul><li>非常简单, 只要在路由配置中多配置一个映射就可以了<ul><li>配置内容为 path: “/“ 这里的意思是, 配置根路径</li><li>redirect : “/name” redirect翻译为重定向, 就是重新定义方向</li></ul></li><li>配置解析<ul><li>在routes中新配置一个映射</li><li>path 配置的是一个根路径 “/“</li><li>redirect是重定向, 表示我们将根路径重新定向到 /home 的路径下,这样我们就可以等我们想要的结果了</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置的index.js文件</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&quot;/&quot;</span>, <span class="comment">// 将path配置为根路径</span></span><br><span class="line">    <span class="attr">redirect</span> : <span class="string">&quot;/home&quot;</span> <span class="comment">// 重定向, 将根路径重新定向给 /home</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><ul><li>通过改变hash值来改变网页的URL, 地址末尾会有一个/# 不好看</li><li>如果通过HTML5的history模式来改变网页的URL, 地址就会好看很多</li><li>只要进行对路由配置文件进行简单的配置即可<ul><li>在路由配置文件中那个的router实例中添加一个option</li><li>mode : “history” 其实这个option值默认是hash, 只是我们手动把它改成history而已</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置文件 index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 将修改url中的hash值来改变展示的组件, 转换为通过history方法来改变</span></span><br><span class="line">  <span class="attr">mode</span> : <span class="string">&quot;history&quot;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-link-标签的补充"><a href="#router-link-标签的补充" class="headerlink" title="router-link 标签的补充"></a>router-link 标签的补充</h3><ul><li>在前面我们只用了 to 这个属性来指定跳转的路径</li><li>router-link 还有一些其他的属性<ul><li>tag : router-link标签默认最终会渲染成 a 标签, 通过tag 属性, 我们可以修改router-link标签最终会渲染成什么标签, 比如设置 tag=”button”, 则该router-link标签最终会被渲染成button标签</li><li>replace : replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个路径, 使用方法: 直接给router-link标签添加replace属性即可, 这个属性没有值</li><li>active-class: 当router-link标签对应的路由匹配成功时, 会自动给当前标签设置了一个router-link-active的class类名, 我们可以通过这个类名修改活动的router-link标签的样式, 设置active-class可以修改这个router-link-active这个默认类名<ul><li>关于router-link-active类, 在进行高亮显示的导航菜单或者底部tabbar时, 会使用这个类</li><li>一般不会修改这个默认的类名, 直接使用默认的router-link-active类名即可</li></ul></li><li>还有另外一种方法改变router-link-active这个默认类名<ul><li>在路由配置文件 index.js中的路由实例对象中添加 linkActiveClass 选项, 值为要修改成的类名, 也可以修改这个默认类名</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过tag改变最终渲染成的标签</span><br><span class="line">    // 通过replace禁止使用后退功能</span><br><span class="line">    // 通过active-class改变默认的 router-link-active 类名</span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;</span></span><br><span class="line"><span class="comment">    &lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过代码来实现路由跳转"><a href="#通过代码来实现路由跳转" class="headerlink" title="通过代码来实现路由跳转"></a>通过代码来实现路由跳转</h3><ul><li>有的时候, 页面的跳转可能需要执行对应的JS代码, 这个时候可以使用第二种跳转方式</li><li>本质上为跳转的标签监听事件, 通过methods方法来实现跳转<ul><li>注意不能在方法中通过修改 history.pushState 的值来实现跳转, 这样会跳过了 vue-router 组件</li><li>$router时vue-router 模块给每一个组件构造器添加的</li><li>通过 this.$router.push(“要跳转的路径”) 来实现跳转</li><li>如果想要禁止后退功能, 那么就将push方法改成replace方法即可</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过代码来实现路由跳转 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;aboutClick&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 通过监听事件来使用 $router 中的方法来实现跳转</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这个$router 时vue-router 模块绑定到所有的组件构造器中的</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/home&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果想要做到禁用后退键的效果, 可以使用replace方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/home&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/about&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/about&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在某些情况下, 一个页面的path路径是不确定的, 比如我们进入用户界面的时候, 希望路径是这样的<ul><li>/user/aaa 或者 /user/bbb</li><li>除了前面的/user之外, 后面还跟上了用户的ID</li><li>这种path和component的匹配关系, 我们称为动态路由</li></ul></li><li>如何实现动态路由<ul><li>第一步: 在组件的路由设置中path, 通过冒号 : 表示后面的路径是不确定的</li><li>第二步: 使用v-bind 绑定根组件的 router-link 中的 to 属性, 使其值 = 确定的路径 + 一个从data传过来的数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使路由设置index.js的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&quot;/user/:userId&quot;</span>,  <span class="comment">// 这里的 /user/ 为确定的路径, :userId 为不确定的路径, 不过要记住冒号后面的名字, 因为可以在组件中获取这个名字 </span></span><br><span class="line">    <span class="attr">component</span> : User</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过v-bind绑定 to 来使to可以使用组件构造器中的数据</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27; + Id&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">Id</span>: <span class="string">&quot;lisi&quot;</span>,  <span class="comment">// 这个Id 模拟从服务器接收的数据</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传递活动的路由的数据"><a href="#传递活动的路由的数据" class="headerlink" title="传递活动的路由的数据"></a>传递活动的路由的数据</h3><ul><li>前面讲到vue-router 有一个 $router 对象, 里面有方法可以实现路径的跳转</li><li>vue-router 中还有一个对象, 为 $route , 这个对象获取的是页面中当前活跃的路由</li><li>$route是一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。</li><li>这个对象有很多属性, 可以查看 vue-router 的官方文档</li><li>$route.params 这个属性是一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; userId &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;User&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">userId</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// $route对象, 是页面中当前活跃的路由</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过params获取路由中的path 中对应的字符串</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.userId;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue打包文件解析"><a href="#vue打包文件解析" class="headerlink" title="vue打包文件解析"></a>vue打包文件解析</h3><ul><li>命令行输入 npm run build 后, 就会对项目进行打包<ul><li>打包完成后项目中会生成一个新的文件夹名叫 dist</li></ul></li><li>dist文件夹解析<ul><li>static文件夹: 里面包含两个文件夹, css文件夹 和 js文件夹<ul><li>css文件夹: 里面存放的是我们的css代码</li><li>js文件夹: 里面存放的是我们的js代码<ul><li>app.xxxx.js文件: 存放的是我们的业务代码, 也就是我们自己写的代码</li><li>manifest.xxxxx.js文件: 存放的是底层支撑的代码, 比如说, 支撑模块和模块之间的导入导出等等</li><li>vendor.xxxxx.js文件: 存放的是提供商也就是第三方的代码, 比如, vue的代码, vue-router的代码等等</li></ul></li></ul></li><li>index.html文件: 入口HTML文件</li></ul></li></ul><h3 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h3><ul><li>官方解释<ul><li>在打包构建应用的时候, JavaScript 文件会变得非常大, 会影响页面的加载</li><li>如果我们能把不同路由对应的组件分割成不同的代码块, 然后当路由被访问的时候才加载对应组件, 这样就更加高效了</li></ul></li><li>通俗地说<ul><li>首先, 我们知道路由中通常会定义很多不同的页面</li><li>但是这些页面最后都被打包到一个js文件中</li><li>那么多的页面全放在一个js文件中, 这个页面必然会很大</li><li>如果我们一次性从服务器请求下这个页面, 可能会花费一定的事件, 甚至用户的电脑上还出现了短暂空白的情况</li><li>要避免这种情况, 就要使用路由懒加载</li></ul></li><li>路由懒加载做了什么<ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块, 一个组件打包成一个js文件</li><li>在当这个路由被访问到的时候, 才加载对应的组件</li></ul></li></ul><h3 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h3><ul><li>每种方式的使用方法都是改变路由配置 index.js 文件中的导入组件的方式来达到懒加载</li><li>方式一: 结合Vue的异步组件和webpack的代码分析 (这种方式已经很古老了, 不用了嗷)<ul><li>const Home = resolve =&gt; { require.ensure([‘../components/Home.vue’], () =&gt; { resolve(require(‘../components/Home.vue’)) })};</li></ul></li><li>方式二: AMD写法 (比方式一好一点)<ul><li>const Home = resolve =&gt; require([‘../components/Home.vue’], resolve);</li></ul></li><li>方式三: 在ES6中, 我们有更加简单的写法来组织Vue异步组件和Webpack的代码分割 (代码简洁, 推荐)<ul><li>const Home = () =&gt; import(“../components/Home.vue”)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件中的代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="comment">/* import Home from &quot;../components/Home&quot;;</span></span><br><span class="line"><span class="comment">import About from &quot;../components/About&quot;;</span></span><br><span class="line"><span class="comment">import User from &quot;../components/User&quot;; */</span>  <span class="comment">// 不用这里的引入方法了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用懒加载来引入相关组件</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/Home&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/About&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/User&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过 /home/news 和 /home/message 访问一些内容</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件</li></ul></li><li>实现嵌套路由有两个步骤<ul><li>第一步: 创建对应的子组件, 并在路由映射中配置对应的子路由<ul><li>注意!!! 嵌套的子路由path的路径前不能加 /</li></ul></li><li>第二步: 在组件内部使用 router-view 标签</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 这里是创建的两个子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in news&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HomeNews&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">news</span>: [<span class="string">&quot;新闻1&quot;</span>, <span class="string">&quot;新闻2&quot;</span>, <span class="string">&quot;新闻3&quot;</span>, <span class="string">&quot;新闻4&quot;</span>],</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in messages&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HomeMessage&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">messages</span>: [<span class="string">&quot;消息1&quot;</span>, <span class="string">&quot;消息2&quot;</span>, <span class="string">&quot;消息3&quot;</span>, <span class="string">&quot;消息4&quot;</span>],</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    <span class="attr">component</span>: Home, <span class="comment">// 挂载组件</span></span><br><span class="line">    <span class="comment">// 在路由的内部添加children 的option来定义子路由, 数组类型</span></span><br><span class="line">    <span class="attr">children</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">redirect</span> : <span class="string">&quot;news&quot;</span> <span class="comment">// 设置默认路由</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        <span class="attr">component</span> : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        <span class="attr">component</span> : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><ul><li>一般来说一个URL长这样: scheme://host.domain:port/path?query#fragment<ul><li>scheme: 协议</li><li>host: 主机</li><li>domain: 域名</li><li>port: 端口号</li><li>path: 路径</li><li>query: 查询</li><li>fragment: 片段, hash</li></ul></li></ul><h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><ul><li>传递参数主要有两种类型: params 和 query</li><li>params的类型<ul><li>配置路由格式: /router/:id</li><li>传递的方式: 在path后面跟上对应的值</li><li>传递后形成的路径: /router/123, /router/abc</li><li>前面标题为 传递活动的路由的数据 有详细用法</li></ul></li><li>query的类型<ul><li>配置路由格式: /router, 也就是普通配置</li><li>传递的方式: 对象中使用query的key作为传递方式</li><li>传递后形成的路径: /router?id=123, /router?id=abc</li><li>具体操作<ul><li>第一步, 用v-bind为想要传递的router-link标签的 to 属性进行属性绑定, 值为一个对象, 对象中有两个属性, 第一个是path, 值为要传递的路由路径, 第二个为query, 值为一个对象, 里面为要传递的数据</li><li>第二步, 在对应的子组件中, 在组件构造器中computed中使用 $route.query 来接收传递过来的数据,</li><li>第三步, 处理数据, 使用数据</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一步 这里是根组件的代码</span><br><span class="line">&lt;router-link :to=&quot;&#123; path: &#x27;/profile&#x27;, query: &#123; name: &#x27;xiaoLam&#x27;, age: 18, height: 1.7 &#125;&#125;&quot; tag=&quot;button&quot;&gt;档案&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是Profile组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是Profile里的信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 使用数据</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in userData&quot;</span>&gt;</span>&#123;&#123; key &#125;&#125; : &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;Profile&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">userData</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 接收传递过来的数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 这里的$route对象是Vue中prototype中的对象, 这个对象是当前活跃的路由组件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.query;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><ul><li>$router本质是VueRouter实例, 就是一个对象包含所有的路由, 想要导航到不同的URL, 则使用 $router.push() 方法</li><li>$route为当前活跃的路由组件对象</li></ul><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ul><li>为什么我们可以在各个组件中使用 $router 和 $route?<ul><li>是因为所有组件都是来自, Vue类的原型prototype</li><li>而Vue类的原型prototype中就定义了, $router 和 $route, 而且通过一些方法将所有的路由赋值给了$router, 将当前活跃的路由组件赋值给了$route</li><li>所以我们可以在组件中使用这两个属性</li></ul></li><li>为什么我们可以在组件模板中中使用  router-link  和  router-view  这两个标签<ul><li>是因为Vue在全局中注册了这两个组件</li></ul></li></ul><h3 id="为什么要使用导航守卫"><a href="#为什么要使用导航守卫" class="headerlink" title="为什么要使用导航守卫"></a>为什么要使用导航守卫</h3><ul><li>需求, 在一个SPA应用中, 如何修改网页的标题呢?<ul><li>网页标题是通过 title 标签来现实的, 但是SPA只有一个固定的HTML, 切换不同的页面的时候, 标题并不会改变</li><li>但是我们可以通过JavaScript中 document.title来修改 title 中的内容 window.document.title = “新的标题” (window可以省略)</li><li>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</li></ul></li><li>普通的修改方式<ul><li>很容易想到的修改标题的位置是每一个路由对应的组件.vue文件中</li><li>通过生命周期函数, 执行对应的代码来修改即可</li><li>但是当页面较多的时候, 这种方式不容易维护(因为要在多个页面执行类似的代码)</li></ul></li><li>使用导航守卫<ul><li>什么是导航守卫<ul><li>vue-router 提供的导航守卫主要用来监听路由的进入和离开的<ul><li>beforEach 守卫函数, 会在路由即将改变前触发, 这个守卫函数需要传入一个函数作为参数<ul><li>这个传入的函数包含三个参数, to, from, next</li><li>to : 即将要进入的目标的路由对象</li><li>from : 当前导航即将要离开的路由对象</li><li>next : 调用了该方法后, 才能进入下一个钩子, 前置守卫函数必须调用这个方法</li></ul></li><li>afterEach 守卫函数, 会在路由改变后触发, 这个守卫函数也需要传入一个函数作为参数<ul><li>这个传入的函数包含两个参数, to , from</li><li>这两个参数的含义与beforEach中的函数的参数含义相同</li><li>后置守卫函数不需要调用next</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 普通的修改方式</span><br><span class="line">// 这里是vue组件中的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 我们可以通过Vue的生命周期函数来修改 document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 生命周期函数有很多，这里只使用了created函数， 其会在为路由创建的时候调用</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 但是这样的做的话, 每一个组件都需要添加一个created生命周期函数, 代码重复度很高, 所以我们可以通过在路由配置index.js文件中通过导航守卫, 来修改document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.title = <span class="string">&quot;首页&quot;</span>;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导航守卫写法</span></span><br><span class="line"><span class="comment">// 通过 路由实例中的 beforeEach 方法来监听路由即将改变前事件</span></span><br><span class="line"><span class="comment">// 这个方法需要传入一个参数, 这个参数是一个函数</span></span><br><span class="line"><span class="comment">// 这个函数包含三个参数, 第一个参数为to, 第二个参数为from, 第三个参数为next(其本质是一个函数)</span></span><br><span class="line"><span class="comment">// to指要跳转到的路由, from指从哪个路由跳转, next指进行下一步操作, [注]必须调用next函数,进行下一步,否则路由不会跳转了</span></span><br><span class="line"><span class="comment">// to和from都是是一个路由对象里面包含整个路由的所有信息, 包括其父路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在路由嵌套的话, 直接用meta是拿不到元数据的</span></span><br><span class="line">  <span class="comment">// 要通过to对象中的metched数组中下标为0的数据中的meta对象来获取预先在路由中设置的元数据</span></span><br><span class="line">  <span class="comment">// meta翻译为元数据（描述数据的数据</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title;</span><br><span class="line">  next(); <span class="comment">// 调用next函数进行下一步</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><ul><li>补充一: 上面已经提到了, 后置守卫函数afterEach 是不需要主动调用next()函数的</li><li>补充二: next()函数里面也是可以传入参数的, 具体可以浏览 vue-router 的官网</li><li>补充三: 上面所说的两个导航守卫都是全局守卫<ul><li>导航守卫还有路由独享的守卫和组件内守卫</li></ul></li></ul><h3 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h3><ul><li>keep-alive是Vue内置的一个组件, 可以使被包含的组件保留状态, 或者避免重新渲染<ul><li>keep-alive组件有两个生命周期钩子函数<ul><li>activated(), 这个函数会在组件进入活跃的时候调用</li><li>deactivated(), 这个函数会在组件离开活跃之前的时候调用</li><li>注意, 这两个函数只能在存在keep-alive组件的情况下使用</li></ul></li></ul></li></ul><h3 id="如何实现切换路由的时候保留组件状态"><a href="#如何实现切换路由的时候保留组件状态" class="headerlink" title="如何实现切换路由的时候保留组件状态"></a>如何实现切换路由的时候保留组件状态</h3><ul><li>首先: 如果组件中具有组件嵌套, 而且有自动跳转默认组件的话, 需要在 路由配置 index.js文件中取消自动跳转</li><li>实现思路: 在组件中的data中存储离开路由前的路由路径, 在再次回到该路由的时候再将路由设置为离开路由前的路由路径达到保留组件状态的效果</li><li>具体操作<ul><li>第一步: 在组件的data中存储默认的路由路径</li><li>第二步, 通过keep-alive中的activated() 函数, 在组件进入活跃的时候, 使用 $router.push() 方法, 将路由路径设置为默认路由路径</li><li>第三步, 通过导航守卫中的组件内守卫, beforeRouteLeave(to, from, next){} 将当前路由路径赋值给data中存储的默认路由路径</li><li>这样就可以达到切换路由的时候保留组件状态的效果</li><li>以后会有更好的方法达到这个效果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置文件 index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">children</span> : [</span><br><span class="line">      <span class="comment">// 要实现保留组件状态就不能自动跳转, 取消自动跳转</span></span><br><span class="line">      <span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">        path : &quot;&quot;,</span></span><br><span class="line"><span class="comment">        redirect : &quot;news&quot;</span></span><br><span class="line"><span class="comment">      &#125;, */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        <span class="attr">component</span> : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        <span class="attr">component</span> : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">path</span>: <span class="string">&quot;home/news&quot;</span>, <span class="comment">// 设置路由默认路径</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 以下代码是实现如何在切换组件的时候 保留组件状态</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 首先在组件的data中记录当前路由的路径</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在路由设置文件 index.js文件中取消自动跳转</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用keep-alive组件中的 activated() 生命周期钩子函数 在路由创建的时候, 使用 $router.push 方法设置路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path); <span class="comment">// 使用$router.push方法设置路径</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用导航守卫中的组件内守卫, 记录离开当前组件时候的路由路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path; <span class="comment">// 记录离开当前组件时的路由路径</span></span></span><br><span class="line"><span class="javascript">    next();</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="keep-alive中的两个重要属性"><a href="#keep-alive中的两个重要属性" class="headerlink" title="keep-alive中的两个重要属性"></a>keep-alive中的两个重要属性</h3><ul><li>keep-alive可以使被包含的组件保留状态, 或者避免重新渲染</li><li>但是我们有些组件就是要频繁的销毁和重新创建</li><li>这个时候就可以用到keep-alive标签中的两个重要的属性了<ul><li>include: 值为字符串或者正则表达式, 只有匹配的组件才会被缓存</li><li>exclude: 值为字符串或者正则表达式, 匹配的组件都不会被缓存</li><li>注意, 有关正则表达式的代码都不能随意加括号</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 keep-alive 标签将router-view标签 包起来 就可以让组件不被销毁 也就是保留组件状态 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果某些组件就是需要频繁的销毁和创建, 那么就用到了keep-alive中的exclude属性了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意与正则表达式相关的代码不能随意加空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;Profile,User&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-Vue-cil脚手架详解</title>
      <link href="2021/05/25/11-Vue-cil%E8%84%9A%E6%89%8B%E6%9E%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/11-Vue-cil%E8%84%9A%E6%89%8B%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么时Vue-CLI"><a href="#什么时Vue-CLI" class="headerlink" title="什么时Vue CLI"></a>什么时Vue CLI</h3><ul><li>如果只是写几个Vue的Demo程序, 那么时不需要用Vue CLI的</li><li>如果在开发大型项目的话, 那么就需要, 而且必然需要使用Vue CLI<ul><li>因为在使用Vue.js开发大型应用的时候, 我们需要考虑代码的目录结构,项目结构和部署,热加载,代码单元测试(国内公司少做)等事情</li><li>如果每个项目都要手动完成这些工作,那无疑效率是十分低效的, 所以我们需要使用一些脚手架工具来帮助完成这些繁琐的事情</li></ul></li><li>CLI是什么意思<ul><li>CLI是Command-Line Interface, 翻译过来就是命令行界面, 俗称脚手架</li><li>Vue CLI是官方发布vue.js项目脚手架</li><li>使用vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置</li></ul></li></ul><h3 id="使用Vue-CLI的前提-–-Node"><a href="#使用Vue-CLI的前提-–-Node" class="headerlink" title="使用Vue CLI的前提 – Node"></a>使用Vue CLI的前提 – Node</h3><ul><li>安装NodeJS<ul><li>NPM安装 (推荐)</li><li>官网安装</li></ul></li><li>检测安装的NodeJS版本<ul><li>使用脚手架需要Node环境8.9以上的版本</li></ul></li><li>什么是NPM<ul><li>NPM 全称是 Node Package Manager</li><li>就是一个NodeJS包管理和分发工具, 已经成为了非官方的发布Node模块的标准</li><li>后续会经常使用NPM安装一些开发过程的依赖包</li></ul></li></ul><h3 id="使用Vue-CLI的前提-–Webpack"><a href="#使用Vue-CLI的前提-–Webpack" class="headerlink" title="使用Vue CLI的前提 –Webpack"></a>使用Vue CLI的前提 –Webpack</h3><ul><li>Vue.js官方脚手架工具就是使用webpack模板的<ul><li>webpack可以对所有资源进行压缩等优化操作</li><li>在开发过程中提供了一套完整的功能, 是开发变得更加高效</li></ul></li><li>webpack的全局安装<ul><li>npm install webpack -g</li></ul></li></ul><h3 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue CLI的使用"></a>Vue CLI的使用</h3><ul><li><p>安装Vue脚手架</p><ul><li>npm install @vue/cli -g</li><li>注意默认安装的是Vue CLI4的版本, 如果需要安装Vue CLI2的方式初始化项目语法是不可以的</li></ul></li><li><p>如果需要用Vue CLI2的方式搭建脚手架</p><ul><li>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</li><li>npm install -g @vue/cli-init</li></ul></li><li><p>Vue CLI2初始化项目</p><ul><li>vue init webpack my-project (my-project指的是项目名字)</li></ul></li><li><p>Vue CLI&gt;=3 初始化项目</p><ul><li>vue create my-project (my-project指的是项目名字)</li></ul></li></ul><h3 id="为了深入地学习脚手架-本文会交替编写Vue-CLI2-和-Vue-CLI3"><a href="#为了深入地学习脚手架-本文会交替编写Vue-CLI2-和-Vue-CLI3" class="headerlink" title="为了深入地学习脚手架, 本文会交替编写Vue CLI2 和 Vue CLI3"></a>为了深入地学习脚手架, 本文会交替编写Vue CLI2 和 Vue CLI3</h3><ul><li>Vue CLI2 初始化项目详解</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行输入</span></span><br><span class="line">vue init webpack vuecli2test  <span class="comment">// 意思是在该文件目录下 创建一个vuecli2test的项目</span></span><br><span class="line">Project name <span class="comment">// 项目名字, 默认是跟上面创建的项目名字相同</span></span><br><span class="line">Project description <span class="comment">// 项目描述</span></span><br><span class="line">Auther <span class="comment">// 项目作者</span></span><br><span class="line">Vue build <span class="comment">// 项目运行的vue版本, 选择是运行时版本还是完整版本</span></span><br><span class="line">Install vue-router? <span class="comment">// 是否安装vue-router 即是vue路由</span></span><br><span class="line">Use ESLint to list your code? <span class="comment">// 是否使用严格模式下的js代码</span></span><br><span class="line"><span class="built_in">Set</span> up unit test <span class="comment">// 是否使用代码单元测试(国内少做)</span></span><br><span class="line">Setup e2e tests <span class="keyword">with</span> Nightwatch <span class="comment">// 是否使用e2e测试</span></span><br><span class="line">Should we run <span class="string">`npm install`</span> <span class="keyword">for</span> you after the project has been created? (recommended)  <span class="comment">// 选择npm安装或者yarn安装</span></span><br></pre></td></tr></table></figure><h3 id="Vue-CLI2-初始化项目的目录结构详解"><a href="#Vue-CLI2-初始化项目的目录结构详解" class="headerlink" title="Vue CLI2 初始化项目的目录结构详解"></a>Vue CLI2 初始化项目的目录结构详解</h3><ul><li>build文件夹和config文件夹: 里面存放的是webpack的相关配置</li><li>node_modules文件夹: 里面存放的是node的模块包</li><li>src文件夹: 里面存放的是源码, 是以后写代码的地方</li><li>static文件夹: 里面存放的是静态文件, 即是打包后会原封不动地加入到dist的文件</li><li>.babelrc文件: 这个是与配置ES代码相关的文件</li><li>.editorconfig文件: 这个是规定项目代码规范格式相关的文件, 比如项目代码的缩进等等</li><li>.gitignore文件: 这个是与上传项目到服务器有关的文件, 里面编写的内容是, 规定上传git仓库的时候要忽略的文件</li><li>.postcssrc.js文件: 这个文件是与样式打包有关的文件</li><li>index.html文件: 这个文件是入口html文件</li><li>package.json文件: 这个文件记录了这个项目所需要的各种模块，以及项目的配置信息</li><li>package-lock.json文件: 这个文件是记录当前状态下实际(注意是实际)安装的各个npm package的具体来源和版本号。</li><li>README.md文件: 这个文件是用于描述这个项目的</li></ul><h3 id="关于-ESLint-严格模式"><a href="#关于-ESLint-严格模式" class="headerlink" title="关于 ESLint 严格模式"></a>关于 ESLint 严格模式</h3><ul><li>如果在初始化Vue CLI的过程中<ul><li>询问Use ESLint to list your code?的时候, 选择使用了其中一个规范</li><li>那么在编写js代码的时候, 就要严格地遵循该规范, 如果有不遵循规范的地方, 运行本地服务器模块, 或者打包的时候, 会报错. 但是这个规范很不灵活, 不人性化, 所以一般都不会开启, 但是有些公司会要求开启, 那就要慢慢适应了</li></ul></li><li>如何关闭 ESLint 严格模式<ul><li>在当前项目中找到 config 文件夹下的 index.js 文件</li><li>将里面的useEslint: true 改为 useEslint: false 即可</li></ul></li></ul><h3 id="Runtime-Compiler-和-Runtime-only的区别"><a href="#Runtime-Compiler-和-Runtime-only的区别" class="headerlink" title="Runtime-Compiler 和 Runtime-only的区别"></a>Runtime-Compiler 和 Runtime-only的区别</h3><ul><li>这两者最大的区别其实就是Runtime-Compiler具有解析template的功能, 而Runtime-only没有这个功能<ul><li>Runtime-Compiler解析代码的过程为<ul><li>template -&gt; ast -&gt; render -&gt; vDOM(虚拟DOM) -&gt; UI(真实渲染在页面中的DOM)</li></ul></li><li>Runtime-only解析代码的过程为<ul><li>render -&gt; vDOM(虚拟DOM) -&gt; UI(真实渲染在页面中的DOM)</li></ul></li></ul></li><li>很明显runtime-only解析代码的时候是跳过了template -&gt; ast 的过程的<ul><li>所以runtime-only比runtime-compiler更轻量(大小小了6KB), 而且代码执行效率更高, 因为解析的时候没有 template -&gt; ast 的过程</li></ul></li><li>但是我们的.vue文件中是带有template模板的, 在runtime-only中是什么来解析template模板的呢?<ul><li>是由 vue-template-compiler 模块来解析的, 可以在package.json文件中找到该模块</li><li>.vue文件中的template模块, 在传入main.js文件中的时候, 已经被vue-template-compiler模块解析为一个 render对象了</li><li>所以我们在实际开发中, 都是选用 runtime-only , 因为它更小更效率</li></ul></li></ul><h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><ul><li>1.使用方法一 (基本不会用这种方法)<ul><li>1.1 基本使用<ul><li>return createElement(“标签名”, {属性对象(可以不传)}, [“内容数组”])</li></ul></li><li>1.2 render函数嵌套<ul><li>return createElement(“标签名”,<br>{属性对象(可以不传)},<br>[“内容”,createElement(“标签名”,{属性对象(可以不传)},[“内容数组”])])</li></ul></li></ul></li><li>2.使用方法二<ul><li>传入一个组件对象<ul><li>return createElement(App);</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件对象</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">  <span class="attr">template</span> : <span class="string">`&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;`</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span> : <span class="string">&quot;你好你好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span> : <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用方法一: </span></span><br><span class="line">    <span class="comment">// 1.1 基本使用 return createElement(&quot;标签名&quot;, &#123;属性对象(可以不传)&#125;, [&quot;内容数组&quot;])</span></span><br><span class="line">    <span class="comment">// return createElement(&quot;h2&quot;, &#123;class : &quot;box&quot;&#125;, [&quot;你好你好我是render的内容&quot;])</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.2 嵌套render函数</span></span><br><span class="line">    <span class="comment">/* return createElement(&quot;h2&quot;,</span></span><br><span class="line"><span class="comment">    &#123;class : &quot;box&quot;&#125;, </span></span><br><span class="line"><span class="comment">    [&quot;你好你好&quot;, createElement(&quot;button&quot;,[&quot;我是按钮&quot;])]) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用方法二: 传入一个组件对象</span></span><br><span class="line">    <span class="keyword">return</span> createElement(cpn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="认识Vue-CLI3"><a href="#认识Vue-CLI3" class="headerlink" title="认识Vue CLI3"></a>认识Vue CLI3</h3><ul><li><p>vue-cli&gt;=3 和 vue-cli2 版本的区别</p><ul><li>vue-cli&gt;=3 是基于webpack4 打造的, vue-cli2 是基于webpack3 打造的</li><li>vue-cli&gt;=3 的设计原则是”0配置”, 移除了根目录下的配置文件, build和config等目录</li><li>vue-cli&gt;=3 提供了vue ui 命令, 也就是提供了可视化设置, 更加人性化, 更加方便修改设置了</li><li>移除了static静态文件夹, 新增了public文件夹(这个文件夹里面的东西打包的时候也会原封不动地打包进dist中), 并且将index.html移动到了public文件夹中</li></ul></li><li><p>使用vue-cli&gt;=3 初始化项目</p><ul><li><ol><li>选择配置方式</li></ol></li><li><ol start="2"><li>选择自己需要的配置(按空格选中或者反选), 选择完毕后直接敲回车进入下一步</li></ol></li><li><ol start="3"><li>选择对应的配置, 是单独生成文件还是放在package.json文件中, 建议单独生成文件</li></ol></li><li><ol start="4"><li>是否将刚才的选择配置保存下来</li></ol><ul><li>如果选择是, 那么就会让你填入配置的名称, 在下次初始化项目的时候, 在第1步, 选择配置方式的步骤中, 就会出现保存下来的配置</li></ul></li><li><ol start="5"><li>选择npm安装还是yran安装</li></ol></li></ul></li></ul><h3 id="vue-cli3-初始化项目的目录结构详解"><a href="#vue-cli3-初始化项目的目录结构详解" class="headerlink" title="vue-cli3 初始化项目的目录结构详解"></a>vue-cli3 初始化项目的目录结构详解</h3><ul><li>node_modules文件夹: 储存node模块包</li><li>public文件夹: 相当于vue-cli2中的static静态文件夹, 在打包项目的时候, 会将里面的文件原封不动地添加到dist中, vue-cli3将index.html也放入了这个文件夹中</li><li>src文件夹: 存放源码的文件夹<ul><li>assets文件夹: 放资源的, 图片logo等</li></ul></li><li>.browserslistrc文件: 这个文件存放关于浏览器兼容的信息, 比如哪些浏览器需要兼容, 哪些浏览器不去兼容</li><li>.gitignore文件: 这个文件是存放关于上传项目的信息的</li><li>babel.config.js文件: 关于ES语法转换的</li><li>postcss.config.js文件: 关于样式转换的</li><li>package.json文件: 记录node模块版本信息</li><li>package-lock.json文件: 记录实际的node模块版本信息</li><li>README.md文件: 项目说明文件</li></ul><h3 id="vue-cli3-与vue-cli2-中的main-js-的区别"><a href="#vue-cli3-与vue-cli2-中的main-js-的区别" class="headerlink" title="vue-cli3 与vue-cli2 中的main.js 的区别"></a>vue-cli3 与vue-cli2 中的main.js 的区别</h3><ul><li>vue-cli3中将 el: “#app” 去除了, 添加上了 .$mount(‘#app’)</li><li>实际上这两个东西是一样的作用</li><li>el: “#app” 在代码的解析的时候也会转换成 .$mount(‘#app’)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 在这里用链式操作, 添加上 .$mount(&#x27;#app&#x27;) 与在Vue实例中的 el : &quot;#app&quot; 是一样的作用</span></span><br></pre></td></tr></table></figure><h3 id="vue-cli-gt-3的配置文件去哪里了-要如何修改我们项目的配置呢"><a href="#vue-cli-gt-3的配置文件去哪里了-要如何修改我们项目的配置呢" class="headerlink" title="vue-cli&gt;=3的配置文件去哪里了? 要如何修改我们项目的配置呢?"></a>vue-cli&gt;=3的配置文件去哪里了? 要如何修改我们项目的配置呢?</h3><ul><li><p>方法一: 要修改项目的配置, 可以在终端的命令行输入 vue ui 进入项目配置的可视化界面</p><ul><li>我们在什么时候安装了 vue ui 呢?<ul><li>在我们全局安装vue/cli 的同时安装了vue 和安装了vue ui这个模块</li><li>所以我们在任何目录下都可以执行 vue ui 这个命令行</li></ul></li><li>在vue ui 可视化界面中导入我们的项目, 就可以对项目的插件, 依赖和配置进行修改了</li></ul></li><li><p>方法二: 在项目的根目录中按照路径 node_modules/@vue/cli-service 就可以找到项目的配置文件 webpack.config.js</p><ul><li>在webpack.config.js 文件中, 可以看到我们引用的配置在 当前文件夹中的 lib/Service中(一般不要随意修改node_modules中的文件)</li></ul></li><li><p>方法三: 在项目的根目录中新建一个名为 vue.config.js(名字是固定的不可以修改) 的文件</p><ul><li>在该文件中编写想要修改的配置</li><li>在vue编译的时候, 就会在根目录中寻找这个文件, 如果找到了就会将文件中的配置与原本的配置进行合并</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-Vue组件化开发深入</title>
      <link href="2021/05/25/10-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%B7%B1%E5%85%A5/"/>
      <url>2021/05/25/10-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><ul><li><p>为什么要使用slot插槽</p><ul><li>组件的插槽是为了让我们封装的组件更加具有扩展性</li><li>让使用者可以灵活地决定组件内部的内容到底展示什么</li><li>网页和网页间每一个组件有很多的区别, 也有很多共性, 如果我们为每一个网页都去单独地封装一个组件是不合适的, 所以我们需要slot插槽</li></ul></li><li><p>如何封装一个灵活的组件</p><ul><li>将共性(相同的地方)抽取放到组件中, 将不同的地方暴露为插槽</li><li>预留了插槽, 就可以让使用者根据自己的需求, 决定插槽内的内容</li></ul></li><li><p>slot的基本使用</p><ul><li>在子组件中, 用特殊的元素标签slot就可以为子组件创建一个插槽</li><li>插槽中插入的内容是什么由父组件来决定</li></ul></li><li><p>slot的注意点</p><ul><li>slot的默认值, 在父组件中没有写入要插入的内容的话, 就会默认显示slot的默认值</li><li>如果父组件中一次性插入多个元素, 那么所有的元素都会进行替换</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在组件的标签中填入要替换slot占位的元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果一次性填入多个替换的元素, 所有的替换元素都会进行替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>我是i<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是替换的p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是替换的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果标签内没有填入要替换的slot占位的元素, slot会使用默认的元素替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在组件中使用solt标签占位 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在slot标签中填入默认的元素, 默认元素会在子组件标签没有填入替换的元素的时候显示出来 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>我是默认的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="具名slot的使用"><a href="#具名slot的使用" class="headerlink" title="具名slot的使用"></a>具名slot的使用</h3><ul><li>当子组件的功能复杂时, 子组件的插槽可能由很多个, 那么在父组件中给插槽插入内容的时候, 如何区分插入的是哪一个插槽呢?<ul><li>此时需要给插槽起一个名字, 添加一个name属性</li><li>然后在插入的元素中添加slot属性, 值为需要替换的插槽的name值</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用子组件的时候, 给需要替换的添加slot属性, 值为需要替换的slot标签的name值, 即可定向替换元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>替换中间的<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 给插槽标签添加name属性 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编译的作用域"><a href="#编译的作用域" class="headerlink" title="编译的作用域"></a>编译的作用域</h3><ul><li>在组件模板中使用的所用东西, 来自该组件</li><li>官方的准则: 父组件模板的所有东西都会在父级作用域内编译, 子级组件模板的所有东西都会在子级作用域内编译</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里使用的isShow数据是来自根组件的,因为这里是app根组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在这里使用的isShow数据是来自cpn组件的, 因为这里是cpn子组件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">isShow</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域插槽的使用"><a href="#作用域插槽的使用" class="headerlink" title="作用域插槽的使用"></a>作用域插槽的使用</h3><ul><li>总结起来就是一句话, 父组件替换插槽的标签, 但是内容由子组件来提供</li><li>就是父组件来决定如何渲染子组件的内容</li><li>如何使用作用域插槽<ul><li>子组件模板中, 通过给slot标签添加v-bind:自定义名称=”想要暴露的数据” 属性来发送子组件的数据</li><li>在父组件中的子组件标签中嵌套一个一个template标签(Vue2.5.x以后可以使用其他的标签比如div等)</li><li>在这个template标签中添加 slot-scope=”也是自定义的名字” 来接收slot标签发送的数据</li><li>在template标签内就可以使用子组件发送来的数据了</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认是按照子组件模板中设定的模板渲染 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果想在父组件中其他的形式展示子组件的内容, 就要使用作用域插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在子组件标签中嵌套一个template标签(Vue2.5.x以后可以使用其他的标签比如div等) --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在该标签中添加 slot-scope=&quot;也是自定义的名字&quot; 来接收slot标签发送的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;acceptdata&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这个标签内就可以使用子组件发送来的数据了 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;span v-for=&quot;item in acceptdata.cpndata&quot;&gt; &#123;&#123;item&#125;&#125; - &lt;/span&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;acceptdata.cpndata.join(&quot; - &quot;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 通过slot标签中添加 v-bind:自定义名称=&quot;想要暴露的数据&quot; 属性来发送子组件的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:cpndata</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">pLanguages</span>: [<span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;python&quot;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-Vue的组件化开发</title>
      <link href="2021/05/25/09-Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>2021/05/25/09-Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h3><ul><li><p>将一个复杂的问题, 拆解为很多个可以处理的小问题, 再将其放到整体当中,大问题就可以迎刃而解  其实就是 动态规划问题</p></li><li><p>组件化也是类似的思想</p><ul><li>如果将一个页面中所有的处理逻辑全部放在一起,处理起来就会变得非常复杂, 而且不利于后续的管理以及扩展, 不利于维护</li><li>如果将一个页面拆分成一个个效地功能块, 每个功能块完成属于自己的部分的独立功能, 那么之后整个页面的管理和维护就变得非常容易了</li></ul></li><li><p>组件化是Vue.js中的重要思想, 它提供了一种抽象, 让我们开发出一个个独立的可以复用的小组件来组成我们的页面</p></li><li><p>任何的应用都可以被抽象成一个组件树</p></li><li><p>组件化思想的应用</p><ul><li>有了组件化的思想, 在以后的开发中就要充分地利用组件化</li><li>尽可能地将页面拆分成一个个小的, 可以复用的组件</li><li>这样可以方便代码的管理和维护,代码的扩展性也会大大增强</li></ul></li></ul><h3 id="注册组件的基本步骤"><a href="#注册组件的基本步骤" class="headerlink" title="注册组件的基本步骤"></a>注册组件的基本步骤</h3><ul><li><p>组件的使用分成三个步骤</p><ul><li>创建组件构造器<ul><li>调用Vue.extend()方法创建组件构造器</li></ul></li><li>注册组件<ul><li>调用Vue.component()方法注册组件</li></ul></li><li>使用组件<ul><li>在Vue实例的作用范围内使用组件</li></ul></li></ul></li><li><p>注意: 前两个步骤代码的编写要写在 创建 new Vue() 之前</p></li></ul><h3 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h3><ul><li><ol><li>Vue.extend()</li></ol><ul><li>调用Vue.extend() 创建的是一个组件构造器</li><li>在创建组件构造器的时候, 传入template 代表自定义组件的模板</li><li>改模板就是在使用到组件的地方, 要显示的html代码</li><li>事实上,这种写法在Vue2.x的文档中几乎看不到了,都是使用语法糖</li></ul></li><li><ol start="2"><li>Vue.component()</li></ol><ul><li>调用Vue.component() 是将创建的组件构造器注册为一个组件, 并给它一个标签名称</li><li>Vue.component() 需要传递两个参数: 1. 注册组件的标签名 2. 组件构造器</li></ul></li><li><ol start="3"><li>组件必须挂载在某个Vue实例中, 否则不会生效</li></ol></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3. 使用组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 1. 创建组件构造器</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const cpn = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 2. 注册组件</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  Vue.component(&#x27;my-cpn&#x27;, cpn)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 以上两步要写在 new Vue实例之前</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    data: &#123;&#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;);</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="全局组件和局部组件-开发中常用的是局部组件"><a href="#全局组件和局部组件-开发中常用的是局部组件" class="headerlink" title="全局组件和局部组件 (开发中常用的是局部组件)"></a>全局组件和局部组件 (开发中常用的是局部组件)</h3><ul><li>全局组件就是在全局注册的组件, 全局组件可以在多个Vue实例中使用</li><li>局部组件就是在Vue实例对象中注册的组件, 局部组件只能在当前的Vue实例下面使用, 在其他的Vue实例下使用会报错<ul><li>局部组件是在Vue实例下的一个叫 components 的 option下注册的, components值是一个对象那个, 里面写入 组件名(就是在html中使用的标签名) : 组件构造器 即可注册组件</li></ul></li><li>注意, 组件构造器和全局注册组件的代码要写在 创建Vue实例的代码之前</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 局部的组件 在这里无效 而且会报错--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;mycpn2&gt;&lt;/mycpn2&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1. 创建组件构造器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn1 = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;我是标题111&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;p&gt;我是内容111, 你好你好&lt;/p&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn2 = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;我是标题222&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;p&gt;我是内容222, 你好你好&lt;/p&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 2. 注册组件 (全局组件)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 全局组件可以在多个Vue实例下使用</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;mycpn1&#x27;</span>, cpn1)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app1&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在实例化的Vue中注册组件就是 局部组件, 局部组件只能在当前的Vue实例中使用, 不能再其他的Vue实例中使用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在 components option中定义局部组件</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">mycpn2</span>: cpn2 <span class="comment">// 组件名(就是在html中使用的标签名) : 组件构造器</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app2&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue组件的父组件和子组件"><a href="#Vue组件的父组件和子组件" class="headerlink" title="Vue组件的父组件和子组件"></a>Vue组件的父组件和子组件</h3><ul><li>子组件的注册组件代码可以写在父组件的组件构造器的名为components的option中, 子组件的注册完成后, 子组件的标签名就可以写入父组件的template中</li><li>简单来说, 就是组件在哪里注册就只能在哪里使用, 浏览器解析组件标签的时候, 会先从当前的组件构造器中的components中查找是否有注册该标签名, 如果找到了就开始渲染, 如果没有找到就在全局的Vue.component中查找, 如果找到就渲染, 如果都没有找到的话就会报错</li><li>注意, 子组件的组件构造器要写在 父组件的组件构造器之前, 否则按照浏览器解析代码的顺序, 会找不到子组件, 就会报错</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fathercpn</span>&gt;</span><span class="tag">&lt;/<span class="name">fathercpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 组件1</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const son = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子内容,呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 组件2</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 注意, 子组件的组件构造器要写在父组件的组件构造器之前</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const father = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是父标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父内容,哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    在这里使用子组件</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">soncpn</span>&gt;</span><span class="tag">&lt;/<span class="name">soncpn</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    // 子组件可以在父组件的内部注册</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    // 注册后就可以在父组件的template中使用</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      soncpn: son</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 这个app可以看作是root组件(根组件)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      fathercpn: father</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册组件的语法糖"><a href="#注册组件的语法糖" class="headerlink" title="注册组件的语法糖"></a>注册组件的语法糖</h3><ul><li>传统注册组件的方式, 有些繁琐</li><li>Vue为了见过这个过程, 提供了注册的语法糖</li><li>主要是省去了调用Vue.extend()的这个步骤, 可以将一个对象当作参数传入component中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 1. 全局注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 将组件构造器中调用Vue.extend方法的步骤省略, 而是直接将一个对象代替传入Vue.component中</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  Vue.component(&#x27;cpn1&#x27;, &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题111<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容111, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      // 2. 局部注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      // 跟全局注册组件的语法糖差不多, 也是直接将一个对象传入</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      cpn2: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题222<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容222, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件模板的分离写法"><a href="#组件模板的分离写法" class="headerlink" title="组件模板的分离写法"></a>组件模板的分离写法</h3><ul><li>template模板如果写在js代码中不优雅不好看</li><li>将其中的HTML代码分离出来,然后挂载到对应的组件上</li><li>Vue提供了两种方案来定义HTML模块内容<ul><li>script标签<ul><li>注意script标签需要定义type类型为 text/x-template</li><li>并且定义id属性来绑定组件的标签名</li></ul></li><li>template标签<ul><li>定义id属性来绑定组件的标签名</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件模板的分离写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. script标签写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题111<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. template标签写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题222<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将定义的模板的id绑定到标签名中</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn1&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn2&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn2&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件中的数据存放问题"><a href="#组件中的数据存放问题" class="headerlink" title="组件中的数据存放问题"></a>组件中的数据存放问题</h3><ul><li>组件可以访问Vue中的数据吗?<ul><li>不可以</li><li>组件是一个单独功能模块的封装</li><li>这个模块有属于自己的HTML模板, 也会有属于自己的数据data</li></ul></li><li>组件中的数据是保存在自身的一个data属性中的(组件也可以有自己的methods等等option,以后会用到)<ul><li>这个data属性必须是一个函数</li><li>函数返回一个对象, 对象内部保存数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件保存的数据也是用mustache语法引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn1&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件中的数据要存放在组件的注册的data中, 而且这个data必须是一个函数, 函数返回一个对象, 对象内写入数据</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 返回一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 对象内写入数据</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件中的data为什么一定要是一个对象"><a href="#组件中的data为什么一定要是一个对象" class="headerlink" title="组件中的data为什么一定要是一个对象"></a>组件中的data为什么一定要是一个对象</h3><ul><li>就是为了防止多次引用组件的时候, 组件和组件之间共用一个data, 造成变量泄露</li><li>Vue已经考虑了这个问题, 所以这里必须写函数, 利用函数的作用域, 成为一个闭包, 防止变量泄露</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;counter&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1. 注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;counter&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#counter&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里为什么要是一个函数?</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 就是为了防止多次引用组件的时候, 组件和组件之间共用一个data, 造成变量泄露</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Vue已经考虑了这个问题, 所以这里必须写函数, 利用函数的作用域, 成为一个闭包, 防止变量泄露</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num++</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num--</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件通讯-父组件向子组件传递数据"><a href="#组件通讯-父组件向子组件传递数据" class="headerlink" title="组件通讯-父组件向子组件传递数据"></a>组件通讯-父组件向子组件传递数据</h3><ul><li>在Vue中子组件是不可以直接引用父组件或者Vue实例中的数据的</li><li>但是在开发中, 往往一些数据需要从上层传递到下层<ul><li>比如在一个页面中, 从服务器请求到很多数据, 包括大组件的数据和小组件的数据, 他们都存储在大组件的data中</li><li>其中一部分数据, 并非是整个页面的大组件来展示的, 而是通过子组件来展示</li><li>这时, 并不会让子组件再次发送一个网络请求, 这样会大大加大服务器的压力的, 此时会让大组件(父组件)将苏剧传递给小组件(子组件)</li></ul></li><li>父组件向子组件传递数据的方法<ul><li>通过props向子组件传递数据<ul><li>props的写法也分有数组写法和对象写法 (我们一般用对象写法)</li><li>对象的写法可以设置 传入的数据类型, 是否必须传入, 默认值等等</li><li>对象的写法中, 如果type的值为0的时候, 则可以传入任何类型的值</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传递数据要子组件的标签中用 v-bind 链接数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:sonmessage</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:sonmovies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在通过子组件标签链接数据后, 就可以在子组件的html模板中用mustache语法使用数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sonmessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in sonmovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这里是子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn =  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 子组件向父组件拿数据, 用props</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里用数组形式, 数组里面传入新的数据名</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// props: [&quot;sonmessage&quot;, &quot;sonmovies&quot;]</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里使用对象形式, 对象形式可以设置传入的数据的类型, 默认值, 是否必须传入等等</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 简单地设置数据类型</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* sonmessage : String,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      sonmovies: Array */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 传入一个对象可以有更多的操作</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">sonmessage</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置数据的类型</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置是否必须传入</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>, <span class="comment">// true表示必须传入, false表示不是必须传入</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置默认值</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="string">&quot;你好我是默认值&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="attr">sonmovies</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意如果传入的数据类型是数组或者对象的话, 设置默认值default必须是一个函数, 函数返回一个默认的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> [<span class="string">&quot;我是默认的数据&quot;</span>, <span class="string">&quot;我也是默认的数据&quot;</span>]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里是父组件的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">movies</span>: [<span class="string">&quot;海王&quot;</span>, <span class="string">&quot;海贼王&quot;</span>, <span class="string">&quot;海尔兄弟&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span> : &#123;</span></span><br><span class="line"><span class="javascript">      cpn</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件向子组件传递数据时props中的驼峰标识"><a href="#父组件向子组件传递数据时props中的驼峰标识" class="headerlink" title="父组件向子组件传递数据时props中的驼峰标识"></a>父组件向子组件传递数据时props中的驼峰标识</h3><ul><li>因为HTML代码时不区分大小写的, 所以不能使用驼峰命名法, 而JS代码时严格区分大小写的, 所以就会导致这个问题</li><li>记住在HTML代码中用短线命名, 在JS代码中使用驼峰命名 就OK啦~</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意这里不能使用驼峰命名法了, 要将props中的驼峰命名的转换为短线命名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:son-message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:son-person</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的数据, 要与props中的数据名一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sonMessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;sonPerson&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">sonMessage</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">sonPerson</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;我是传入的数据&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">person</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">22</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      cpn</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h3><ul><li>需要使用自定义事件传递</li><li>什么时候需要自定义事件呢?<ul><li>当子组件需要向父组件传递数据的时候, 就要用到自定义事件了</li><li>v-on不仅仅可以监听DOM事件, 也可以用域监听组件间的自定义事件</li></ul></li><li>自定义事件的流程<ul><li>在子组件中, 通过$emit()来发射数据<ul><li>$emit() 中有两个参数, 第一个参数是自定义事件的名字, 第二个参数是需要发送的数据</li></ul></li><li>在父组件中, 通过v-on来监听自定义事件, 接收数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需求: 计数器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 操作在子组件中完成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 展示交给父组件完成 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在这里用v-on监听接收子组件发射数据的自定义事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">btn</span> @<span class="attr">num-de</span>=<span class="string">&quot;decreNum&quot;</span> @<span class="attr">num-in</span>=<span class="string">&quot;increNum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">btn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置点击后触发发射数据事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件模块</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> btn = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#btn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 用$emit()发射数据</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;num-de&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;num-in&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 父组件模块</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      btn</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处理接收来的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increNum</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num++</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decreNum</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num--</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件接收来自父组件的数据-通过子组件修改父组件的数据案例"><a href="#子组件接收来自父组件的数据-通过子组件修改父组件的数据案例" class="headerlink" title="子组件接收来自父组件的数据, 通过子组件修改父组件的数据案例"></a>子组件接收来自父组件的数据, 通过子组件修改父组件的数据案例</h3><ul><li>注意!!! 子组件不要直接修改props中来自父组件的数据, 会报错的<ul><li>正确做法是, 子组件修改子组件中data的数据, 然后将data中的数据通过自定义事件发送给父组件, 父组件处理接收的数据, 修改父组件自身的数据</li><li>以下的代码请注意看注释</li><li>以下代码实现的过程为, 从父组件通过props向子组件发送数据, 子组件接收数据, 子组件设置自己的data数据, 子组件修改自己的data数据, 子组件通过自定义事件向父组件发送自己的data数据, 父组件接收数据, 父组件修改自己的data数据, 同步修改了props向子组件发送的数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 根组件模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> <span class="attr">:sonnum1</span>=<span class="string">&quot;num1&quot;</span> <span class="attr">:sonnum2</span>=<span class="string">&quot;num2&quot;</span> @<span class="attr">parchangenum1</span>=<span class="string">&quot;parentnum1&quot;</span> @<span class="attr">parchangenum2</span>=<span class="string">&quot;parentnum2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 注意嗷!!! 子组件里不要直接修改props中来自父组件的数据 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;input type=&quot;number&quot; v-model=&quot;num1&quot;&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;num1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;changenum1&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- props 是接收的来自父组件的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props : &#123;&#123;sonnum1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- data 是子组件自身的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data : &#123;&#123;num1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;input type=&quot;number&quot; v-model=&quot;num2&quot;&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;num2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;changenum2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props : &#123;&#123;sonnum2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data : &#123;&#123;num2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收来自根组件的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">sonnum1</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 在做这个案例的时候, 发现了一个很有趣的现象, 如果将这里的type的值设置为 0 , 那么这个sonnum1 就可以接收任何类型的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">sonnum2</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 子组件的data必须是一个函数, 防止变量泄露</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">num1</span>: <span class="built_in">this</span>.sonnum1,</span></span><br><span class="line"><span class="javascript">          <span class="attr">num2</span>: <span class="built_in">this</span>.sonnum2</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">changenum1</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 处理num1, 然后向根组件发送</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = event.target.value;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum1&quot;</span>, <span class="built_in">this</span>.num1);</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 处理num2, 然后向根组件发送</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = <span class="built_in">this</span>.num1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum2&quot;</span>, <span class="built_in">this</span>.num2);</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">changenum2</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = event.target.value;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum2&quot;</span>, <span class="built_in">this</span>.num2)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = <span class="built_in">this</span>.num2 / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum1&quot;</span>, <span class="built_in">this</span>.num1)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num1</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">num2</span>: <span class="number">2</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        son</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 父组件处理从子组件接收来的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">parentnum1</span>(<span class="params">num</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(num)</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">parentnum2</span>(<span class="params">num</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(num)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件访问-父组件访问子组件-通过-children-和-refs"><a href="#组件访问-父组件访问子组件-通过-children-和-refs" class="headerlink" title="组件访问-父组件访问子组件, 通过$children 和 $refs"></a>组件访问-父组件访问子组件, 通过$children 和 $refs</h3><ul><li>$children 是一个数组, 里面包含的的是父组件中包含的所有子组件<ul><li>想要通过children访问某一个特定的子组件只能通过数组的下标来访问(这样的方法很不灵活), 所以children访问子组件的方法很少用</li></ul></li><li>$refs 是一个对象, 对象里面包含的是在父组件中 有ref属性注册的子组件, 没有ref属性的子组件不会被包含在内; 如果没有子组件设置ref属性, $refs就是一个空对象<ul><li>想要通过refs访问某一个特定的子组件, 需要在子组件的ref属性设置值, 通过这个设置值来访问这个子组件 </li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> <span class="attr">ref</span>=<span class="string">&quot;son1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过这个按钮来触发事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>: <span class="string">&quot;子组件数据&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">showMessage</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;子组件方法&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        son</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 1. 通过children获取所有的子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 获取的是所有的子组件组成的一个数组</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 想要获取某个特定的子组件, 只能使用数组的下标获取(这样很不灵活, 所以使用children获取子组件的方法很少用)</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">/* console.log(this.$children);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.$children[0].showMessage(); // 通过$children 使用某个下标的子组件的方法</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          console.log(this.$children[0].name); // 通过$children 获取某个下标的子组件的数据 */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 2. 通过$refs 获取某个特定的子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs); <span class="comment">// $refs 获得的是一个对象, 里面包含通过标签属性ref注册的子组件 可以通过属性ref的值来获取特定的一个子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$refs.son1.showMessage(); <span class="comment">//通过refs调用ref值为son1的子组件的方法</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.son1.name); <span class="comment">// 通过refs获取ref值为son1的子组件中的数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件访问-子组件访问父组件-通过-parent-和-root"><a href="#组件访问-子组件访问父组件-通过-parent-和-root" class="headerlink" title="组件访问-子组件访问父组件, 通过$parent 和 $root"></a>组件访问-子组件访问父组件, 通过$parent 和 $root</h3><ul><li>$parent 可以访问当前子组件上一级的父组件</li><li>$root 可以访问当前子组件的最上级根组件</li><li>这两个方法不是很常用, 因为Vue最大的优点是能够组件化分离, 如果组件用了$parent 或者 ​$root 方法的话就大大地减低了Vue的组件性</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是son组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sonBtnClick&quot;</span>&gt;</span>我是son按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sonchild</span>&gt;</span><span class="tag">&lt;/<span class="name">sonchild</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;sonchild&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是sonchild组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sonChildBtnClick&quot;</span>&gt;</span>我是sonchild按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;我是根组件的数据&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">son</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">message</span>: <span class="string">&quot;我是son组件的数据&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sonBtnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 通过parent访问父组件</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent);</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 通过parent访问父组件的数据</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">sonchild</span>: &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">template</span>: <span class="string">&quot;#sonchild&quot;</span>,</span></span><br><span class="line"><span class="javascript">              <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">sonChildBtnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 通过 $root 访问根组件</span></span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root);</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 通过$parent 访问父组件</span></span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent);</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">              &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-Vue中v-model数据双向绑定</title>
      <link href="2021/05/25/08-Vue%E4%B8%ADv-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>2021/05/25/08-Vue%E4%B8%ADv-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="v-model的基本使用"><a href="#v-model的基本使用" class="headerlink" title="v-model的基本使用"></a>v-model的基本使用</h3><ul><li>在input框中添加指令, v-model, 值为需要绑定的data数据</li><li>这样的话, 修改input框中的内容, data中的内容也会响应式改变</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好呀&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><ul><li>v-model其实是一个语法糖, 它的背后本质是包含两个操作<ul><li><ol><li>v-bind绑定一个value属性</li></ol></li><li><ol start="2"><li>v-on 指令给当前元素绑定input事件</li></ol></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合radio的使用"><a href="#v-model结合radio的使用" class="headerlink" title="v-model结合radio的使用"></a>v-model结合radio的使用</h3><ul><li>在给input的radio设置v-model指令后, 不需要设置相同的name值就可以达到单选的效果</li><li>在使用v-model绑定radio单选按钮到data数据中的时候, 每次点击单选按钮都会将单选按钮是否选择传入data数据中, 已选传入true, 没选则传入false</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在给input的radio设置v-model指令后, 不需要设置相同的name值就可以达到单选的效果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">sex</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合checkbox使用"><a href="#v-model结合checkbox使用" class="headerlink" title="v-model结合checkbox使用"></a>v-model结合checkbox使用</h3><ul><li>结合单选checkbox使用<ul><li>与单选checkbox结合使用的时候, 一般给绑定的data数据声明为boolean值, 记录单选框是否有被选中</li></ul></li><li>结合多选checkbox使用<ul><li>与多选checkbox结合使用的时候, 一般给绑定的data数据声明为一个数组, 因为每次点击checkbox的时候,如果选中则会将其value值传入data数据, 如果没有选中, 则会将对应的data数据删除, 这样就可以记录用户选择了什么</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择是: &#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;网球&quot;</span>&gt;</span>网球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好有: &#123;&#123;hobby&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">isAgree</span>: <span class="literal">false</span>, <span class="comment">//单选框绑定为boolean值</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">hobby</span>: [] <span class="comment">// 多选框绑定为一个数组</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的值绑定"><a href="#v-model的值绑定" class="headerlink" title="v-model的值绑定"></a>v-model的值绑定</h3><ul><li>实质上就是动态地给value赋值</li><li>在真实开发中, input的值是从服务器中获取或者定义在data中的</li><li>所以要通过v-bind:value动态地给value绑定值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-model的值绑定概念 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 遍历请求来的数据创建input --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in orginHobby&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过v-model将input绑定在用于记录用户选择的数据中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">hobby</span>: [],  <span class="comment">// 这里是用于记录用户选中的数据的</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">orginHobby</span>: [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>, <span class="string">&quot;网球&quot;</span>, <span class="string">&quot;高尔夫球&quot;</span>, <span class="string">&quot;台球&quot;</span>] <span class="comment">// 这里可以看作是从服务器中请求来的需要渲染在页面上的数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合select使用"><a href="#v-model结合select使用" class="headerlink" title="v-model结合select使用"></a>v-model结合select使用</h3><ul><li>select单选<ul><li>v-model绑定的是一个值</li><li>当选中option中的一个时, 就会将它的value值传入绑定的data中</li></ul></li><li>select多选<ul><li>用multiple属性将select转换为多选</li><li>v-model绑定的是一个数组</li><li>当选中多个值的时候, 就会将选中的option传入绑定的data数组中</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;frult&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;frult&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你选择的水果是: &#123;&#123;frult&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- select设置为多选 用multiple属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;frults&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;frults&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你选择的水果有: &#123;&#123;frults&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">frult</span>: <span class="string">&quot;苹果&quot;</span>, <span class="comment">// 如果是单选的select 就设置为一个字符串就好了</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">frults</span>: [] <span class="comment">// 如果是多选的select 就设置为一个数组</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的修饰符"><a href="#v-model的修饰符" class="headerlink" title="v-model的修饰符"></a>v-model的修饰符</h3><ul><li><p>lazy修饰符</p><ul><li>默认情况下, v-model默认是在input事件中同步输入框的数据的</li><li>也就是说数据一旦发生变化, data中的数据就会立即变化, 这样会降低性能</li><li>在v-model指令加上lazy修饰符, 就可以让data数据在input框失去焦点或者用户敲下回车的时候才会更新</li></ul></li><li><p>number修饰符</p><ul><li>默认情况下,在输入框中无论用户输入的是字符串还是数字, 存储在data中的时候都会被Vue转换为字符串类型</li><li>如果想要处理的是数字类型, 那么最好将内容存储为数字类型</li><li>number修饰符可以将传入的内容转成数字类型</li></ul></li><li><p>trim修饰符</p><ul><li>如果输入的内容首尾有空格, 我们希望去除的话</li><li>trim修饰符可以过滤内容左右两边的空格</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.修饰符: lazy --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2.修饰符: number --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125; &#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3.修饰符: trim --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">age</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-Vue中循环遍历v-for</title>
      <link href="2021/05/25/07-Vue%E4%B8%AD%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86v-for/"/>
      <url>2021/05/25/07-Vue%E4%B8%AD%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86v-for/</url>
      
        <content type="html"><![CDATA[<h3 id="v-for循环遍历数组"><a href="#v-for循环遍历数组" class="headerlink" title="v-for循环遍历数组"></a>v-for循环遍历数组</h3><ul><li>v-for循环遍历一个数组, 没有使用索引值(下标值) v-for=”item in arr”</li><li>v-for循环遍历一个数组, 使用索引值(下标值) v-for=”(item, index) in arr”</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-for循环遍历一个数组, 没有使用索引值(下标值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for循环遍历一个数组, 使用索引值(下标值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in names&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125; &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">names</span>: [<span class="string">&quot;xiaoLam&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;jams&quot;</span>, <span class="string">&quot;copo&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for循环遍历对象"><a href="#v-for循环遍历对象" class="headerlink" title="v-for循环遍历对象"></a>v-for循环遍历对象</h3><ul><li>v-for=”value in obj” 遍历obj对象中的值value</li><li>v-for=”(value,key) in obj” 遍历obj对象中的值value和键key</li><li>v-for=”(value, key, index) in obj” 遍历obj对象中的值value和键key和下标index(很少用)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;value in obj&quot; 遍历obj对象中的值value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;(value,key) in obj&quot; 遍历obj对象中的值value和键key --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;,&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;(value, key, index) in obj&quot; 遍历obj对象中的值value和键key和下标index(很少用) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;, &#123;&#123;key&#125;&#125;, &#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">obj</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">tall</span>: <span class="number">1.70</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件的key属性"><a href="#组件的key属性" class="headerlink" title="组件的key属性"></a>组件的key属性</h3><ul><li>官方推荐在使用v-for的时候, 给对应的元素添加一个 :key 属性</li><li>key属性是Vue的虚拟DOM的Diff算法中用来识别元素唯一性的属性</li><li>添加这个 :key属性的好处<ul><li>这个其实和Vue的虚拟DOM的Diff算法有关系</li><li>当某一层有很多相同的节点时, 也就是列表节点时,当我们希望插入一个新的节点时, 比如希望在B和C之间插入一个F, Diff算法默认的做法时这样的: 把C更新为F, 把D更新为C, 把E更新为D, 最后再插入一个E, 这样的做法效率时很低的</li></ul></li><li>所以我们需要使用key来给每个节点做一个唯一的标识<ul><li>Diff算法就可以正确地识别这个节点</li><li>然后找到正确地位置区插入新的节点</li></ul></li><li>一句话, key地作用主要就是为了高效地更新虚拟DOM</li><li>:key一定要写入唯一的, 能对应标签的值, 否则没有意义</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Vue中响应式数组方法</title>
      <link href="2021/05/25/06-Vue%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/25/06-Vue%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数组中的哪些方法是响应式的"><a href="#数组中的哪些方法是响应式的" class="headerlink" title="数组中的哪些方法是响应式的"></a>数组中的哪些方法是响应式的</h3><ul><li>push(), pop(), shift(), unshift(), splice(), sort(), reverse() 这些方法是响应式的</li><li>修改数组中的数据不是响应式的! </li><li>如果想要修改数组中的数据也有响应式 则需要用splice() 方法</li><li>或者使用Vue的set()方法 set(要修改的数组, 要修改的数据的下标, 修改后的数据)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in arr&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">arr</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 数组中哪些方法是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. push() 在数组的最后添加数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.push(&#x27;aaa&#x27;);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. pop() 删除数组的最后一个数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.pop();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3. shift() 删除数组中的第一个数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.shift();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4. unshift() 在数组中的最前面添加数据, 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.unshift(&quot;aaa&quot;);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 5. splice() 删除数组元素, 修改数组元素, 向数组插入元素 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这个方法一共有三或以上的参数, 第一个参数是从第几个索引号开始, 第二个参数是要修改多少个数据, 后面的参数是要插入或者要修改的参数</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 删除数据, 第一个参数传入从第几个索引号开始删除, 第二个参数传入要删除的数据个数, 如果第二个参数不传入的话, 就是删除第一个参数往后的所有数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 1);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 替换数据, 第一个参数传入从第几个索引号开始替换, 第二个参数传入要替换多少个数据, 后面的参数是要替换后的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 2, &quot;aaa&quot;, &quot;bbb&quot;);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 插入数据, 第一个参数传入从第一个索引号开始插入, 第二个参数传入0, 后面的参数是要插入的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 0, &quot;aaa&quot;, &quot;bbb&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 6. sort() 排列数组 参数是一个function 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.sort();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 7. reverse() 翻转数组, 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.reverse();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意: 修改数组中的数据不是响应式的!!!</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr[0] = &quot;aaa&quot;;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 想要响应式</span></span></span><br><span class="line"><span class="javascript">        Vue.set(<span class="built_in">this</span>.arr, <span class="number">0</span>, <span class="string">&quot;aaa&quot;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-Vue中逻辑语句v-if/v-else-if/v-else</title>
      <link href="2021/05/25/05-Vue%E4%B8%AD%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5v-if-v-else-if-v-else/"/>
      <url>2021/05/25/05-Vue%E4%B8%AD%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5v-if-v-else-if-v-else/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul><li>指令的值可以是一个布尔值, 也可以是一个判断条件</li><li>用于决定一个标签元素是否在页面中渲染</li><li>如果值为真, 则指令的标签会加载在页面中, 为false则不会加载在页面中(不会存在)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-if基本使用, 如果值为true则会加载该标签, 为false则不会加载该标签(这个标签不会存在) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;false&quot;</span>&gt;</span>&#123;&#123;meassage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">meassage</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-else"><a href="#v-if-和-v-else" class="headerlink" title="v-if 和 v-else"></a>v-if 和 v-else</h3><ul><li>如果v-if的值为真则会加载 v-if的标签, 否则会加载v-else 的标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>v-if为假的时候,显示的div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-else-if-和-v-else"><a href="#v-if-和-v-else-if-和-v-else" class="headerlink" title="v-if 和 v-else-if 和 v-else"></a>v-if 和 v-else-if 和 v-else</h3><ul><li>如果有多种情况需要判断的的话, 可以用v-else-if 指令写更多的情况, 但是一般不会将判断的过程写在页面的标签指令中, 而是写在 computed 计算属性中, 这样代码更好看</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;scort&gt;=90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;scort&gt;=80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;scort&gt;=60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果进行复杂的判断的话 不会像上面那样写 而是将判断条件写在computed中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">scort</span>: <span class="number">55</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">result</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showMeassage = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">90</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;优秀&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">80</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;良好&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">60</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;及格&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;不及格&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> showMeassage;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul><li>v-show是用来决定元素是否在dom中显示的, 如果值为false,则会在对应的元素加上行内样式, display=”none”</li><li>与v-if的区别是, v-if是用来决定元素是否在dom中渲染, 如果值为false, 那么对应的元素则不会被渲染出来</li><li>开发中, 如果元素在页面中的切换很频繁, 那么就使用v-show, 如果元素在页面中只切换一次的话就用v-if, 开发中v-if常用一点</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-if是用来决定元素是否在dom中渲染, 如果值为false, 那么对应的元素则不会被渲染出来 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-show是用来决定元素是否在dom中显示的, 如果值为false,则会在对应的元素加上行内样式, display=&quot;none&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好呀&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Vue中computed计算属性</title>
      <link href="2021/05/25/04-Vue%E4%B8%ADcomputed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
      <url>2021/05/25/04-Vue%E4%B8%ADcomputed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h3><ul><li>什么是计算属性, 在某些情况下, 需要将数据先进行转化后再进行显示, 或者需要将多个数据结合后再进行显示, 那么就需要将属性进行处理, 这就叫做计算属性</li><li>在进行变量的操作的时候 将操作写到computed对象中, return 计算的结果</li><li>定义名字的时候尽量与methods的方法区别开来, methods中定义名字用动词, computed中定义名字用名词</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 定义好后直接mustache语法调用即可 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">lastName</span>: <span class="string">&quot;bulaen&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 计算属性 computed</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>computed 和 methods 其实都可以实现功能, 但是为什么要分开呢?</li><li>实际上, 虽然computed 和methods 都可以实现功能, 但是它们两个内部进行的操作是不一样的</li><li>computed 计算属性会进行缓存, 多次调用里面的函数, 只会计算一次, 而methods不会进行缓存, 多次调用的话, 会调用多次</li></ul><h3 id="computed计算属性的set和get"><a href="#computed计算属性的set和get" class="headerlink" title="computed计算属性的set和get"></a>computed计算属性的set和get</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- computed 是一个属性, 而不是一个函数, 所以mustache语法中不需要加括号调用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">lastName</span>: <span class="string">&quot;bulan&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 完整写法 完整写法一般是传入一个对象, 对象里面有两个函数, set 和 get</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* fullName: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        // set函数用来设置属性, 但是在计算属性中, 一般只用get函数, 不用set函数 </span></span></span><br><span class="line"><span class="comment"><span class="javascript">        set: function (newValue) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          // set函数一般有一个形参用于接收传递进来的参数</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          const names = newValue.split(&quot; &quot;);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.firstName = names[0];</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.lastName = names[1];</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        get: function () &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          return this.firstName + &quot; &quot; + this.lastName;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      &#125; */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// computed 中一般不会用来设置属性, 所以只写get函数, 所以省略写法可以这样写</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="methods和computed的区别"><a href="#methods和computed的区别" class="headerlink" title="methods和computed的区别"></a>methods和computed的区别</h3><ul><li>methods是函数方法, 如果调用多少次就会调用多少次</li><li>computed是计算属性, 具有缓存机制, 在数据没有改变的情况下, 只会调用一次</li><li>所以在对数据进行处理的话就用computed计算属性, 而对事件的绑定则使用methods方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Vue中v-on事件监听</title>
      <link href="2021/05/25/03-Vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>2021/05/25/03-Vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="v-on指令的基本使用"><a href="#v-on指令的基本使用" class="headerlink" title="v-on指令的基本使用"></a>v-on指令的基本使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="comment">  &lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="comment">  &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 语法糖 @写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">counter</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.counter++</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.counter--</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on的参数传递问题"><a href="#v-on的参数传递问题" class="headerlink" title="v-on的参数传递问题"></a>v-on的参数传递问题</h3><ul><li>第一种情况, 如果方法本身不需要传入参数, 调用方法的时候小括号可以省略</li><li>第二种情况, 如果方法本身需要传入参数, 但是调用方法的时候没有省略小括号, 也没有传入参数, 那么方法内的变量就是undefined<ul><li>如果省略了小括号, 但是这个方法本事是需要一个参数传入的, 那么Vue就会默认将浏览器生成的事件对象当作参数传入</li></ul></li><li>第三种情况, 如果方法既需要传入一个参数, 又需要传入浏览器生成的事件对象event, 那么要获取这个事件对象event, 就用 $event</li><li>传入参数的注意事项, 如果传入的参数带引号, 那么这个参数表示一个字符串, 如果这个参数没有引号, 那么这个参数表示一个变量, 注意Vue中的变量都需要在data中定义, 不然会报错<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 情况1, 方法本身不需要传递参数, 调用方法时的小括号可以省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn1()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn1&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 情况2, 方法本身需要传递一个参数, 调用方法的时候没有省略小括号, 也没有传入参数, 那么这个形参就为undefined --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2(&#x27;abc&#x27;)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里就是没有省略小括号, 也没有传入参数, 那么就是undefined --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2()&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果省略了小括号, 但是这个方法本事是需要一个参数传入的, 那么Vue就会默认将浏览器生成的事件对象当作参数传入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2&quot;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 情况3, 如果在定义方法的时候, 既需要传入一个参数, 又需要传入浏览器产生的event对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 那么要获取这个这个event对象, 就用 $event --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传入参数的时候注意引号的问题, 有引号表示字符串, 没引号代表变量, $event代表浏览器产生的event对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn3(&#x27;abc&#x27;, $event)&quot;</span>&gt;</span>按钮5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn1</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮1被按了&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn2</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn3</span>(<span class="params">abc, event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(abc, event);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="v-on的修饰符"><a href="#v-on的修饰符" class="headerlink" title="v-on的修饰符"></a>v-on的修饰符</h3><ul><li>修饰符是 .修饰符 这样的格式 写在事件类型的后面的</li><li>停止冒泡修饰符 .stop  例如 @click.stop=()</li><li>阻止默认行为 .prevent</li><li>既想停止冒泡 又想阻止默认行为, 那么就要用修饰符串联语法 .stop.prevent</li><li>想要当事件是从特定的键触发时才触发回调, 那么就用键修饰符, 也可以用键的ASCII码 例如 键修饰符 .enter  ASCII码修饰符 .13</li><li>想要监听组件的事件, 必须加上修饰符 .native</li><li>想要事件只能触发一次 就用 .once 修饰符</li><li>示例代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span></span><br><span class="line">  我是div文字</span><br><span class="line">  <span class="comment">&lt;!-- 如果要阻止事件冒泡, 那么就给事件添加修饰符.stop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是btn文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 既想要阻止事件冒泡, 又想要阻止标签的默认行为, 那么就需要串联修饰符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;aClick&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果要阻止标签的默认行为, 就给事件添加修饰符.prevent --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;aClick&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果只当事件是从特定的键触发时才触发回调, 那么就用键修饰符, 也可以用键的ASCII码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;enterOn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.13</span>=<span class="string">&quot;enterOn&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果想要事件只执行一次, 那么就用修饰符.once --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>只能点击一次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">divClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;divClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;aClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">enterOn</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;enterOn&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-VueMustache语法与一些指令</title>
      <link href="2021/05/25/02-VueMustache%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4/"/>
      <url>2021/05/25/02-VueMustache%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h4><ul><li>又称大胡子语法 就是用两个大括号来包裹变量 从而挂钩Vue去解析里面的代码</li><li>比如</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mustache语法中不仅仅可以直接写变量, 还可以写一些简单的表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;first&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter * 2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-once指令-不是很常用"><a href="#v-once指令-不是很常用" class="headerlink" title="v-once指令 (不是很常用)"></a>v-once指令 (不是很常用)</h4><ul><li>在某些情况下, 有一些元素我们不想它响应式地根据数据的改变而改变的时候, 给这个元素加上v-once指令后, 它就只会渲染一次, 之后就不会再渲染</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> // 这个元素会动态响应渲染</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> // 这个元素不会动态响应渲染</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-html指令"><a href="#v-html指令" class="headerlink" title="v-html指令"></a>v-html指令</h4><ul><li>有时候服务器端传过来的数据并不是一个字符串 而是一个html标签, 这个时候就可以用v-html指令来渲染这个标签</li><li>v-html指令不用Mustache语法, 这是为了安全的考虑 而且这个指令一般用于信任的数据<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">url</span>: <span class="string">&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="v-test指令"><a href="#v-test指令" class="headerlink" title="v-test指令"></a>v-test指令</h4><ul><li>因为会覆盖原来标签里面的内容,而且不能进行字符串的拼接, 所有很少使用</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟Mustache语法差不多, 但是Mustache语法用得多, 因为v-text使用不灵活, 会覆盖原来标签里面的东西 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-test</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-pre指令"><a href="#v-pre指令" class="headerlink" title="v-pre指令"></a>v-pre指令</h4><ul><li>把标签里面的东西原封不动的显示在页面, 带有这个指令的标签不进行Vue的处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个标签里面的东西就不会进入Vue渲染了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h4><ul><li>在某些情况下, 浏览器可能会直接显示出未经过Vue渲染的代码</li><li>v-cloak指令会在vue渲染之前存在, 而在vue渲染之后自动删除</li><li>利用这个特性, 可以将代码通过CSS的属性选择器先把代码隐藏起来, 在vue渲染之后删除了这个指令, 代码自动就显示出来了, 增强用户体验, 但是以后vue的代码会有更好的方法解决这个问题,所以这个指令也不常用</li></ul><h4 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h4><ul><li>想要动态绑定标签的属性值, 不能直接用mustache语法, 而要用v-bind指令前缀</li><li>v-bind指令的语法糖是 :</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 想要动态绑定标签的属性, 不可以直接用mustache语法, 而要用v-bind前缀 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 语法糖写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- a标签也一样 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;aHerf&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">imgUrl</span>: <span class="string">&quot;https://cn.vuejs.org/images/logo.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">aHerf</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-bind指令的对象语法-用得较多"><a href="#v-bind指令的对象语法-用得较多" class="headerlink" title="v-bind指令的对象语法 (用得较多)"></a>v-bind指令的对象语法 (用得较多)</h4><ul><li>v-bind还可以动态地绑定class, 达到动态绑定样式的效果</li><li>动态绑定的class, 里面传入一个对象, 键值对的形式 {key:value},key是一个类名,value是一个布尔值, 为true则为这个class添加这个key, 反之则不添加</li><li>动态绑定的class, 和静态的class可以共存的, 动态绑定的class不会覆盖静态的class</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind还可以动态地绑定class, 达到动态绑定样式的效果 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 动态绑定的class, 里面传入一个对象, 键值对的形式 &#123;key:value&#125;,value是一个布尔值, 为true则为这个class添加这个key, 反之则不添加 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active : isActive, line : isLine&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 动态绑定的class, 和静态的class可以共存的, 动态绑定的class不会覆盖静态的class --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active : isActive, line : isLine&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果class的内容过于复杂的话, 可以将class的内容放入methods中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">isLine</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">btnClick</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">getClasses</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 调用这个方法的时候返回一个对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;<span class="attr">active</span> : <span class="built_in">this</span>.isActive, <span class="attr">line</span> : <span class="built_in">this</span>.isLine&#125; <span class="comment">// 方法中调用变量记得要加this</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-bind绑定class的数组写法-不常用"><a href="#v-bind绑定class的数组写法-不常用" class="headerlink" title="v-bind绑定class的数组写法 (不常用)"></a>v-bind绑定class的数组写法 (不常用)</h4><ul><li>特点跟对象写法差不多</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 数组写法 跟对象写法差不多 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[active , line]&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意数组中的元素加引号和不加引号的区别, 加引号表示一个字符串, 不加引号表示一个变量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;, &#x27;line&#x27;]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟对象一样如果class过于复杂也可以, 写到methods里面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">active</span>: <span class="string">&quot;aaa&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">line</span>: <span class="string">&quot;bbb&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">getClasses</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> [<span class="built_in">this</span>.active, <span class="built_in">this</span>.line] <span class="comment">// 方法中调用变量记得加this</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用v-bind动态绑定style-对象写法-常用"><a href="#用v-bind动态绑定style-对象写法-常用" class="headerlink" title="用v-bind动态绑定style (对象写法, 常用)"></a>用v-bind动态绑定style (对象写法, 常用)</h4><ul><li>与动态绑定class写法差不多, 传入一个对象{key(属性名) : value(属性值)}</li><li>动态绑定的与静态编写的不会覆盖</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟动态绑定class差不多, 传入一个对象 &#123;key(属性名) : value(属性值)&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:&#x27;100px&#x27;&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传入参数的时候, 要注意引号的添加, 不加引号代表一个变量, 加了引号代表一个字符串, 绑定多个style用逗号隔开即可 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: finalSize, background : finalColor&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">finalSize</span>: <span class="string">&quot;100px&quot;</span>, <span class="comment">// 如果这里写的100 ,那么在标签内引入的时候记得要利用字符串拼接加上单位&quot;px&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">finalColor</span>: <span class="string">&quot;red&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用v-bind动态绑定style-数组写法-我感觉这个写法很蠢-不常用"><a href="#用v-bind动态绑定style-数组写法-我感觉这个写法很蠢-不常用" class="headerlink" title="用v-bind动态绑定style (数组写法, 我感觉这个写法很蠢, 不常用)"></a>用v-bind动态绑定style (数组写法, 我感觉这个写法很蠢, 不常用)</h4><ul><li>在数组中传入一个一个的对象, 对象是键值对写法, 与对象写法一致</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 数组写法, 数组中传入一个对象,可以传入多个对象,逗号隔开, 对象写的是&#123;key(属性名) : value(属性值)&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">[baseStyle]</span>&gt;</span>你好啊<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">baseStyle</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">backgroundColor</span>: <span class="string">&quot;red&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-vue学习笔记-vue特点</title>
      <link href="2021/05/12/01-vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E7%89%B9%E7%82%B9/"/>
      <url>2021/05/12/01-vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h3><h4 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h4><ul><li>下载vue 可以通过cdn引入vue 也可以下载vue.js本地引入</li><li>vue的基本使用<ul><li>在引入vue后 new Vue({}) 一个vue对象</li><li>这样操作是为了防止XSS,csrf的攻击</li><li>然后就可以在html中进行vue操作了 例如</li><li>例如</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span> : <span class="string">&#x27;#box&#x27;</span>, <span class="comment">//此处写需要进行vue渲染的元素</span></span><br><span class="line">    <span class="attr">data</span> : &#123;</span><br><span class="line">        <span class="comment">// 此处写变量</span></span><br><span class="line">        <span class="attr">myname</span> : <span class="string">&#x27;xiaoLam&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123;20+30&#125;&#125; // 输出50</span><br><span class="line">    &#123;&#123;myname&#125;&#125; // 输出xiaoLam</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="以前的js做法-编程范式-命令式编程"><a href="#以前的js做法-编程范式-命令式编程" class="headerlink" title="以前的js做法 (编程范式: 命令式编程)"></a>以前的js做法 (编程范式: 命令式编程)</h4><ol><li>创建一个div元素,设置id属性</li><li>定义一个变量message</li><li>将这个变量插入div元素中</li><li>如果修改了message的数据</li><li>就要重新将修改后的数据重新插入div</li></ol><h4 id="1-模板语法-编程范式-声明式编程-优点是数据处理和页面渲染分开管理-可以很方便地动态响应数据的改变"><a href="#1-模板语法-编程范式-声明式编程-优点是数据处理和页面渲染分开管理-可以很方便地动态响应数据的改变" class="headerlink" title="1.模板语法 (编程范式: 声明式编程) 优点是数据处理和页面渲染分开管理 可以很方便地动态响应数据的改变"></a>1.模板语法 (编程范式: 声明式编程) 优点是数据处理和页面渲染分开管理 可以很方便地动态响应数据的改变</h4><ul><li>(1) 插值<ul><li>文本插值 使用双大括号<ul><li>在页面中插入文本的时候 需要将想插入的文本方法双层大括号中</li></ul></li><li>插入html标签 (处于安全考虑,只插入信任的内容)<ul><li>在需要插入html标签的元素中添加 v-html属性(其实叫 指令) 值为要插入的键, 例如</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span> : <span class="string">&#x27;#box&#x27;</span>, <span class="comment">//此处写需要将vue对象挂载到哪一个元素</span></span><br><span class="line">    <span class="attr">data</span> : &#123;</span><br><span class="line">        <span class="comment">// 此处写变量 自己定义的属性 也可以是来自网络的数据 网络的数据改变的话, 页面显示的数据动态改变(这个就是响应式的优点)</span></span><br><span class="line">        <span class="attr">myname</span> : <span class="string">&#x27;xiaoLam&#x27;</span>,</span><br><span class="line">        <span class="attr">myhtml</span>: <span class="string">&#x27;&lt;h1&gt;你好你好&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123;20+30&#125;&#125; // 输出50</span><br><span class="line">    &#123;&#123;myname&#125;&#125; // 输出xiaoLam</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&#x27;myhtml&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> // 输出渲染后的myhtml</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(2) 指令: 是带有v- 前缀的特殊属性<ul><li>v-html 插入标签</li><li>v-show 判断是否显示节点 值为布尔值 true表示显示 flase表示隐藏</li><li>v-if 判断是否创建节点 值为布尔值 true表示创建 flase表示不创建</li></ul></li></ul><h4 id="2-class和style"><a href="#2-class和style" class="headerlink" title="2. class和style"></a>2. class和style</h4><ul><li>(1) 绑定HTML class<ul><li>动态绑定class有三种写法<ul><li>三目运算符写法</li><li>对象写法</li><li>数组写法</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">classObj</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">b</span>: <span class="literal">true</span></span><br><span class="line">            <span class="comment">// a, b 为class的名字</span></span><br><span class="line">            <span class="comment">// 对象写法有一个缺点就是不能在没有定义之前创建class</span></span><br><span class="line">            <span class="comment">// 就比如classObj没有定义 c 这个class 那么就不能动态地创建 c 这个class</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">classArr</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>] <span class="comment">// 要操作数组中的元素也是按照JS的语法来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;isActive?&#x27;red&#x27;:&#x27;blue&#x27;&quot;</span>&gt;</span>动态绑定class 三目运算符写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>动态绑定class 对象写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classArr&quot;</span>&gt;</span>动态绑定class 数组写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(2) 动态绑定style 跟动态绑定class差不多</li><li>(3) 想要绑定事件就Vue对象中的methods中编写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 添加变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">// 添加方法</span></span><br><span class="line">        <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for-指令"><a href="#v-for-指令" class="headerlink" title="v-for 指令"></a>v-for 指令</h3><ul><li>可以遍历数组中的元素</li><li>实际上就是JS中的for-in循环 例如:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in movies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  // 这里就可以循环movies数组中的元素 是响应式的,会自动检测movies中的数据, 增删改都会实时更新</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">movies</span>: [<span class="string">&quot;肖申克的救赎&quot;</span>, <span class="string">&quot;少年派&quot;</span>, <span class="string">&quot;星际穿越&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-on-添加事件监听指令-语法糖"><a href="#v-on-添加事件监听指令-语法糖" class="headerlink" title="v-on 添加事件监听指令  语法糖 @"></a>v-on 添加事件监听指令  语法糖 @</h3><ul><li>用于给元素添加事件监听</li><li>具体用法<ul><li>给需要的添加的元素添加属性 v-on:事件类型=”触发的函数名称”</li><li>在Vue对象中的methods中编写对应函数</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.counter++; <span class="comment">// 注意要获取data中的变量 需要写this. 否则Vue会在html中查找该名字的元素</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;add被触发了&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">sub</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.counter--;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;sub被触发了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="VUE中的MVVM-model-view-viewModel"><a href="#VUE中的MVVM-model-view-viewModel" class="headerlink" title="VUE中的MVVM (model view viewModel)"></a>VUE中的MVVM (model view viewModel)</h3><ul><li><p>view层</p><ul><li>视图层</li><li>在前端开发中, 通常就是DOM层</li><li>主要作用就是给用户展示各种信息</li></ul></li><li><p>Model层</p><ul><li>数据层</li><li>可以是自己写的固定数据, 可以是从服务器端请求下来的动态数据</li><li>如果是动态数据在VUE中就可以通过ViewModel实时刷新数据</li></ul></li><li><p>viewModel层</p><ul><li>视图模型层</li><li>是view 和 model 之间沟通的桥梁</li><li>一方面实现了Data Binding(数据绑定), 将Model的改变实时地反映在View中</li><li>另一方面 实现了 DOM listener (DOM监听), 当DOM触发事件的时候, 可以改变对应的Data</li></ul></li></ul><h3 id="Vue实例中传入的options"><a href="#Vue实例中传入的options" class="headerlink" title="Vue实例中传入的options"></a>Vue实例中传入的options</h3><ul><li>有很多 现在只学了三个 el , data , methods</li><li>el : 类型string | HTMLElement   作用是决定Vue实例会管理哪一个DOM</li><li>data : 类型Object | Function   是Vue实例对应的数据对象, [注]在组件当中data必须是一个函数</li><li>methods : 类型{[key:string] : Function}  作用是定义属于Vue的一些方法,可以在其他地方调用, 也可以在指令中调用</li></ul><h4 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h4><ul><li>函数 function 在全局运用</li><li>方法 method 与某个实例对象挂钩的函数就是方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
