<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>认识token验证</title>
      <link href="2021/05/26/%E8%AE%A4%E8%AF%86token%E9%AA%8C%E8%AF%81/"/>
      <url>2021/05/26/%E8%AE%A4%E8%AF%86token%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="认识token"><a href="#认识token" class="headerlink" title="认识token"></a>认识token</h3><ul><li>cookie和session的方式有很多的缺点<ul><li>cookie会被附加在每一个HTTP请求中, 即是这个HTTP请求不需要cookie, 所以无形中增加了流量</li><li>cookie是使用明文传递的,所以存在安全性问题, session可以解决这个问题,但是session也是可以自行使用base64解密的, 除非使用加严操作</li><li>cookie的大小限制是4kb, 所以对于复杂的需求来说是不够用的</li><li>对于浏览器外的其他客户端, 比如安卓和IOS, 必须手动地设置cookie和session</li><li>对于分布式系统和服务器集群中想要正确地解析session是比较困难的</li><li>token解决这个问题的方式为, 只有一台服务器拥有私钥和颁发token的权限, 而其他服务器拥有公钥和解析token的权限, 以此方便地解析token</li></ul></li><li>所以在目前的前后端分离开发过程中, 使用token来进行身份验证是最多的情况<ul><li>token可以翻译为令牌</li><li>也就是在验证了用户账号和密码正确的情况下, 给用户颁发一个令牌</li><li>这个令牌作为后续用户访问一些接口或者资源的凭证</li><li>我们可以根据这个凭证来判断用户是否有权限来访问</li></ul></li><li>所以token的使用一个分成两个重要的步骤<ul><li>生成token: 登陆的时候, 颁发token</li><li>验证token: 访问某些资源或者接口的时候, 验证token</li></ul></li></ul><h3 id="JWT-json-web-token-实现Token机制"><a href="#JWT-json-web-token-实现Token机制" class="headerlink" title="JWT(json web token)实现Token机制"></a>JWT(json web token)实现Token机制</h3><ul><li>JWT的作用就是帮助我们生成token</li><li>JWT生成的Token由三个部分组成:<ul><li>header<ul><li>alg: 采用的加密算法, 默认的是HMAC SHA256(HS256), 采用同一个密钥进行加密和解密</li><li>typ: JWT, 固定值, 通常都写成JWT即可</li><li>会通过base64Url算法进行编码</li></ul></li><li>payload<ul><li>携带的数据, 比如我们可以将用户的id和name放到payload中</li><li>默认也会携带iat(issued at), 也就是令牌的签发时间</li><li>我们也可以设置令牌的过期时间: exp(expiration time)</li><li>会通过base64Url算法进行编码</li></ul></li><li>signature<ul><li>设置一个secretKey, 通过将前面两个的结果合并后进行HMACSHA256的算法</li><li>HMACSHA256(base64Url(header)+.+base64Url(payload), secretKey);</li><li>但是如果secretKey暴露是一件十分危险的时器, 英文之后就可以模拟颁发token, 也可以解密token了</li></ul></li></ul></li></ul><h3 id="Token的使用"><a href="#Token的使用" class="headerlink" title="Token的使用"></a>Token的使用</h3><ul><li>在真实开发中, 直接使用jsonwebtoken来实现<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用jsonwebtoken库</span></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置secretKey</span></span><br><span class="line"><span class="keyword">const</span> SECRET_KEY = <span class="string">&quot;xiaoLam123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆验证颁发token</span></span><br><span class="line">testRouter.post(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 首先获取到用户的信息</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后通过jwt.sign方法生成token</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(user, SECRET_KEY, &#123;</span><br><span class="line">    <span class="comment">// 设置过期时间, 对应秒</span></span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">10</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 然后将生成的token返回给客户端</span></span><br><span class="line">  ctx.body = token;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证token接口</span></span><br><span class="line">testRouter.get(<span class="string">&quot;/auth&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一般来说, 客户端会将token放在headers中, 所以从headers中获取token</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.headers.authorization;</span><br><span class="line">  <span class="comment">// 对authorization进行字符串切割获取真正的token</span></span><br><span class="line">  <span class="keyword">const</span> token = authorization.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回验证信息</span></span><br><span class="line">  <span class="comment">// 注意jsonwebtoken库中, 如果验证失败的话会抛出错误, 所以使用try catch来捕获错误</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用jwt.verify来解析验证从客户端传递过来的token, 将token和密钥作为参数传入即可</span></span><br><span class="line">    <span class="keyword">const</span> result = jwt.verify(token, SECRET_KEY);</span><br><span class="line">    ctx.body = result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;token错误 &quot;</span> + error.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><ul><li>HS256加密算法使用单一密钥, 如果一旦暴露就是非常危险的事情<ul><li>比如在分布式系统中, 每一个子系统都需要获得密钥来对token进行解析</li><li>那么拿到这个密钥后子系统既可以颁发token, 也可以验证token</li><li>但是对于一些资源服务器来说, 只需要由验证token的能力就足够了</li></ul></li><li>这个时候我们可以使用非对称加密, RS256<ul><li>私钥(private key): 用于颁发token</li><li>公钥(public key): 用于验证token</li></ul></li><li>我们可以使用openssl工具来生成一对私钥和公钥<ul><li>Mac电脑可以直接使用terminal终端来使用openssl</li><li>但是window电脑中默认的cmd终端是不能直接使用的, 建议使用git bash终端来使用openssl</li></ul></li><li>openssl的基本使用<ul><li>生成一个私钥<ul><li>genrsa -out 输出的文件名 私钥长度</li><li>比如: genrsa -out private.key 1024</li></ul></li><li>根据私钥生成一个公钥<ul><li>rsa -in 私钥的文件名 -pubout -out 输出的文件名</li><li>比如: rsa -in private.key -pubout -out public.key</li></ul></li></ul></li></ul><h3 id="使用公钥和私钥签发和验证签名"><a href="#使用公钥和私钥签发和验证签名" class="headerlink" title="使用公钥和私钥签发和验证签名"></a>使用公钥和私钥签发和验证签名</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&quot;jsonwebtoken&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testRouter = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取私钥和公钥</span></span><br><span class="line"><span class="keyword">const</span> PRIVATE_KEY = fs.readFileSync(<span class="string">&quot;./keys/private.key&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> PUBLIC_KEY = fs.readFileSync(<span class="string">&quot;./keys/public.key&quot;</span>);</span><br><span class="line"></span><br><span class="line">testRouter.post(<span class="string">&quot;/login&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 首先获取到用户信息</span></span><br><span class="line">  <span class="keyword">const</span> user = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据用户信息和私钥生成token</span></span><br><span class="line">  <span class="comment">// jwt中传入secretKey的参数可以传入Buffer</span></span><br><span class="line">  <span class="keyword">const</span> token = jwt.sign(user, PRIVATE_KEY, &#123;</span><br><span class="line">    <span class="attr">expiresIn</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="comment">// 注意因为是使用了非默认算法进行加密, 所以要设置加密方式</span></span><br><span class="line">    <span class="attr">algorithm</span>: <span class="string">&quot;RS256&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回密钥</span></span><br><span class="line">  ctx.body = token;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">testRouter.get(<span class="string">&quot;/auth&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取密钥</span></span><br><span class="line">  <span class="keyword">const</span> authorization = ctx.headers.authorization;</span><br><span class="line">  <span class="keyword">const</span> token = authorization.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 验证token</span></span><br><span class="line">  <span class="keyword">const</span> result = jwt.verify(token, PUBLIC_KEY, &#123;</span><br><span class="line">    <span class="attr">algorithms</span>: [<span class="string">&quot;RS256&quot;</span>]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  ctx.body = result;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(testRouter.routes());</span><br><span class="line">app.use(testRouter.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;使用非对称密钥服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h3><ul><li>在项目中的任何一个地方的相对路径, 都是相对于process.cwd()的, 也就是相对于启动目录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> token验证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie和session</title>
      <link href="2021/05/26/cookie%E5%92%8Csession/"/>
      <url>2021/05/26/cookie%E5%92%8Csession/</url>
      
        <content type="html"><![CDATA[<h3 id="登陆凭证"><a href="#登陆凭证" class="headerlink" title="登陆凭证"></a>登陆凭证</h3><ul><li>为什么需要登陆凭证呢?<ul><li>在Web开发中, 使用最多的协议式http协议, 但是http协议是一个无状态协议</li></ul></li><li>什么式无状态协议?<ul><li>比如说, 我们登陆了一个网站, 在登陆的时候需要输入用户名和密码</li><li>登陆成功后, 我们以用户的身份访问其他数据和资源, 还是通过http请求去访问的</li><li>但是对于服务器来说, 每一次请求都是一个单独的请求, 和之前的请求没有任何关系, 所以服务器不会认可我们的用户身份</li><li>这个就是http的无状态, 也就是服务器不知道你上一步做了什么, 所以我们需要由登陆凭证</li></ul></li></ul><h3 id="认识cookie"><a href="#认识cookie" class="headerlink" title="认识cookie"></a>认识cookie</h3><ul><li>Cookie(复数形态Cookies), 又称为”小甜饼”, 类型为”小型文本文件”, 某些网站为了辨别用户身份而存储在用户本地终端(Client Side)上的数据<ul><li>浏览器会在特定的情况下携带上cookie来发送请求, 我们可以通过cookie来获取到一些信息</li></ul></li><li>Cookie总是保存至客户端中, 按照在客户端中的存储位置, Cookie可以分为内存Cookie和硬盘Cookie<ul><li>内存Cookie由浏览器维护, 保存至内存中, 浏览器关闭的时候Cookie就会消失, 其存在的时间是短暂的</li><li>硬盘Cookie保存在硬盘中, 有一个过期时间, 用户手动清理或者过期时间到了, 才会被清理</li></ul></li><li>如何判断一个Cookie是内存Cookie还是硬盘Cookie?<ul><li>没有设置过期时间, 默认情况下Cookie是内存Cookie, 其在关闭浏览器的时候会自动删除</li><li>有设置过期时间, 并且过期时间不为0或者负数的cookie为硬盘cookie, 需要手动或者到期的时候才会被删除</li></ul></li></ul><h3 id="cookie常见的属性"><a href="#cookie常见的属性" class="headerlink" title="cookie常见的属性"></a>cookie常见的属性</h3><ul><li>cookie的生命周期<ul><li>默认情况下cookie是内存cookie, 也称为会话cookie, 也就是在浏览器关闭的时候会被自动删除</li><li>我们可以通过设置expire或者max-age来设置过期时间<ul><li>expire: 设置的是Date.toUTCString(), 设置格式是: exoires= date-in-GMTString-format;</li><li>max-age: 设置过期的秒钟, max-age=max-age-in-seconds</li></ul></li></ul></li><li>cookie的作用域: 允许cookie发送给哪些URL<ul><li>Domain: 指定哪些主机可以接受cookie<ul><li>如果不指定, 默认就是origin, 不包括子域名</li><li>如果指定了Domain, 则包含子域名, 例如: 如果设置Doamin=mozila.org,则cookie也包含在子域名中(如developer.mozila.org)</li></ul></li><li>Path: 指定主机下哪些路径可以接收cookie<ul><li>例如: 设置Path=/docs, 则以下地址都会匹配<ul><li>/docs</li><li>/doce/Web/</li><li>/doce/Web/HTTP</li></ul></li></ul></li></ul></li></ul><h3 id="客户端中设置cookie"><a href="#客户端中设置cookie" class="headerlink" title="客户端中设置cookie"></a>客户端中设置cookie</h3><ul><li>js直接设置和获取cookie<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取cookie</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置内存cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;name=xiaoLam;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置硬盘cookie</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;name=somin;max-age=5;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何删除cookie, 本质是找到对应的cookie, 将其的max-age设置为0</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;name=somin;max-age=0;&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="服务器中设置cookie"><a href="#服务器中设置cookie" class="headerlink" title="服务器中设置cookie"></a>服务器中设置cookie</h3><ul><li>Koa中默认支持直接操作cookie<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如何在服务器端设置cookie</span></span><br><span class="line"><span class="comment">// 使用cookies.set(name, value, option对象)方法即可设置</span></span><br><span class="line"><span class="comment">// 该方法需要传入三个参数, 前两个参数为键值对, 第三个参数为option对象可以设置cookie的一些属性</span></span><br><span class="line">testRouter.get(<span class="string">&quot;/set&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.cookies.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaoLam&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 注意这里的maxAge对应的是毫秒数</span></span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  ctx.body = <span class="string">&quot;你的cookie已经设置好了&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何在服务器端获取到cookie</span></span><br><span class="line"><span class="comment">// 使用cookies.get(name)方法即可获取</span></span><br><span class="line">testRouter.get(<span class="string">&quot;/get&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = ctx.cookies.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  ctx.body = <span class="string">`你的cookie为<span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Session是基于cookie来实现的"><a href="#Session是基于cookie来实现的" class="headerlink" title="Session是基于cookie来实现的"></a>Session是基于cookie来实现的</h3><ul><li>在Koa中, 我们需要借助koa-session来实现session认证</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Session = <span class="built_in">require</span>(<span class="string">&quot;koa-session&quot;</span>);</span><br><span class="line"><span class="comment">// 在koa中使用session需要借助第三方库 koa-session</span></span><br><span class="line"><span class="comment">// 实际上, session是借助cookie来实现的</span></span><br><span class="line"><span class="comment">// session只是把cookie中设置的value值使用base64进行了一层加密</span></span><br><span class="line"><span class="comment">// 所以session主要是解决cookie传递的使用使用明文传递的缺点</span></span><br><span class="line"><span class="comment">// 创建session的配置</span></span><br><span class="line"><span class="keyword">const</span> session = Session(&#123;</span><br><span class="line">  <span class="comment">// key用于设置cookie的name值</span></span><br><span class="line">  <span class="attr">key</span>: <span class="string">&quot;sessionid&quot;</span>,</span><br><span class="line">  <span class="comment">// 这里的maxAge也是对应毫秒的</span></span><br><span class="line">  <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">  <span class="comment">// 通过设置signed的值来设置是否使用前面, 为true(默认)的时候不可以修改对应的value值, 设置为false的时候可以进行修改</span></span><br><span class="line">  <span class="attr">signed</span>: <span class="literal">true</span></span><br><span class="line">&#125;, app);</span><br><span class="line"><span class="comment">// 使用keys进行加严操作</span></span><br><span class="line">app.keys = [<span class="string">&quot;aaa&quot;</span>];</span><br><span class="line">app.use(session);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">testRouter.get(<span class="string">&quot;/set&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> id = <span class="number">110</span>;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过ctx.session来设置value</span></span><br><span class="line">  ctx.session.user = &#123;</span><br><span class="line">    id,</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.body = <span class="string">&quot;session 设置成功&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何在服务器端获取到session</span></span><br><span class="line">testRouter.get(<span class="string">&quot;/get&quot;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 直接通过ctx.sesstion 来获取对应的cookie</span></span><br><span class="line">  ctx.body = ctx.session.user</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> cookie和session </tag>
            
            <tag> 数据存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识ORM</title>
      <link href="2021/05/26/%E8%AE%A4%E8%AF%86ORM/"/>
      <url>2021/05/26/%E8%AE%A4%E8%AF%86ORM/</url>
      
        <content type="html"><![CDATA[<h3 id="认识ROM"><a href="#认识ROM" class="headerlink" title="认识ROM"></a>认识ROM</h3><ul><li>对象关系映射(英语: Object Relational Mapping), 简称ORM, 或者O/RM mapping, 是一种程序设计的方法<ul><li>从效果来讲, 它提供了一个可在编程语言中, 使用虚拟对象数据库的效果</li><li>比如在Java开发中经常使用的ORM包括: Hibernate, MyBatis</li></ul></li><li>Node当中的ORM我们通常使用的是sequelize<ul><li>sequelize是用于Postgres, MySQL, MariaDB, SQLite和Microsoft SQL Server的基于Node.js的ORM</li></ul></li><li>如果我们希望讲Sequelize和MySQL一起使用, 那么我们需要先安装两个东西<ul><li>mysql2: sequelize在操作mysql是使用的是mysql2</li><li>sequelize: 使用它来让对象映射到表中</li></ul></li></ul><h3 id="Sequelize的使用"><a href="#Sequelize的使用" class="headerlink" title="Sequelize的使用"></a>Sequelize的使用</h3><ul><li>Sequelize连接数据库<ul><li>第一步: 创建一个Sequelize的对象, 并且指定数据库 用户名 密码 数据库类型 主机地址等</li><li>第二步: 使用authenticate方法来连接数据库</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  Sequelize</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&quot;sequelize&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 一个Sequelize类, 并传入四个参数</span></span><br><span class="line"><span class="comment">// 第一个参数为需要连接的数据库名称</span></span><br><span class="line"><span class="comment">// 第二个参数为用户名</span></span><br><span class="line"><span class="comment">// 第三个参数为密码</span></span><br><span class="line"><span class="comment">// 第四个参数为一个对象, 里面填写相关的option</span></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">&#x27;coderhub&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;xiaoLam&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="attr">dialect</span>: <span class="string">&#x27;mysql&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过authenticate方法连接启动连接, 该方法返回一个Promise对象, 所以可以通过then和catch获取返回的信息</span></span><br><span class="line">sequelize.authenticate().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库连接失败&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> ORM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识Buffer</title>
      <link href="2021/05/26/%E8%AE%A4%E8%AF%86Buffer/"/>
      <url>2021/05/26/%E8%AE%A4%E8%AF%86Buffer/</url>
      
        <content type="html"><![CDATA[<h3 id="数据的二进制"><a href="#数据的二进制" class="headerlink" title="数据的二进制"></a>数据的二进制</h3><ul><li>计算机中所有的内容: 文字, 数字, 图片, 音频, 视频最终都是通过二进制进行表示的</li><li>JavaScript可以直接去处理非常直观的数据: 比如字符串, 通常展示出来的也是这些字符串内容</li><li>JavaScript是不可以处理图片的<ul><li>事实上在网页端, 图片是交友浏览器处理的</li><li>JavaScript或者HTML只是负责将这个图片的地址告诉给浏览器</li><li>浏览器负责根据这个图片地址, 渲染出这个图片</li></ul></li><li>一般来说, 在前端是不需要处理图片的</li><li>但是对于服务器端来说就不一样了<ul><li>服务器端要处理的本地文件类型相对较多</li><li>比如保存文本的文件并不是使用UTF-8进行编码的, 而是使用GBK, 那么我们必须读取到其二进制数据, 再通过GBK转换成对应的文字</li><li>比如我们需要读取的是一张图片的数据(二进制), 再通过某些手段对图片数据进行二次的处理(裁剪, 格式转换, 旋转, 添加滤镜), Node中有一个Sharp的库, 可以读取图片或者对传入图片的Buffer进行处理</li><li>比如Node中通过TCP建立长链接, TCP传输的是字节流, 我们需要将图片数据转换为字节再进行传输, 并且需要知道传输字节的大小(客服端需要根据大小来判断读取多少内容)</li></ul></li></ul><h3 id="Buffer和二进制"><a href="#Buffer和二进制" class="headerlink" title="Buffer和二进制"></a>Buffer和二进制</h3><ul><li>对于前端开发来说, 很少会和二进制打交道, 但是对于服务器端为了做很多的功能, 必须要去操作二进制的数据</li><li>所以Node为了可以方便开发者完成更多功能, 提供给了我们一个类, 这个类称为Buffer, 而且是一个全局类</li><li>Buffer中存储的是二进制数据, 那么到底是如何存储的呢?<ul><li>我们可以将buffer看成是一个存储二进制的数组</li><li>这个数组中的每一项, 可以存储8位二进制</li></ul></li><li>为什么是8位呢?<ul><li>在计算机中, 很少情况下回操作一位的二进制, 因为一位的二进制可以存储的数据十分有限</li><li>所以通常会将8位合在一起作为一个单元, 这个单元称为一个字节(byte)</li><li>也就是说 1byte = 8bit, 1kb = 1024byte, 1M = 1024kb</li><li>比如很多编程语言中的int类型是4个字节, long类型是8个字节</li><li>比如TCP传输的是字节流, 在写入和读取的时候都需要说明字节的个数</li><li>比如RGB的值分别是255, 所以本质上在计算机中都是使用一个字节存储的</li></ul></li></ul><h3 id="Buffer和字符串"><a href="#Buffer和字符串" class="headerlink" title="Buffer和字符串"></a>Buffer和字符串</h3><ul><li>Buffer相当于是一个字节的数组, 数组中的每一项对于一个字节的大小</li><li>如果我们希望将一个字符串放入到Buffer中, 过程如下<ul><li>首先字符串会被分割为一个一个的字符, 每一个字符都会通过ASCII编码转换为一个字节, 每一个字节又会被转换位十六进制的数据类型, Buffer中就将每一个十六进制的数据存储到一个数组中</li></ul></li><li>如果存储的数据是中文<ul><li>首先会将中文通过UTF-8编码转换, 然后再进行上面的过程</li></ul></li></ul><h3 id="Buffer的其他创建方式"><a href="#Buffer的其他创建方式" class="headerlink" title="Buffer的其他创建方式"></a>Buffer的其他创建方式</h3><ul><li>Buffer.alloc()<ul><li>使用Buffer.alloc可以创建一个有固定长度的buffer, 里面所有的数据默认都是00</li><li>注意创建的时候需要指定大小, 否则可能会报错</li><li>像数组一样, 可以对buffer中某一个位置的数据进行修改</li><li>如果想要存储十六进制的数据</li></ul></li></ul><h3 id="Buffer的创建过程"><a href="#Buffer的创建过程" class="headerlink" title="Buffer的创建过程"></a>Buffer的创建过程</h3><ul><li>事实上创建Buffer时, 并不会频繁地向操作系统申请内存, 而是会默认先申请一个8 * 1024个字节大小的内存, 也就是8kb</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> Buffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPM包管理工具详解</title>
      <link href="2021/05/26/NPM%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/26/NPM%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="如何共享代码"><a href="#如何共享代码" class="headerlink" title="如何共享代码"></a>如何共享代码</h3><ul><li>JavaScript中可以通过模块化的方式将代码划分为一个个小的结构<ul><li>在以后的开发中就可以通过模块化的方式来封装自己的代码, 并且封装成一个工具</li><li>这个工具我们可以让别人通过导入的方式来使用, 甚至分享给全世界的任何人</li></ul></li><li>如何共享我们的代码呢?</li><li>方式一: 上传到github中, 让其他程序员通过github下载然后手动地引用<ul><li>缺点是别人必须知道我们代码地github地址, 并且从github上手动地下载下来</li><li>在项目中需要手动地引用, 并且管理相关的依赖</li><li>不需要使用的时候, 需要手动地删除相关的依赖</li><li>当遇到版本升级或者切换的时候, 需要重复上面的操作</li><li>显然, 这种方法很麻烦, 并且容易出错</li></ul></li><li>方式二: 使用一个专业的工具来管理我们的代码<ul><li>我们通过工具将代码发布到特定的位置</li><li>让其他人直接通过这个工具来安装, 升级, 删除, 管理我们的工具代码</li></ul></li></ul><h3 id="包管理工具npm"><a href="#包管理工具npm" class="headerlink" title="包管理工具npm"></a>包管理工具npm</h3><ul><li>显然, 通过第二种方式我们可以更好地管理自己的工具包, 其他人也可以更好地使用我们的工具包</li><li>包管理工具npm<ul><li>Node package manager, Node包管理器</li><li>目前已经不仅仅是Node包管理器了, 在前端项目中也可以使用它来管理依赖包</li><li>比如express, koa, react, react-dom, axios, babel, webpack等等</li></ul></li><li>npm管理的包可以在哪里查看, 搜索呢?<ul><li><a href="http://www.npmjs.org/">www.npmjs.org</a>, 也就是npm包的官网</li></ul></li><li>npm管理的包存放在哪里呢?<ul><li>但我们发布自己的包其实是发布在registry上面的</li><li>当我们安装一个包的时候其实是从registry上面下载的包</li></ul></li></ul><h3 id="项目配置文件"><a href="#项目配置文件" class="headerlink" title="项目配置文件"></a>项目配置文件</h3><ul><li>实际上, 每一个项目都会有一个对应的配置文件, 无论是前端项目还是后端项目<ul><li>这个配置文件会记录你的项目名称, 版本号, 项目描述等等</li><li>也会记录你项目所依赖的其他库的信息和依赖库的版本号</li></ul></li><li>这个配置文件在Node环境下面(无论是前端还是后端)就是package.json文件</li></ul><h3 id="package-json文件中常见的属性"><a href="#package-json文件中常见的属性" class="headerlink" title="package.json文件中常见的属性"></a>package.json文件中常见的属性</h3><ul><li>必须填写的属性: name, version<ul><li>name: 项目的名称</li><li>version: 当前项目的版本号</li><li>description: 项目的描述信息, 作为项目的基本描述</li><li>author: 作者信息, 项目发布的时候会用到</li><li>license: 开源协议, 项目发布的时候会用到</li></ul></li><li>private属性<ul><li>记录当前项目是否为私有项目</li><li>当值为true的时候, npm是不会发布这个项目的, 这是防止私有项目或者模块发布到网络上公开.</li></ul></li><li>main属性:<ul><li>这个属性是设置程序的入口的</li><li>很多人会以火, webpack不是会自动找到程序的入口吗?<ul><li>这个属性设置的入口和webpack打包的入口并不冲突</li><li>这个入口是发布一个模块的时候, 这个模块的入口</li><li>比如axios模块 const axios = require(“axios”), 此时就会找到axios模块的入口, 实际上就是找到axios模块中package.json文件中的main属性查找模块的入口</li></ul></li></ul></li><li>script属性<ul><li>script属性用于配置一些脚本命令, 以键值对的形式存在</li><li>配置后可以通过npm run 命令的key来执行这个命令</li><li>npm start 和npm run start 的区别的<ul><li>实际上是等价的</li><li>只是npm 对于一些比较常用的命令, 比如start, test, stop, restart做了一个优化, 可以省略掉run直接通过npm start的方式运行</li></ul></li></ul></li><li>dependencies属性<ul><li>dependencies属性用于指定开发环境和生成环境都需要依赖的包</li><li>通常是我们项目中实际开发中用到的一些库模块</li><li>与之对应的属性是devDependencies属性</li></ul></li><li>devDependencies属性<ul><li>一些包在生成环境下是不需要的, 比如webpack, babel等包</li><li>这个时候会通过npm install webpack –save-dev, 来将它安装到devDependencies属性中, 表示这个模块包在生成环境中是不需要用到的, 减少生成环境的程序的大小</li></ul></li><li>engines属性<ul><li>engines属性用于指定Node和NPM的版本号</li><li>在安装的过程中, 会先检查对应的引擎版本, 如果不符合就会报错</li><li>事实上也可以指定所在的操作系统 “os”: [“darwin”, “linux”], 一般很少使用</li></ul></li><li>browserslist属性<ul><li>用于配置打包后的JavaScript浏览器的兼容情况, 参考;</li><li>否则我们需要手动的添加polyfills来支持某些语法</li><li>也就是说它是为webpack等打包工具服务的一个属性</li></ul></li></ul><h3 id="版本管理问题"><a href="#版本管理问题" class="headerlink" title="版本管理问题"></a>版本管理问题</h3><ul><li>安装的依赖版本的版本号有: ^2.0.3 和 ~2.0.3 这两种</li><li>这是由于npm的包是遵循semver版本规范的<ul><li>semver：<a href="https://semver.org/lang/zh-CN/">https://semver.org/lang/zh-CN/</a></li><li>npm semver：<a href="https://docs.npmjs.com/misc/semver">https://docs.npmjs.com/misc/semver</a></li></ul></li><li>semver版本规范是X.Y.Z<ul><li>主版本号X(major): 当你做了不兼容的API修改(可能不兼容之前的版本), 此时修改主版本号</li><li>次版本号Y(minor): 当你做了向下兼容的功能性新增(新功能增加, 但是兼容之前的版本), 此时修改次版本号</li><li>修订号Z(patch): 当你做了向下兼容的问题修正(没有新功能, 修复了之前版本的bug), 此时修改修订号</li></ul></li><li>^x.y.z 和 ~x.y.z的区别<ul><li>^x.y.z：表示x是保持不变的，y和z永远安装最新的版本；</li><li>~x.y.z：表示x和y保持不变的，z永远安装最新的版本；</li></ul></li></ul><h3 id="npm-install-命令"><a href="#npm-install-命令" class="headerlink" title="npm install 命令"></a>npm install 命令</h3><ul><li>安装npm包分两种情况<ul><li>全局安装(global install): npm install yarn -g;</li><li>项目(局部)安装 (local install): npm install yarn</li></ul></li><li>全局安装<ul><li>全局安装是直接将某个包安装到全局</li><li>比如yarn的全局安装: npm install yarn -g</li></ul></li><li>全局安装的意义<ul><li>通常使用npm全局安装的包都是一些工具包: yarn, webpack等</li><li>并不是类似于axios, express, koa等库文件</li><li>如果将axios, express, koa等的库文件进行全局安装的话, 之后并不能让我们在所有项目中使用axios等的库</li></ul></li></ul><h3 id="项目-局部-安装"><a href="#项目-局部-安装" class="headerlink" title="项目(局部)安装"></a>项目(局部)安装</h3><ul><li>局部安装会在当前目录下生成一个node_modules文件夹, require函数查找引入模块的时候会从这个文件夹中查找对应的模块</li><li>局部安装分为开发时依赖和生产时依赖<ul><li>安装开发和生产依赖<ul><li>npm install axios</li><li>npm i axios</li></ul></li><li>开发时依赖<ul><li>npm install webpack –save-dev</li><li>npm install webpack -D</li><li>npm i webpack -D</li></ul></li><li>根据package.json中的配置安装依赖<ul><li>npm install</li></ul></li></ul></li></ul><h3 id="npm-install-的原理"><a href="#npm-install-的原理" class="headerlink" title="npm install 的原理"></a>npm install 的原理</h3><ul><li>从npm5开始, npm支持缓存策略(来自yarn的压力)</li><li>npm install 执行后 会检测项目目录中是否有package-lock.json文件<ul><li>如果没有lock文件<ul><li>会分析依赖关系, 因为包会依赖其他的包, 并且多个包之间会产生相同依赖的情况</li><li>然后从registry仓库中下载压缩包(从npm5开始有的)</li><li>将压缩包解压到项目的node_modules文件夹中(前面我们讲过, require的查找顺序会从这个文件夹中查找)</li></ul></li><li>如果有lock文件<ul><li>会检测lock文件中包的版本是否和package.json中的包版本是否一致(会按照semver版本规范检测)<ul><li>如果不一致, 会重新构建依赖关系, 直接走上面没有lock文件的流程</li></ul></li><li>如果版本一致, 会去优先查找缓存<ul><li>如果没有找到, 会从registry仓库下载, 然后还是接着走上面的流程</li></ul></li><li>如果找到了, 会获取缓存中的压缩文件, 并且将压缩文件解压到node_modules文件夹中</li></ul></li></ul></li></ul><h3 id="package-lock-json-属性解析"><a href="#package-lock-json-属性解析" class="headerlink" title="package-lock.json 属性解析"></a>package-lock.json 属性解析</h3><ul><li>name: 项目名称</li><li>version: 项目版本</li><li>lockfileVersion: lock文件的版本</li><li>requires: 使用requires来记录模块的依赖关系</li><li>dependencies: 项目的依赖<ul><li>其中的依赖包也依赖其他的包</li><li>依赖包也有其他的属性<ul><li>version: 表示实际安装的依赖包的版本</li><li>resolved用来记录下载的地址, registry仓库中的地址</li><li>requires记录当前模块的依赖</li><li>integrity用来从缓存中获取索引, 再通过索引去获取压缩包文件</li></ul></li></ul></li></ul><h3 id="npm中的其他命令"><a href="#npm中的其他命令" class="headerlink" title="npm中的其他命令"></a>npm中的其他命令</h3><ul><li>卸载某一个依赖包<ul><li>npm uninstall package</li><li>npm uninstall package –save-dev</li><li>npm uninstall package -D</li></ul></li><li>强制重新构建<ul><li>npm rebuild</li></ul></li><li>清除缓存 (当缓存包损坏的时候可以使用这个命令清除缓存)<ul><li>npm cache clean</li></ul></li><li>npm的命令其实是很多的<ul><li><a href="https://docs.npmjs.com/cli-documentation/cli">https://docs.npmjs.com/cli-documentation/cli</a></li><li>更多的命令，可以根据需要查阅官方文档</li></ul></li></ul><h3 id="yarn工具"><a href="#yarn工具" class="headerlink" title="yarn工具"></a>yarn工具</h3><ul><li>yarn工具是另外一个node包管理工具<ul><li>yarn是由facebook, google, exponent和tilde联合推出的一个新的JS包管理工具</li><li>yarn是为了弥补npm的一些缺陷而出现的</li><li>早期的npm存在很多的缺陷, 比如安装依赖速度很慢, 版本依赖混论等等一系列问题(包的依赖是树结构的, 所以会出现依赖的包重叠的情况)</li><li>虽然从npm5版本开始, 进行了很多的升级改进, 但是还是有很多人依然喜欢使用yarn</li></ul></li><li>yarn工具和npm的命令行差不多, 这里只列出几个比较重要的命令<ul><li>安装命令: yarn install, 这个命令是通过 package.json安装包的命令</li><li>安装命令: yarn add package, 这个命令是安装独立包的命令</li><li>卸载命令: yarn remove package, 这个命令是卸载包的命令</li></ul></li></ul><h3 id="cnpm工具"><a href="#cnpm工具" class="headerlink" title="cnpm工具"></a>cnpm工具</h3><ul><li>由于一些特殊的原因(因为registiry仓库服务器地址是在国外的), 所以在某些情况下在国内没办法很好地从<a href="https://registry.npmjs.org上下载需要的包/">https://registry.npmjs.org上下载需要的包</a></li><li>此时的解决方法有两种<ul><li>方法一: 修改npm的镜像源<ul><li>命令行输入: npm config get registry 这个命令行可以查看当前npm的源</li><li>命令行输入: npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 这个命令可以将npm的源设置为淘宝镜像源</li><li>如果你不希望修改npm的默认设置, 或者担心某一天淘宝的镜像源失效了, 可以使用方法二解决</li></ul></li><li>方法二: 使用cnpm, 并且将cnpm设置为淘宝的镜像<ul><li>通过命令行输入: npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> 可以全局安装cnpm并且设置源为淘宝镜像源</li><li>通过命令行输入: cnpm config get registry 查看当前cnpm的源</li></ul></li></ul></li></ul><h3 id="npx工具"><a href="#npx工具" class="headerlink" title="npx工具"></a>npx工具</h3><ul><li>npx是npm5.2之后自带的一个命令<ul><li>npx的作用非常多, 比较常见的是使用它来调用项目中某个模块的指令</li></ul></li><li>以webpack为例<ul><li>全局安装webpack5.1.3</li><li>项目安装webpack3.6.0</li></ul></li><li>此时在项目目录下终端输入命令行 webpack –version, 此时调用的是全局安装的webpack5.1.3<ul><li>原因是因为在当前目录下找不到webpack的时候, 就会去全局查找, 并且执行命令</li></ul></li><li>如果想要使用项目安装的webpack, 如何解决呢?<ul><li>方式一: 明确找到node_module下面的webpack来执行<ul><li>终端中使用如下命令: ./node_modules/.bin/webpack –version</li></ul></li><li>方式二: 修改package.json中的scripts<ul><li>“scripts”: { “webpack” : “webpack –version” }</li></ul></li><li>方式三: 使用npx<ul><li>npx webpack –version</li></ul></li></ul></li><li>npx的原理其实非常简单, 它会到当前目录的node_modules/.bin目录下查找对应的命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> 包管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的模块化规范</title>
      <link href="2021/05/26/JavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <url>2021/05/26/JavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h3><ul><li><p>什么是模块化开发?</p><ul><li>事实上模块化开发最终的目的是将程序划分为一个个小的结构</li><li>这个结构中编写属于本身的逻辑代码, 有自己的作用域, 不会影响到其他的结构</li><li>这个结构可以将自己希望暴露的变量, 函数, 对象等导出, 供给其他结构使用</li><li>也可以通过某种方式, 导入其他结构中的变量, 函数, 对象等</li></ul></li><li><p>以上说到的结构, 就是模块; 按照这种结构划分开发程序的过程, 就是模块化开发的过程</p></li></ul><h3 id="早期的JavaScript"><a href="#早期的JavaScript" class="headerlink" title="早期的JavaScript"></a>早期的JavaScript</h3><ul><li>早期的JavaScript有很多的缺陷<ul><li>var定义的变量作用域问题;<ul><li>这个问题在ES6后, 通过使用let 和 const定义变量就解决了这个问题</li></ul></li><li>JavaScript的面向对象并不能像常规面向对象语言一样使用class<ul><li>这个问题也在ES6后, 通过class关键字解决了</li></ul></li><li>JavaScript没有模块化<ul><li>这个问题在ES6后, 也得到了完善</li></ul></li></ul></li><li>现在的JavaScript的最紧急的问题是, 没有静态类型检测, 这也是为什么TypeScript发展起来的原因之一</li><li>在网页开发的早期, Brendan Eich开发的JavaScript只是作为一种脚本语言, 做一些简单的表单验证和动画实现等, 那个时候JS的代码量是很少的</li><li>但是随着前端和JavaScript的快速发展, JavaScript的代码量越来越多, 越来越复杂<ul><li>ajax的出现, 前后端开发分离, 意味着后端返回数据后, 需要通过JavaScript进行前端页面的渲染</li><li>SPA(单页面富应用)的出现, 前端页面变得更加复杂: 包括前端路由, 页面状态管理等等一系列复杂的需求需要通过JavaScript实现</li><li>Node的出现, JavaScript可以编写复杂的后端程序了</li></ul></li><li>所以模块化是JavaScript一个非常迫切的需求<ul><li>但是JavaScript本身, 知道ES6(2015)才推出了自己的模块化方案</li><li>那么在此之前, 为了让JavaScript支持模块化, 涌现了很多不同的模块化规范: AMD规范, CMD规范, CommenJS规范等</li></ul></li></ul><h3 id="没有模块化带来很多的问题"><a href="#没有模块化带来很多的问题" class="headerlink" title="没有模块化带来很多的问题"></a>没有模块化带来很多的问题</h3><ul><li>早期没有模块化带来了很多的问题: 比如命名冲突的问题</li><li>我们也有方法去解决上面的问题: 立即函数调用表达式(IIFE), 本质上就是使用函数本身自带的作用域形成闭包来保护变量不泄露<ul><li>IIFE(Immediately Invaoked Function Expression)</li></ul></li><li>但是这样做又带来了其他的问题<ul><li>首先: 我们必须记得每一个模块中返回对象的命名, 才能在其他模块中正确地使用</li><li>第二: 代码变得混乱, 每一个文件中的代码都需要包裹在一个匿名函数中编写</li><li>第三: 在没有合适的规范情况下, 每个人, 每个公司都有可能任意命名, 甚至出现模块名称相同的情况</li></ul></li><li>所以, 我们发现, 虽然实现了模块化, 但是我们使用IIFE的实现过于简单, 并且是没有规范的<ul><li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码</li><li>这个规范中应该包含核心功能: 模块本身可以导出暴露的属性, 模块又可以导入自己需要的属性</li><li>JavaScript社区为了解决上面的问题, 涌现出一系列好用的规范, 比如CommonJS, AMD, CMD等</li></ul></li></ul><h3 id="CommonJS和Node"><a href="#CommonJS和Node" class="headerlink" title="CommonJS和Node"></a>CommonJS和Node</h3><ul><li>我们需要知道CommonJS是一个规范, 最初设计出来是在浏览器以外的地方使用的, 并且当时被命名为ServerJS(意为主要使用在服务器端), 后来为了体现CommonJS的广泛性, 才将其改名为CommonJS, 平时也会简称CJS<ul><li>Node是CommonJS在服务器端一个具有代表性的实现</li><li>Browserify是CommonJS在浏览器中的一种实现</li><li>Webpack打包工具具备对CommonJS的支持和转换</li></ul></li><li>所以, Node对CommonJS进行了支持和是西安, 让我们在开发node的过程中可以方便地进行模块化开发<ul><li>在Node中每一个js文件都是一个单独的模块</li><li>这个模块中包含CommonJS规范的核心变量: exports, module.exports, require</li><li>我们可以使用这些变量来方便的进行模块化开发</li></ul></li><li>前面我们提到过模块化的核心是导出和导入, Node对其进行了实现<ul><li>exports和module.exports可以负责对模块中的内容进行实现</li><li>require函数可以帮助我们导入其他模块(包括自定义模块, 系统模块, 第三方库模块)中的内容</li></ul></li></ul><h3 id="Node中的CommonJS规范"><a href="#Node中的CommonJS规范" class="headerlink" title="Node中的CommonJS规范"></a>Node中的CommonJS规范</h3><ul><li>通过exports导出<ul><li>实际上, exports是一个对象, 我们可以在这个对象中添加很多个属性, 添加的属性就会被导出</li></ul></li><li>在另外一个文件中通过 require函数导入<ul><li>require函数需要传入一个参数, 这个参数就是需要导入的变量所在模块的路径</li><li>这个函数会返回一个对象, 这个对象本质上就是exports对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar.js中的代码</span></span><br><span class="line"><span class="keyword">const</span> myName = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Node实现的CommonJS规范来导出需要暴露的变量</span></span><br><span class="line"><span class="comment">// 通过 exports.属性名=属性值 的语法规范来导出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实质上exports是一个对象, 可以在这个对象中添加很多个属性, 添加的属性就会被导出</span></span><br><span class="line"><span class="built_in">exports</span>.myName = myName</span><br><span class="line"><span class="built_in">exports</span>.age = age</span><br><span class="line"><span class="built_in">exports</span>.sayHello = sayHello</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js中的代码</span></span><br><span class="line"><span class="comment">// 通过Node实现的CommonJS规范来导入需要的变量</span></span><br><span class="line"><span class="comment">// 通过require函数来导入, require函数会返回一个对象, 这个对象本质上就是exports对象</span></span><br><span class="line"><span class="comment">// require函数需要传入参数, 这个参数就是要导入的模块的路径</span></span><br><span class="line"><span class="comment">// 需要用一个变量来接收require函数返回的对象</span></span><br><span class="line"><span class="comment">// 这一句代码的意义实际上就是, const bar = exports</span></span><br><span class="line"><span class="comment">// 也就是说bar对象是exports对象的浅拷贝(引用赋值)</span></span><br><span class="line"><span class="comment">// 浅拷贝的本事就是一种引用赋值(也就是说修改bar.name的值, exports.name的值也会跟着改变)</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&quot;./bar&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时就可以通过bar对象访问这些暴露的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(bar.myName);</span><br><span class="line"><span class="built_in">console</span>.log(bar.age);</span><br><span class="line">bar.sayHello(<span class="string">&quot;kobe&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="module-exports又是什么"><a href="#module-exports又是什么" class="headerlink" title="module.exports又是什么?"></a>module.exports又是什么?</h3><ul><li>在Node中我们经常导出东西的时候, 是通过 module.exports导出的<ul><li>module.exports和exports有什么关系或者区别吗?</li></ul></li><li>实际上CommonJS规范中是没有module.exports的概念的<ul><li>但是为了实现模块的导出, Node中使用的是Module的类, 每一个模块都是Module的一个实例, 也就是module</li><li>所以在Node中真正用于导出的其实根本不是exports, 而是module.exports, 只是Node源码中做了一步, module.exports = exports 而已</li><li>也就是说module才是导出的真正实现者</li></ul></li><li>但是, 为什么exports也可以导出呢? <ul><li>因为module对象的exports属性是exports对象的一个引用</li><li>也就是说 module.exports = exports = require()</li></ul></li><li>在三者相互引用的情况下, 修改exports中的属性值<ul><li>那么三者中对应的属性值都会发生改变, 因为这三者都是指向同一个内存地址的</li></ul></li><li>在三者相互引用的情况下, 修改require()函数返回的对象中的属性值<ul><li>那么三者中对应的属性值都会发生变化, 因为这三者都是指向同一个内存地址</li></ul></li><li>如果module.exports不再引用exports对象了, 这个时候修改exports中的属性值<ul><li>只有exports对象中的属性值会发生改变, 而module.exports和require()函数返回的对象中的属性值是不会发生改变的</li></ul></li><li>总结: require()函数和module.exports是必定关联在一起的, Node中实现的CommonJS规范, 本质是就是 module.exports导出, require()函数导入, 只不过Node内部做了一步操作, 就是 module.exports = exports, 让module.exports引用exports对象, 所以通过exports也可以导出, 但是当module.exports不再引用exports的时候, exports就不可以导出了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Node中实现CommonJS规范, 本质上是通过 module.exports来导出的</span></span><br><span class="line"><span class="comment">// 只不过Node中做了一步操作 module.exports = exports , 所以通过exports也可以导出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports == <span class="built_in">exports</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果module.exports不再引用exports, 那么exports就不可以导出了</span></span><br><span class="line"><span class="comment">// 如下</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">myName</span> : <span class="string">&quot;jiaZhen&quot;</span>,</span><br><span class="line">  <span class="attr">age</span> : <span class="number">123</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过上面的代码操作就取消了 module.exports对exports的引用, 此时 require()函数导入的是 module.exports对象而不是 exports对象</span></span><br><span class="line"><span class="comment">// 而且, module.export 与 exports 不再指向同一个内存地址</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports == <span class="built_in">exports</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="exports存在的意义是什么"><a href="#exports存在的意义是什么" class="headerlink" title="exports存在的意义是什么?"></a>exports存在的意义是什么?</h3><ul><li>是因为CommonJS规范要求有一个exports作为导出</li><li>Node作出的妥协</li></ul><h3 id="require函数的细节"><a href="#require函数的细节" class="headerlink" title="require函数的细节"></a>require函数的细节</h3><ul><li>require是一个函数, 可以帮助我们引入一个文件(模块)中导出的对象</li><li>require的查找规则是怎么样的?</li><li>require的查找规则有很多, 这里列举常见的查找规则: 导入的格式: require(X)<ul><li>情况一: X是一个核心模块, 比如path, http<ul><li>直接返回核心模块, 并停止查找</li></ul></li><li>情况二: X是以./或者../或者/(根目录)开头的<ul><li>第一步: 将X当作一个文件在对应的目录下查找<ul><li>如果X有后缀名, 按照后缀名的格式查找对应的文件</li><li>如果X没有后缀名, 会按照以下顺序查找<ul><li>1&gt;直接查找文件X</li><li>2&gt;查找X.js文件</li><li>3&gt;查找X.json文件</li><li>4&gt;查找X.node文件</li></ul></li></ul></li><li>第二步: 没有找到对应的文件, 将X作为一个目录查找<ul><li>然后查找目录下的index文件<ul><li>1&gt;查找X/index.js文件</li><li>2&gt;查找X/index.json文件</li><li>3&gt;查找X/index.node文件</li></ul></li></ul></li><li>如果没有找到则报错: not found</li></ul></li><li>情况三: 直接是一个X(没有路径), 并且X不是一个核心模块<ul><li>此时会根据module对象中的paths数组中的路径一个一个从上往下查找对应路径中的 node_modules文件夹中的X/index.js文件</li><li>如果没找到则报错: not found</li></ul></li></ul></li></ul><h3 id="Node中模块的加载过程"><a href="#Node中模块的加载过程" class="headerlink" title="Node中模块的加载过程"></a>Node中模块的加载过程</h3><ul><li>一: Node中的模块加载时同步的</li><li>二: Node中的模块在被第一次引入的时候, 模块中的js代码就会被运行一次</li><li>三: 模块被多次引入的时候会缓存, 最终只加载(运行)一次<ul><li>为什么会只加载运行一次呢?</li><li>因为每一个模块对象module中都有一个属性: loaded</li><li>当loaded为false的时候表示该模块还没有被加载过, 当模块被加载完毕后loaded的值会变为true, 表示该模块被加载过了</li></ul></li><li>四: 如果有循环引入, 加载的顺序时深度优先搜索加载</li></ul><h3 id="CommonJS规范的缺点"><a href="#CommonJS规范的缺点" class="headerlink" title="CommonJS规范的缺点"></a>CommonJS规范的缺点</h3><ul><li>CommonJS加载模块是同步的<ul><li>同步就意味着有阻塞, 只有等到对应的模块加载完毕后, 当前模块中的内容才能被运行</li><li>这个问题如果在服务器端的话是不会有什么问题的, 因为服务器端加载的js文件都是本地文件, 加载速度非常快</li></ul></li><li>但是如果将CommonJS规范应用在浏览器端的话<ul><li>浏览器加载JS文件有时候是需要从服务器将文件先下载下来之后再加载运行的</li><li>那么CommonJS的同步加载模块就意味着后续的js代码都无法正常运行, 即使是一些简单的DOM操作</li></ul></li><li>所以再浏览器中, 通常是不使用CommonJS规范的<ul><li>当然再webpack中使用CommonJS是另外一回事</li><li>因为webpack会将代码转换为浏览器可以直接执行的代码(也就是说webpack会处理这个问题)</li></ul></li><li>在早期为了可以在浏览器中使用模块化, 通常会采用AMD或者CMD规范<ul><li>但是现在现代浏览器已经支持ES Modules, 另一方面借助于webpack等工具也是可以实现对CommonJS或者ES Modules代码的转换的</li><li>所以现在AMD和CMD规范已经很少使用了</li></ul></li></ul><h3 id="AMD规范"><a href="#AMD规范" class="headerlink" title="AMD规范"></a>AMD规范</h3><ul><li>AMD主要是应用于浏览器的一种模块化规范<ul><li>AMD是Asynchronous Module Definition (异步模块定义)的缩写</li><li>AMD规范使用的是异步加载模块</li><li>事实上AMD规范还要早于CommonJS规范</li></ul></li><li>AMD规范实现常用的库是require.js和curl.js</li><li>使用require.js来实现AMD规范的基本语法代码在03-AMD规范基本语法文件夹中</li></ul><h3 id="CMD规范"><a href="#CMD规范" class="headerlink" title="CMD规范"></a>CMD规范</h3><ul><li>CMD规范是应用于浏览器的一种模块化规范<ul><li>CMD是Common Module Definition（通用模块定义）的缩写；</li><li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li><li>但是目前CMD使用也非常少了</li></ul></li><li>CMD也有自己比较优秀的实现方案：<ul><li>SeaJS</li></ul></li><li>使用sea.js来实现CMD规范的基本语法代码在04-CMD规范基本语法文件夹中</li></ul><h3 id="认识ES-Module"><a href="#认识ES-Module" class="headerlink" title="认识ES Module"></a>认识ES Module</h3><ul><li>JavaScript没有模块化一直是它的痛点, 所以才会产生我们前面学习的社区规范, CMD, AMD, commonJS等</li><li>ES Module和CommonJS的模块化有一些不同之处<ul><li>一方面它使用了 import 和export 关键字</li><li>另一方面它采用编译期的静态分析, 并且加入了动态引用的方式</li></ul></li><li>ES Module模块采用export和import关键字来实现模块化<ul><li>export负责将模块内的内容导入</li><li>import负责从其他模块导入内容</li></ul></li><li>注意: 采用ES Module进行模块化将自动采用严格模式: use strict</li></ul><h3 id="使用ES-Module实现模块化的注意事项"><a href="#使用ES-Module实现模块化的注意事项" class="headerlink" title="使用ES Module实现模块化的注意事项"></a>使用ES Module实现模块化的注意事项</h3><ul><li>如果之间将使用了ES Module实现模块化的html代码直接在浏览器中运行的话<ul><li>将会遇到CORS错误(跨域错误), 这是由于JavaScript模块的安全性需要</li><li>此时需要使用一个服务器来测试我们的模块化代码</li><li>这里我们使用的是VScode中的一个插件 Live Server, 这个插件可以开启一个服务器来运行我们的html代码, 并且可以根据代码改变来实现页面的热更新</li></ul></li></ul><h3 id="export关键字"><a href="#export关键字" class="headerlink" title="export关键字"></a>export关键字</h3><ul><li>export关键字将一个模块中的变量, 函数, 类等导出</li><li>通过export关键字导出内容有以下三种方式<ul><li>方式一: 在语句声明的前面直接加上export关键字</li><li>方式二: 将所有需要导出的标识符, 放到export后面的{}大括号(不是对象)中<ul><li>注意: 这里的{}里面不是ES6对象字面量的增强写法, {}也不是一个对象</li><li>所以: export {name: name} 是错误的写法</li><li>导出的是变量的引用, 而不是变量的值</li></ul></li><li>方式三: 导出的时候给标识符起一个别名</li></ul></li></ul><h3 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h3><ul><li>import关键字负责从另外一个模块中导入内容</li><li>导入内容的方式常用的有三种方式<ul><li>方式一: import {标识符列表} form “模块路径”<ul><li>注意: 这里的{}也不是一个对象, 这个大括号里面只是存放导入的标识符列表内容</li></ul></li><li>方式二: 导入时给标识符起别名</li><li>方式三: 通过 * 将模块功能放到一个模块功能对象 (a module object) 中</li></ul></li></ul><h3 id="export和import-结合使用"><a href="#export和import-结合使用" class="headerlink" title="export和import 结合使用"></a>export和import 结合使用</h3><ul><li><p>export 和import 是可以结合使用的</p><ul><li>export {} from “模块的路径”</li></ul></li><li><p>这样做的意义</p><ul><li>在开发和封装一个功能库的时候, 通常我们希望将暴露的所有接口都放在一个文件中</li><li>这样方便指定统一的接口规范, 也方便阅读</li><li>这个时候, 就可以使用export和import结合来使用了</li></ul></li></ul><h3 id="default的用法"><a href="#default的用法" class="headerlink" title="default的用法"></a>default的用法</h3><ul><li>前面学习的导出方式都是有名字的导出 (named exports)<ul><li>在导出export的时候指定了名字</li><li>在导入import的时候也需要知道具体的名字</li></ul></li><li>还有一种导出的方式称为 默认导出 (default exports)<ul><li>默认导出 export 的时候可以不需要指定名字</li><li>在导入的时候不需要使用 {}, 并且可以自己来指定名字</li><li>它也方便我们和现有的CommonJS等规范相互操作</li></ul></li><li>注意: 在一个模块中, 只能有一个默认导出 (default export)</li></ul><h3 id="import函数"><a href="#import函数" class="headerlink" title="import函数"></a>import函数</h3><ul><li>通过import关键字来加载一个模块的时候, 是不可以将其放到逻辑代码中的<ul><li>这是因为ES Module在被JS引擎解析的时候, 就必须知道它的依赖关系</li><li>由于这个时候JS代码还没有任何的运行, 所以是无法根据代码逻辑来判断是否加载某一个模块的</li></ul></li><li>但是在某种情况下, 确实希望动态地加载某一个模块<ul><li>此时就需要使用import()函数来动态加载了</li><li>import函数在JS代码中是异步加载的</li><li>import函数会返回一个promise对象, 所以可以通过then来获取到需要导入的内容</li></ul></li></ul><h3 id="CommonJS的加载过程"><a href="#CommonJS的加载过程" class="headerlink" title="CommonJS的加载过程"></a>CommonJS的加载过程</h3><ul><li><p>CommonJS模块加载JS文件的过程是运行时加载的, 并且是同步的</p><ul><li>运行时加载意味着是js引擎在执行js代码过程中加载模块的, 所以可以将引入模块的代码写到逻辑代码里面</li><li>同步加载意味着一个文件没有加载结束之前, 后面的代码是不会继续执行的 (阻塞)</li></ul></li><li><p>CommonJS通过module.exports导出的是一个对象</p><ul><li>导出的是一个对象意味着可以将这个对象的引用在其他模块中赋值给其他变量</li><li>但是最终他们共同指向的是同一个对象, 如果修改了对象中的属性值, 那么其他地方的属性值也会跟着改变</li></ul></li></ul><h3 id="ES-Module的加载过程"><a href="#ES-Module的加载过程" class="headerlink" title="ES Module的加载过程"></a>ES Module的加载过程</h3><ul><li>ES Module加载js文件的过程是编译(解析)时加载的, 并且是异步的<ul><li>编译时加载, 意味着import不能和运行时相关的内容写在一起, 也就是说不可以将导入模块的代码写到逻辑代码中, 以下情况都不可以</li><li>比如from后面的路径需要动态获取的时候</li><li>比如将import写到if等逻辑语句中</li><li>所以我们有时候也称ES Module是静态解析的, 而不是动态或者运行时解析的</li></ul></li><li>异步意味着: JS引擎在执行代码的过程中遇到import的时候会去获取这个js文件, 但是这个获取过程是异步的, 并且不会阻塞主线程的继续执行<ul><li>也就是说设置了 type = module 的script标签, 相当于给该标签加上了async属性</li><li>如果该标签后面有普通的script标签以及对应的代码, 那么ES Module对应的js文件和代码不会阻塞它们的执行</li></ul></li><li>ES Module通过export导出的是变量本身的引用<ul><li>export在导出一个变量的时候, js引擎会解析这个语法, 并且创建一个称为 模块环境记录(module environment record) 的一块内存</li><li>在 模块环境记录 中会将变量进行绑定(binding), 而且这个绑定是实时绑定的(时刻绑定最新的变量)</li><li>而在导入的地方, 可以实时地获取到绑定地最新值</li></ul></li><li>所以, 如果在导出的模块中修改了变量, 那么导入地地方可以实时获取到最新的变量<ul><li>注意: 在导入的地方不可以修改获取的变量, 因为它只是绑定到这个变量上, 但是这个变量的绑定实质上是用const 来绑定的</li></ul></li><li>思考: 如果导出的是一个对象, 那么在引入的地方去修改这个对象中的属性值, 会成功吗?<ul><li>会成功的, 因为导出的是一个对象的话, 说明导出的是这个对象的内存地址, 而在引入的地方去修改这个对象中的属性值这个操作, 实际上是根据这个内存地址去找到对应的属性值去修改, 也就是说 导出的对象 和 引入的对象实际上指向的是同一块内存地址, 所以会成功</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在纯使用ES Module的情况下实现模块化</span></span><br><span class="line"><span class="comment">// 在通过import 来加载一个模块的时候, 是不可以将其放入逻辑代码中的</span></span><br><span class="line"><span class="comment">// 比如:</span></span><br><span class="line"><span class="comment">// const flag = true;</span></span><br><span class="line"><span class="comment">// if (flag) &#123;</span></span><br><span class="line"><span class="comment">//   import &#123;name, age&#125; from &quot;./modules/foo.js&quot; // 这里浏览器会报语法错误</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 出现这种情况的原因是因为, ES Module在被JS引擎解析的时候, 就必须知道模块与模块之间的依赖关系</span></span><br><span class="line"><span class="comment">// 而这个时候JS代码还没有实际运行起来, 所以是无法根据代码逻辑来判断是否加载某一个模块的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果在某些情况下, 确实需要动态来加载某个模块的话</span></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 第一种方式</span></span><br><span class="line">  <span class="comment">// 如果, 当前环境有webpack打包工具的话, 可以使用commonJS中的require来实现</span></span><br><span class="line">  <span class="comment">// const data = require(&quot;路径&quot;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 第二种方式:</span></span><br><span class="line">  <span class="comment">// 如果, 是纯JS中的ES Module来实现模块化的话</span></span><br><span class="line">  <span class="comment">// 可以使用 import()函数来实现</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&quot;./modules/foo.js&quot;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;import()函数中then中的打印&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// impor函数在JS中是异步调用的</span></span><br><span class="line">  <span class="comment">// 其返回值是一个promise对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node对ES-Module的支持"><a href="#Node对ES-Module的支持" class="headerlink" title="Node对ES Module的支持"></a>Node对ES Module的支持</h3><ul><li>在最新的Current的Node版本中(14.13.1), 支持es module需要进行如下操作<ul><li>方式一: 在package.json中配置type属性值为module(后续会学习, 现在还没有讲到package.json文件的作用, 其实这个文件的作用就是对项目文件的配置)</li><li>方式二: 在需要当作模块的js文件以.mjs为后缀, 表示使用ES Module模块化</li></ul></li></ul><h3 id="CommonJS和ES-Module的相互引用"><a href="#CommonJS和ES-Module的相互引用" class="headerlink" title="CommonJS和ES Module的相互引用"></a>CommonJS和ES Module的相互引用</h3><ul><li><p>结论一: 通常情况下, CommonJS是不能加载ES Module的导出内容的</p><ul><li>因为CommonJS是同步加载的, 但是ES Module是必须经过静态分析等操作的, 在ES Module的静态操作的过程中是不会执行JavaScript代码的</li><li>但是这个结论并不是绝对的, 在某些平台中是可以对代码进行针对性的解析的</li><li>在Node平台中式不支持的</li></ul></li><li><p>结论二: 多数情况下, ES Module式可以加载CommonJS导出的内容的</p><ul><li>ES Module在加载CommonJS导出的内容的时候, 会将module.exports导出的内容作为default导出的方式来使用</li><li>这个依然需要看具体的实现, 比如在webpack中是支持的, Node的最新版本也是支持的</li><li>在较早的Node版本中是不支持的</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> JS模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL2基础</title>
      <link href="2021/05/26/mySQL2%E5%9F%BA%E7%A1%80/"/>
      <url>2021/05/26/mySQL2%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="认识mysql2"><a href="#认识mysql2" class="headerlink" title="认识mysql2"></a>认识mysql2</h3><ul><li>前面我们所有的操作都是在GUI工具中, 通过SQL语句来获取结果的,真实开发中肯定是通过代码来完成所有的操作的</li><li>如何在Node的代码中执行SQL语句呢? 这里我们可以借助于两个库<ul><li>mysql: 最早的Node连接MySQL的数据库驱动</li><li>mysql2: 在mysql的基础之上, 进行了很多的优化 改进</li></ul></li><li>目前来说, 建议使用mysql2, 因为mysql2兼容了mysql的API, 并且提供了一些附加功能<ul><li>更快更好的性能</li><li>Prepared Statement(预编译语句)<ul><li>提高性能: 将创建的语句模块发送个MySQL, 然后MySQL编译(解析, 优化, 转换)语句模块, 并且存储它但是不执行, 之后我们在真正执行的时候会给MySQL提供实际的参数才会执行; 就算多次执行, 也只会编译一次, 所以性能是更好的</li><li>支持Promise. 所以可以使用async和await语法</li><li>等等</li></ul></li></ul></li></ul><h3 id="使用mysql2"><a href="#使用mysql2" class="headerlink" title="使用mysql2"></a>使用mysql2</h3><ul><li>安装mysql2<ul><li>npm install mysql2</li></ul></li><li>mysql2的基本使用过程如下:<ul><li>第一步: 创建链接(通过createConection), 并且获取连接对象</li><li>第二部: 执行SQL语句(通过query)即可</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&quot;mysql2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建数据库连接</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;coderhub&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xiaoLam&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 执行SQL语句</span></span><br><span class="line"><span class="keyword">const</span> statement = <span class="string">`SELECT * FROM products WHERE price &gt; 8000;`</span>;</span><br><span class="line"><span class="comment">// 通过query的方式执行即可</span></span><br><span class="line">connection.query(statement, <span class="function">(<span class="params">err, result, field</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Prepared-Statement-预编译语句"><a href="#Prepared-Statement-预编译语句" class="headerlink" title="Prepared Statement(预编译语句)"></a>Prepared Statement(预编译语句)</h3><ul><li>Prepared Statement(预编译语句)<ul><li>提高性能: 将创建的语句模块发送给MySQL, 然后MySQL编译(解析 优化 转换)语句模块, 并且存储语句但是不执行, 之后再真正执行的时候给?提供实际的参数才会执行; 就算多次执行, 也只会编译一次, 所以性能是更高的</li><li>放置SQL注入, 之后传入的值不会像模块引擎那样按照传入的MySQL语句编译, 那么一些SQL注入的内容就不会被执行; OR 1 = 1 不会被执行</li></ul></li><li>强调: 如果再次执行预编译语句, 它将会从LRU(Least Recently Used)(一个用于处理缓存的算法) Cache中获取, 省略了编译statement的时间来提高性能</li></ul><h3 id="Connection-Pools"><a href="#Connection-Pools" class="headerlink" title="Connection Pools"></a>Connection Pools</h3><ul><li>前面我们创建了一个连接(connection), 但是如果我们有多个请求的话, 该连接很有可能正在被占用, 那么我们是否需要每次一个请求都去创建一个新的连接呢?<ul><li>事实上, mysql2给我们提供了一个连接池(connection pools)</li><li>连接池可以在需要的时候自动创建连接, 并且创建的连接不会被销毁, 会被放到连接池值, 后续是可以继续使用的</li><li>我们可以在创建连接池的时候设置LIMIT, 也就是最大创建个数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建连接池</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createPool(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;coderhub&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xiaoLam&#x27;</span>,</span><br><span class="line">  <span class="comment">// connectionLimit 表示最多可以建立多少个连接</span></span><br><span class="line">  <span class="attr">connectionLimit</span>: <span class="number">10</span></span><br><span class="line">  <span class="comment">// queueLimit 表示队列中的连接 一般不会设置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用连接池</span></span><br><span class="line"><span class="keyword">const</span> statement = <span class="string">`SELECT * FROM products WHERE price &gt; ? AND score &gt; ?;`</span></span><br><span class="line"></span><br><span class="line">connection.execute(statement, [<span class="number">6000</span>, <span class="number">7</span>], <span class="function">(<span class="params">err, result, field</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise方式"><a href="#Promise方式" class="headerlink" title="Promise方式"></a>Promise方式</h3><ul><li>目前在JavaScript开发中中我们更习惯Promise和awiat, async的方式进行异步处理, mysql2同样也是支持的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建连接池</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createPool(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;coderhub&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;xiaoLam&#x27;</span>,</span><br><span class="line">  <span class="comment">// connectionLimit 表示最多可以建立多少个连接</span></span><br><span class="line">  <span class="attr">connectionLimit</span>: <span class="number">10</span></span><br><span class="line">  <span class="comment">// queueLimit 表示队列中的连接 一般不会设置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用连接池</span></span><br><span class="line"><span class="keyword">const</span> statement = <span class="string">`SELECT * FROM products WHERE price &gt; ? AND score &gt; ?;`</span></span><br><span class="line"></span><br><span class="line">connection.promise().execute(statement, [<span class="number">6000</span>, <span class="number">7</span>])</span><br><span class="line">  .then(<span class="function">(<span class="params">[result, fileds]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 实质上返回的结果是一个数组, 里面包含了fileds的信息的</span></span><br><span class="line">    <span class="comment">// 这里对这个结果进行了一个解构</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mySQL数据库基本</title>
      <link href="2021/05/26/mySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC/"/>
      <url>2021/05/26/mySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么需要数据库"><a href="#为什么需要数据库" class="headerlink" title="为什么需要数据库"></a>为什么需要数据库</h3><ul><li>任何软件系统都需要存放大量的数据, 这些数据通常都是非常复杂和庞大的<ul><li>比如用户信息包括姓名、年龄、性别、地址</li><li>比如商品信息包括商品名称、描述、价格、分类标签、商品图片等</li><li>比如歌曲信息包括歌曲名称、歌手、专辑、歌曲时长、歌词、封面等</li></ul></li><li>这些信息如果直接存储到文件系统中可以吗？可以，但是文件系统有很多缺点<ul><li>很难以合适的方式组织数据(多张表之前的关系合理组织)</li><li>并且对数据进行增删改查中的复杂操作(虽然一些简单确实可以), 并且保证操作的原子性</li><li>很难实现数据共享, 比如一个数据库需要为多个程序服务</li><li>需要考虑如何进行数据的高效备份 迁移 恢复</li></ul></li><li>数据库通俗来说就是一个存储数据的仓库, 本质上就是一个软件 一个程序</li></ul><h3 id="常见的数据库有哪些"><a href="#常见的数据库有哪些" class="headerlink" title="常见的数据库有哪些"></a>常见的数据库有哪些</h3><ul><li>通常我们将数据库划分为两类: 关系型数据库和非关系型数据库</li><li>关系型数据库: MySQL、Qracle、DB2、SQL Server、Postgre SQL等<ul><li>关系型数据库通常我们会创建很多个二维数据表</li><li>数据表之间相互关联起来, 形成一对一 一对多 多对多等关系</li><li>之后可以利用SQL语句再多张表中查询我们所需的数据</li><li>支持事务, 对数据的访问更加的安全</li></ul></li><li>非关系型数据库:MongoDB、Redis、Memcached、HBse等<ul><li>非关系型数据库的英文其实是Not Only SQL, 简称为NoSQL</li><li>相对而言非关系型数据库比较简单一些, 存储数据也会更加自由(甚至我们可以直接将一个复杂的json对象直接塞入数据库中)</li><li>NoSQL是基于Key-Value的对应关系, 而且查询的过程中不需要进过SQL解析, 所以性能更高</li></ul></li><li>如何在开发中选择数据库? 具体的选择会根据不同的项目进行综合的分析<ul><li>一般来说, 目前再公司进行后端开发(Node, Java, Go等), 还是以关系型数据库为主</li><li>比较常用的用到非关系型数据的情况是再爬取大量的数据需要进行存储的时候会比较常见</li></ul></li></ul><h3 id="认识MySQL"><a href="#认识MySQL" class="headerlink" title="认识MySQL"></a>认识MySQL</h3><ul><li>MySQL的介绍:<ul><li>MySQL原本是一个开源的数据库, 原开发者为瑞典的MySQL AB公司</li><li>再2008年被Sun公司收购; 再2009年, Sun被Oracle收购</li><li>所以目前MySQL归属于Oracle(甲骨文)</li></ul></li><li>MySQL是一个关系型数据库, 其实本质上就是一款软件, 一个程序<ul><li>这个程序中管理着多个数据库</li><li>每个数据库中可以有多张表</li><li>每个表中可以有多条数据</li></ul></li></ul><h3 id="MySQL的连接操作"><a href="#MySQL的连接操作" class="headerlink" title="MySQL的连接操作"></a>MySQL的连接操作</h3><ul><li>打开终端, 查看MySQL的安装<ul><li>mysql –version</li><li>如果mySQL安装成功后, 会出现mySQL的版本信息</li></ul></li><li>如果我们想要操作数据, 需要先和数据库建立链接, 最直接的方式就是通过终端来连接</li><li>有两种方式来连接<ul><li>两种方式的区别在于输入密码一个是直接输入, 一个是另起一行以密文的形式输入</li><li>方式一: 终端命令行输入 mysql -uroot -p密码</li><li>方式二: 终端命令行输入 mysql -uroot -p 回车, 另起一行输入密码 然后回车</li><li>注意在git bash中如果出现 输入连接命令却没有反应的情况下, 在命令行前添加 winpty即可解决</li></ul></li></ul><h3 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h3><ul><li>一个数据库软件中, 可以包含很多个数据库<ul><li>命令行输入 show databases; 即可查看数据库, 注意分号;也是必须填入的 </li></ul></li><li>此时我们可以看到MySQL默认帮我们创建了几个数据库<ul><li>infomation_schema: 信息数据库, 其中包括MySQL在维护的其他数据库, 表列, 访问权限等信息</li><li>performance_schema: 性能数据库, 记录着MySQL_Server数据库引擎在运行过程中的一些资源消耗相关的信息</li><li>mysql: 用于存储数据库管理者的用户信息 权限信息 以及一些日志信息等</li><li>sys: 相当于是一个简易版的performance_schema, 将性能数据库中的数据汇总成更容易理解的形式</li></ul></li></ul><h3 id="创建数据库-表"><a href="#创建数据库-表" class="headerlink" title="创建数据库-表"></a>创建数据库-表</h3><ul><li>在终端中直接创建一个属于自己的新的数据库(一般情况下一个新的项目会对应一个新的数据库)<ul><li>create database 数据库名;</li></ul></li><li>使用指定的数据库<ul><li>use 数据库名;</li></ul></li><li>在数据库中, 创建一张表<ul><li>create table user(name varchar (20), age int, height double);</li></ul></li><li>在表中插入数据<ul><li>insert into user (name, age, height) values (“xiaoLam”, 18, 1.88);</li></ul></li></ul><h3 id="GUI工具的介绍"><a href="#GUI工具的介绍" class="headerlink" title="GUI工具的介绍"></a>GUI工具的介绍</h3><ul><li>我们会发现在终端操作数据库有很多不方便的地方<ul><li>语句写出来没有高亮, 并且不会有任何提示</li><li>复杂的语句分成多行, 格式看起来不美观, 很容易出现错误</li><li>终端中查看所有的数据库或者表非常的不直观和不方便</li><li>等等</li></ul></li><li>所以在开发中, 我们可以借助于一些GUI工具来帮助我们连接上数据库, 之后直接在GUI工具中操作就很方便了</li><li>常见的MySQL的GUI工具有很多<ul><li>Navicat: 最好用的, 但是收费</li><li>SQLYog: 免费, 但是界面很丑</li><li>TablePlus: 常用的功能都可以使用, 但是会多一些限制(比如只能开两个标签页)</li></ul></li></ul><h3 id="认识SQL语句"><a href="#认识SQL语句" class="headerlink" title="认识SQL语句"></a>认识SQL语句</h3><ul><li>我们希望操作数据库(特别是在程序中操作), 就需要又和数据库沟通的语言, 这个语言就是SQL<ul><li>SQL是Structured Query Language, 称之为结构化查询语言, 简称SQL</li><li>使用SQL编写出来的语句, 就成为SQL语句</li><li>SQL语句可以用于对数据库进行操作</li></ul></li><li>事实上, 常见的关系型数据库SQL语句都是比较相似的, 所以学习了MySQL中的SQL语句, 之后去操作其他关系型数据库也是非常简单的</li><li>SQL语句的常用规范<ul><li>通常关键字是大写的, 比如CREATE, TABLE, SHOW等等</li><li>一条语句结束后, 需要以分号; 结尾, 否则语句不会结束</li><li>如果遇到关键字作为表明或者字段名称, 可以使用反引号 `` 包裹</li></ul></li></ul><h3 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h3><ul><li>常见的SQL语句我们可以分成四类</li><li>DDL(Data Definition Language): 数据定义语言;<ul><li>可以通过DDL语句对数据库或者表进行</li></ul></li><li>DML(Data Manipulation Language): 数据操作语言<ul><li>可以通过DML语句对表进行: 添加, 删除, 修改等操作</li></ul></li><li>DQL(Data Query Language): 数据查询语言<ul><li>可以通过DQL从数据中查询记录;(重点)</li></ul></li><li>DCL(Data Control Language): 数据控制语言<ul><li>对数据库, 表格的权限进行相关访问控制操作</li></ul></li></ul><h3 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h3><ul><li>查看当前数据库<ul><li>查看所有的数据: SHOW DATABASES;</li><li>使用某一个数据: USE 数据库名称;</li><li>查看当前正在使用的数据库: SELECT DATABASE();</li></ul></li><li>创建新的数据库<ul><li>创建数据库: CREATE DATABASE 数据库名称;</li><li>一般来说我们不会以上面的方式创建数据库, 因为如果已经存在了同名的数据库, 会报错, 甚至程序崩溃</li><li>一般用更加严谨的方式创建: CREATE DATABASE IF NOT EXISTS 数据库名称;</li><li>如果想要创建数据库的同时设置数据库的字符集和排序规则: CREATE DATABASE IF NOT EXISTS 数据库名称 DEFAULT CHARACTER SET 字符集 COLLATE 排序规则;</li><li>注: 排序规则指, 如果在数据库查询的时候, 排序规则规定了查询结果的显示顺序, ai和as指是否区分英文轻重音, ai指不区分; ci和cs指是否区分英文大小写, ci指不区分; 一般使用默认即可</li></ul></li><li>删除数据库<ul><li>删除数据库: DROP DATABASE 数据库名称;</li><li>更加严谨的写法: DROP DATABASE IF EXISTS 数据库名称;</li></ul></li><li>修改数据库(一般只修改数据库的字符集和排序规则)<ul><li>ALTER DATABASE 数据库名称 CHARACTER SET = 字符集 COLLATE = 排序规则;</li></ul></li></ul><h3 id="SQL的数据类型-数字类型"><a href="#SQL的数据类型-数字类型" class="headerlink" title="SQL的数据类型-数字类型"></a>SQL的数据类型-数字类型</h3><ul><li>我们知道不同的数据会划分不同的数据类型, 在数据库中也是一样的<ul><li>MySQL支持的数据类型又: 数字类型, 日期和时间类型, 字符串(字符和字节)类型, 空间类型(存储一个点的坐标, 经度纬度的时候会使用, 一般不会使用)和JSON数据类型(一般不会将一个JSON对象存储在数据库中, 不常用)</li></ul></li><li>数字类型<ul><li>MySQL的数字类型有很多</li><li>整数数字类型: INTEGER, INT(最常用), SMALLINT, TINYINT, MEDLUMINT, BIGINT</li><li>浮点数字类型: FLOAT, DOUBLE(常用), FLOAT是四个字节, 而DOUBLE是八个字节</li><li>精确数字类型: DECIMAL, NUMERIC(DECIMAL是NUMERIC的实现形式), 这两个的使用方法和作用基本一样, 一般常用DECIMAL, 使用方法为传入两个参数, 第一个参数表示数字的长度, 第二个参数为保存的小数个数</li></ul></li></ul><h3 id="SQL的数据类型-日期类型"><a href="#SQL的数据类型-日期类型" class="headerlink" title="SQL的数据类型-日期类型"></a>SQL的数据类型-日期类型</h3><ul><li>MySQL的日期类型也很多</li><li>YEAR以YYY格式显示值<ul><li>范围1901到2155, 和0000</li></ul></li><li>DATE类型用于具有日期部分但是没有时间部分的值<ul><li>DATE以格式YYYY-MM-DD显示值</li><li>支持的范围是’1000-01-01’到’9999-12-31’</li></ul></li><li>DATETIME类型用于包含日期和时间部分的值<ul><li>DATETIME以格式’YYYY-MM-DD hh:mm:ss’显示值</li><li>支持的范围是1000-01-01 00:00:00到9999-12-31 23:59:59</li></ul></li><li>TIMESTAMP数据类型被用于同时包含日期和时间部分的值(一般用这个)<ul><li>TIMESTAMP以格式’YYYY-MM-DD hh:mm:ss’显示值；</li><li>但是它的范围是UTC的时间范围：’1970-01-01 00:00:01’到’2038-01-19 03:14:07’</li><li>与DATETIME的区别只是范围不一样</li></ul></li><li>另外：DATETIME或TIMESTAMP 值可以包括在高达微秒（6位）精度的后小数秒一部分<ul><li>比如DATETIME表示的范围可以是’1000-01-01 00:00:00.000000’到’9999-12-31 23:59:59.999999’</li></ul></li></ul><h3 id="SQL的数据类型-字符串类型"><a href="#SQL的数据类型-字符串类型" class="headerlink" title="SQL的数据类型-字符串类型"></a>SQL的数据类型-字符串类型</h3><ul><li>MySQL的字符串类型表示方式如下</li><li>CHAR类型在创建表时为固定长度, 长度看也是0到255之间的任何值<ul><li>在被查询时, 会删除后面的空格</li></ul></li><li>VARCHAR类型的值是可变长度的字符串, 长度可以指定为0到65535之间的值<ul><li>在被查询时, 不会删除后面的空格</li><li>一般使用VARCHAR这个类型</li></ul></li><li>BINARY和VARBINARY类型用于存储二进制字符串, 存储的时字节字符串;<ul><li>一般来说不会将二进制的数据(比如图片数据)存储在数据库中, 一般时将这种数据存储在文件系统中, 然后根据文件系统的存储位置URL存储在数据库中</li></ul></li><li>BLOB用于存储大的二进制类型</li><li>TEXT用于存储大的字符串类型</li></ul><h3 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h3><ul><li>主键: PRIMARY KEY<ul><li>一张表中, 为了区分每一条记录的唯一性, 必须有一个字段时永远不会重复, 而且不能为空的, 这个字段我们通常会将其设置为主键</li><li>主键时表中唯一的所以</li><li>而且必须时NOT NULL的, 如果没有设置NOT NULL, 那么MySQL也会隐式地设置为NOT NULL</li><li>主键也可以多列索引, PRIMARY KEY(key…pary, …) 我们一般称之为联合主键</li><li>建议: 在开发中主键字段一个和业务无关, 尽量不要使用业务字段来作为主键</li></ul></li><li>唯一: UNIQUE<ul><li>某些字段在开发中我们希望是唯一地, 不会重复地, 比如手机号码, 身份证号码等, 这些字段我们可以使用UNIQUE来约束</li><li>使用UNIQUE约束地字段在表中必须是不同的</li><li>对于所有引擎, UNIQUE索引允许NULL包含的列具有多个NULL值</li></ul></li><li>不能为控: NOT NULL<ul><li>某些字段我们要求用户必须插入值, 不可以为空, 这个时候我们可以使用NOT NULL来约束</li></ul></li><li>默认值: DEFAULT<ul><li>某些字段我们希望在没有设置时给予一个默认值, 这个时候我们可以使用DEFAULT来完成</li></ul></li><li>自动递增: AUTO_INCREMENT<ul><li>某些字段我们希望不设置值的时候可以进行递增, 比如用户的ID, 这个时候可以使用AUTO_INCREMENT来完成</li></ul></li><li>外键约束也是最常用的一种约束手段</li></ul><h3 id="创建一个完整的表"><a href="#创建一个完整的表" class="headerlink" title="创建一个完整的表"></a>创建一个完整的表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` &#123;</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  age <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  telPhone <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  createTime <span class="type">TIMESTAMP</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;</span><br><span class="line"><span class="comment">-- 更加严谨的写法</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> users;</span><br></pre></td></tr></table></figure><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users RENAME <span class="keyword">TO</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"># 添加一个新的列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> updateTime <span class="type">TIMESTAMP</span>;</span><br><span class="line"></span><br><span class="line"># 修改字段的名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> CHANEG phoneNum telePhone <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 修改字段的类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> MODIFY name <span class="type">VARCHAR</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"># 删除某一个字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">DROP</span> age;</span><br><span class="line"></span><br><span class="line"># 补充</span><br><span class="line"># 根据一个表结构去创建另外一个表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user1 <span class="keyword">LIKE</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"># 根据一个表中的所有内容去创建另外一个表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user2 (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>);</span><br><span class="line"></span><br><span class="line"># 注意以上两种创建表的方式不会包含主键等的设置</span><br></pre></td></tr></table></figure><h3 id="DML-数据操作语句"><a href="#DML-数据操作语句" class="headerlink" title="DML 数据操作语句"></a>DML 数据操作语句</h3><ul><li>DML: Date Manipulation Language (数据操作语句)</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 插入数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> <span class="keyword">VALUES</span> (按照数据项传入的数据);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (需要填入的数据项) <span class="keyword">VALUES</span> (按照顺序插入的顺序);</span><br><span class="line"></span><br><span class="line"># 需求: 在插入日期数据的时候, 数据库可以按照当前时间插入默认值</span><br><span class="line"># <span class="keyword">DEFAULT</span> 指在添加数据的时候会自动设置默认值</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> MODIFY createTime <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">ON</span> UPDATE 指在数据更新的时候会自动设置当前时间</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> MODIFY updateTime <span class="type">TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"></span><br><span class="line"># 如果想要既在添加数据的时候设置默认值, 并且在更新数据的时候也会更新当前时间, 则如下设置</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> MODIFY updateTime <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除数据</span><br><span class="line"># 删除所有的数据(一般来说不会这样操作)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br><span class="line"># 删除符合条件的数据</span><br><span class="line"><span class="keyword">DELETE</span> FORM <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line"># 更新所有的数据(一般来说不会这样操作)</span><br><span class="line">UPDATE <span class="keyword">user</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;lily&#x27;</span>, telePhone <span class="operator">=</span> <span class="string">&#x27;1011121&#x27;</span>;</span><br><span class="line"># 更新符合条件的数据</span><br><span class="line">UPDATE <span class="keyword">user</span> <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;lily&#x27;</span>, telePhone <span class="operator">=</span> <span class="string">&#x27;1011121&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure><h3 id="DQL查询操作语句"><a href="#DQL查询操作语句" class="headerlink" title="DQL查询操作语句"></a>DQL查询操作语句</h3><ul><li>DQL: Data Query Language(数据查询语言)<ul><li>SELECT用于从一个或者多个表中检索选中的行(Record)</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>基本的查询操作</span><br><span class="line"># 查询表中所有字段以及所有的数据</span><br><span class="line"># <span class="operator">*</span> 号表示通配符, 选择所有字段</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products;</span><br><span class="line"># 查询特定字段的数据</span><br><span class="line"><span class="keyword">SELECT</span> title, price <span class="keyword">FROM</span> products;</span><br><span class="line"># 对字段结果起别名</span><br><span class="line"># <span class="keyword">AS</span> 后面跟想要起的别名</span><br><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">AS</span> phoneTitle, price <span class="keyword">AS</span> currentPrice <span class="keyword">FROM</span> procucts;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> <span class="keyword">WHERE</span>条件</span><br><span class="line"># <span class="number">2.1</span> 条件判断语句</span><br><span class="line"># 案例: 查询价格小于<span class="number">1000</span>的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&lt;</span> <span class="number">1000</span>;</span><br><span class="line"># 案例二: 价格等于<span class="number">999</span>的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">=</span> <span class="number">999</span>;</span><br><span class="line"># 案例三: 价格不等于<span class="number">999</span>的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">!=</span> <span class="number">999</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&lt;&gt;</span> <span class="number">999</span>;</span><br><span class="line"># 案例四: 查询品牌是华为的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.2</span> 逻辑运算语句</span><br><span class="line"># 案例一: 查询价格<span class="number">1000</span>到<span class="number">2000</span>之间的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">1000</span> <span class="keyword">AND</span> price <span class="operator">&lt;</span> <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">1000</span> <span class="operator">&amp;&amp;</span> price <span class="operator">&lt;</span> <span class="number">2000</span>;</span><br><span class="line"># 注意使用 <span class="keyword">BETWEEN</span> <span class="keyword">AND</span> 关键字是包含等于的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="keyword">BETWEEN</span> <span class="number">1000</span> <span class="keyword">AND</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"># 案例二: 查询价格在<span class="number">5000</span>以上或者品牌是华为的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">5000</span> <span class="keyword">OR</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> price <span class="operator">&gt;</span> <span class="number">5000</span> <span class="operator">||</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查询url值为<span class="keyword">NULL</span>的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> url <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"># 查询url值不为<span class="keyword">NULL</span>的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> url <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.3</span>. 模糊查询</span><br><span class="line"># <span class="operator">%</span> 百分号表示匹配任意个的任意字符；</span><br><span class="line"># _ 下划线表示匹配一个的任意字符</span><br><span class="line"># 查询title中有M的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;%M%&#x27;</span>;</span><br><span class="line"># 查询title中第二个字符为P的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;_P%&#x27;</span>;</span><br><span class="line"># 查询title中第三个字符为P的数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;__P%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.4</span>. <span class="keyword">IN</span>表示取多个值中的其中一个即可</span><br><span class="line"># 查询品牌为华为或者小米或者苹果的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span> <span class="operator">||</span> brand <span class="operator">=</span> <span class="string">&#x27;小米&#x27;</span> <span class="operator">||</span> brand <span class="operator">=</span> <span class="string">&#x27;苹果&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="keyword">IN</span> (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> 对结果进行排序</span><br><span class="line"># 使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 关键字, <span class="keyword">ASC</span> 表示升序, <span class="keyword">DESC</span>表示降序</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="keyword">IN</span> (<span class="string">&#x27;华为&#x27;</span>, <span class="string">&#x27;小米&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span>, score <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 分页查询</span><br><span class="line"># 使用LIMIT关键字, 表示获取多少条, <span class="keyword">OFFSET</span>关键字, 表示从哪一条开始获取</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products LIMIT <span class="number">20</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"># 另外一种写法, LIMIT <span class="keyword">offset</span>, limit;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products LIMIT <span class="number">0</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>什么是聚合函数<ul><li>聚合函数指的是, 将一张表作为一组数据, 当我们想对这一组数据进行某些操作(比如求和, 求平均值, 求最大最小值)的时候所使用的方法就是聚合函数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1.</span>聚合函数的使用</span><br><span class="line"># <span class="number">1.1</span> 求所有手机的价格总和</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(price) <span class="keyword">FROM</span> products;</span><br><span class="line"># 当然也可以给结果取别名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(price) <span class="keyword">AS</span> totalPrice <span class="keyword">FROM</span> products;</span><br><span class="line"># 求符合特定条件的数据的手机价格总和</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(price) <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"># 求华为手机的平均价格</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(price) <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"># 求手机的最高和最低价格</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(price) <span class="keyword">FROM</span> products;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(price) <span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"># 求手机的个数</span><br><span class="line"># <span class="operator">*</span> 号通配符, 表示所有的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> products;</span><br><span class="line"># 求品牌为华为的所有手机的个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br><span class="line"># 求具有url的手机个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(url) <span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"># 求具有price的手机的个数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(price) <span class="keyword">FROM</span> products;</span><br><span class="line"># 如果想要去重则使用关键字<span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> price) <span class="keyword">FROM</span> products;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span><span class="keyword">GROUP</span> <span class="keyword">BY</span>的使用</span><br><span class="line"># <span class="keyword">GROUP</span> <span class="keyword">BY</span>的作用是分组</span><br><span class="line"># 将所有手机按照品牌分组</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> brand;</span><br><span class="line"># 将所有手机的平均值和数量和平均分按照品牌分组</span><br><span class="line"><span class="keyword">SELECT</span> brand, <span class="built_in">AVG</span>(price), <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="built_in">AVG</span>(score) <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> brand;</span><br><span class="line"># <span class="keyword">HAVING</span>的使用</span><br><span class="line"><span class="keyword">SELECT</span> brand, <span class="built_in">AVG</span>(price) avgPrice, <span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="built_in">AVG</span>(score) <span class="keyword">FROM</span> products <span class="keyword">GROUP</span> <span class="keyword">BY</span> brand <span class="keyword">HAVING</span> avgPrice <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span>需求: 求评分score <span class="operator">&gt;</span> <span class="number">7.5</span> 的手机的, 平均价格是多少</span><br><span class="line"><span class="keyword">SELECT</span> brand, <span class="built_in">AVG</span>(price) <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> score <span class="operator">&gt;</span> <span class="number">7.5</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> brand;</span><br></pre></td></tr></table></figure><h3 id="多表的设计"><a href="#多表的设计" class="headerlink" title="多表的设计"></a>多表的设计</h3><ul><li>假如我们的上面的商品表中, 对应的品牌还需要包含其他的信息<ul><li>比如品牌的官网, 品牌的世界排名, 品牌的市值等等</li></ul></li><li>如果我们直接在商品中添加一个字段取存储品牌相关的信息, 会存在一些问题<ul><li>一方面, products表中应该表示的都是商品相关的数据, 应该有另外的一张表取表示brand的数据</li><li>另一方面, 多个商品使用的品牌是一致的时候, 会存在大量的冗余数据</li></ul></li><li>所以, 我们可以将所有的批评数据, 单独放到一张表中, 然后通过外键将两张表关联在一起</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 给products添加一个brand_id字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products <span class="keyword">ADD</span> brand_id <span class="type">INT</span>;</span><br><span class="line"></span><br><span class="line"># 设置外键限制: 外键限制指的是限制值只能为引用的值</span><br><span class="line"># 修改products的brand_id的字段外键为brand中的id</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(brand_id) <span class="keyword">REFERENCES</span> brand(id);</span><br><span class="line"></span><br><span class="line"># 设置brand_id的值</span><br><span class="line">UPDATE products <span class="keyword">SET</span> brand_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> brand <span class="operator">=</span> <span class="string">&#x27;华为&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="外键存在的时候更新和删除数据"><a href="#外键存在的时候更新和删除数据" class="headerlink" title="外键存在的时候更新和删除数据"></a>外键存在的时候更新和删除数据</h3><ul><li>我们来思考一个问题<ul><li>如果products中引用的外键被更新了或者删除了, 此时会出现什么情况呢?</li></ul></li><li>使用SQL语句进行一个更新操作<ul><li>UPDATE brand SET id = 100 WHERE id = 1;</li></ul></li><li>执行代码会报错<ul><li>这是因为外键有默认的action设置为了RESTRICT, 此时就不可以更新和删除关联的外键</li></ul></li></ul><h3 id="如何进行更新呢"><a href="#如何进行更新呢" class="headerlink" title="如何进行更新呢?"></a>如何进行更新呢?</h3><ul><li>如果我们希望可以更新和删除关联的外键, 我们需要修改on delete 或者 on update的值</li><li>我们可以给更新或者删除时设置几个值<ul><li>RESTRIC(默认属性): 当更新或者删除某个关联外键的时候, 会检查该记录是否有关联的外键记录, 有的话就会报错, 不允许更新或者删除</li><li>NO ACTION: 和RESTRIC是一致的, 在SQL标准中定义的</li><li>CASCADE: 当更新或者删除某个记录的时候, 会检查该记录是否有关联的外键记录, 有的话:<ul><li>更新: 会更新对应的记录</li><li>删除: 会将关联的记录一起删除(一般来说删除的时候不会设置为CASCADE值,)</li></ul></li><li>SET NULL: 当更新或者删除某个记录的时候, 会检查该记录是否有关联的外键记录, 有的话, 将对应的值设置为NULL</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3.</span>修改和删除外键引用的id</span><br><span class="line"># 不可以直接修改和删除被引用的外键</span><br><span class="line">UPDATE brand <span class="keyword">SET</span> id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> brand <span class="keyword">DROP</span> id;</span><br><span class="line"># 原因是因为关联外键的action被设置为RESTRICT, 此时是不可以修改和删除被引用的外键的</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span>修改关联外键的action</span><br><span class="line"># 要经过三步才可以修改, 本质是先删除原本的外键, 然后在重新设置外键的时候设置对应的action</span><br><span class="line"># <span class="number">4.1</span> 获取到目前的外键的名称</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- CREATE TABLE `products` (</span></span><br><span class="line"><span class="comment">--   `id` int NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="comment">--   `brand` varchar(20) DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   `title` varchar(100) NOT NULL,</span></span><br><span class="line"><span class="comment">--   `price` double NOT NULL,</span></span><br><span class="line"><span class="comment">--   `score` decimal(2,1) DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   `voteCnt` int DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   `url` varchar(100) DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   `pid` int DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   `brand_id` int DEFAULT NULL,</span></span><br><span class="line"><span class="comment">--   PRIMARY KEY (`id`),</span></span><br><span class="line"><span class="comment">--   KEY `brand_id` (`brand_id`),</span></span><br><span class="line"><span class="comment">--   CONSTRAINT `products_ibfk_1` FOREIGN KEY (`brand_id`) REFERENCES `brand` (`id`)</span></span><br><span class="line"><span class="comment">-- ) ENGINE=InnoDB AUTO_INCREMENT=109 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4.2</span> 根据获取到的外键的名称删除外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY products_ibfk_1;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.3</span> 重新添加外键的同时设置对应的action</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> products <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (brand_id) <span class="keyword">REFERENCES</span> brand(id) <span class="keyword">ON</span> UPDATE CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT;</span><br><span class="line"></span><br><span class="line"># 此时修改关联的外键就可以正常修改了</span><br><span class="line">UPDATE brand <span class="keyword">SET</span> id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>什么是多表查询<ul><li>如果我们希望查询到产品的同时, 显示对应的品牌相关的信息, 因为数据是存放在两张表中的, 所以这个时候就需要进行多表查询</li></ul></li><li>如果我们直接通过查询语句希望在多张表中查询到数据, 使用下列SQL语句会产生什么效果呢?<ul><li>SELECT * FROM products, brand;</li></ul></li><li>会发现结果的数量为两张表数据数量的乘积</li><li>这个结果我们称为笛卡尔乘积, 也称为直积, 表示为X*YEAR以YYY格式显示值</li><li>但是事实上很多的数据是没有意义的, 所以我们要对笛卡尔乘积进行筛选<ul><li>使用WHERE进行筛选</li><li>使用SQL语句: SELECT * FROM products, brand WHERE products.brand_id = brand.id;</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 多表查询的方法</span><br><span class="line"># <span class="number">1.</span> 先获取到笛卡尔乘积</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products, brand;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 对笛卡尔乘积进行筛选</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products, brand <span class="keyword">WHERE</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"></span><br><span class="line"># 以上方法本质上是将所有的结果都查询出来然后进行了筛选, 一般来说我们不会这样取操作的</span><br></pre></td></tr></table></figure><h3 id="多表之间的连接"><a href="#多表之间的连接" class="headerlink" title="多表之间的连接"></a>多表之间的连接</h3><ul><li>事实上想要达到上面所说的效果, 并不是像上面的方式操作的, 而是使用SQL JOIN操作</li><li>左连接<ul><li>如果我们希望获取到的是左边所有的数据(以左表为主)<ul><li>这个时候就表示无论左边的表是否有对应的brand_id的值对应右边表的id, 左边的数据都会被查询出来</li><li>这个也是开发中使用最多的情况, 它的完整写法是 LEFT [OUTER] JOIN, 其中的OUTER可以省略</li></ul></li></ul></li><li>右连接<ul><li>如果我们希望获取到的是右边所有的数据(以右表为主)<ul><li>这个时候就表示无论左边的表中的brand_id是否有和右边表中的id对应, 右边的数据都会被查询出来</li><li>右连接在开发中没有左连接常用, 它的完整写法是 RIGHT [OUTER] JOIN,其中的OUTER可以省略</li></ul></li></ul></li><li>内连接<ul><li>事实上内连接表示左边的表和右边的表都有对应的数据关联<ul><li>内连接在开发中偶尔也会常见使用</li><li>内连接有其他的写法: INNER JOIN , CROSS JOIN 或者 JOIN都可以</li></ul></li></ul></li><li>外连接<ul><li>SQL规范中全连接是使用FULL JOIN, 但是MySQL中并没有对它支持, 所以我们是使用UNION来实现全连接的</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">3.</span> 左连接</span><br><span class="line"># <span class="number">3.1</span> 查询所有的手机(包括没有品牌信息的手机)以及对应的品牌</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.2</span> 查询没有对应品牌信息的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id <span class="keyword">WHERE</span> brand.id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 右连接</span><br><span class="line"># <span class="number">4.1</span> 查询所有品牌(包括没有手机信息的品牌)以及对应的手机</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"></span><br><span class="line"># <span class="number">4.2</span> 查询没有对应手机信息的品牌</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id <span class="keyword">WHERE</span> products.brand_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> 内连接</span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 和 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 都是一样的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">INNER</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"></span><br><span class="line"># <span class="number">6.</span> 全连接</span><br><span class="line"># mySQL中是不支持 <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> 的</span><br><span class="line"># 所以我们需要将左连接和右连接通过 <span class="keyword">UNION</span> 做一个联合</span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id <span class="keyword">WHERE</span> brand.id <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> products <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id <span class="keyword">WHERE</span> products.brand_id <span class="keyword">IS</span> <span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="多对多关系数据"><a href="#多对多关系数据" class="headerlink" title="多对多关系数据"></a>多对多关系数据</h3><ul><li>在开发中我们会经常遇到多对多的关系<ul><li>比如学生可以选择多门课程, 一个课程也可以被多个学生选择</li><li>这种情况我们就会使用多对多关系的数据</li></ul></li><li>多对多数据表关键点是有一个关系表来记录两张表中的数据关系</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建两张表并插入数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> students (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> courses (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">price <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 插入学生数据以及课程数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students` (name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;why&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students` (name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students` (name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;lilei&#x27;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students` (name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `students` (name, age) <span class="keyword">VALUES</span>(<span class="string">&#x27;lily&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;英语&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;语文&#x27;</span>, <span class="number">666</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;数学&#x27;</span>, <span class="number">888</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;历史&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;物理&#x27;</span>, <span class="number">888</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `courses` (name, price) <span class="keyword">VALUES</span> (<span class="string">&#x27;地理&#x27;</span>, <span class="number">333</span>);</span><br><span class="line"></span><br><span class="line"># 创建关系表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> stuendts_select_courses (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">students_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">courses_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (students_id) <span class="keyword">REFERENCES</span> students(id) <span class="keyword">ON</span> UPDATE CASCADE,</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (courses_id) <span class="keyword">REFERENCES</span> courses(id) <span class="keyword">ON</span> UPDATE CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 学生选课</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students_select_courses (students_id, courses_id) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"># 查询所有有选课的学生, 以及这些学生选择的课程</span><br><span class="line"><span class="keyword">SELECT</span> stu.id id, stu.name studentName, stu.age studentAge, cs.id coursesId, cs.name coursesName, cs.price coursesPrice  </span><br><span class="line"><span class="keyword">FROM</span> students stu </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> ssc.students_id <span class="operator">=</span> stu.id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> courses cs <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id; </span><br><span class="line"></span><br><span class="line"># 查询所有学生的选课情况</span><br><span class="line"><span class="keyword">SELECT</span> stu.id id, stu.name studentName, stu.age studengAge, cs.id coursesId, cs.name coursesName, cs.price coursesPrice</span><br><span class="line"><span class="keyword">FROM</span> students stu</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> ssc.students_id <span class="operator">=</span> stu.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses cs <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id;</span><br><span class="line"></span><br><span class="line"># 查询哪些学生是没有选课的</span><br><span class="line"><span class="keyword">SELECT</span> stu.id id, stu.name studentName, stu.age studengAge, cs.id coursesId, cs.name coursesName, cs.price coursesPrice</span><br><span class="line"><span class="keyword">FROM</span> students stu</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> ssc.students_id <span class="operator">=</span> stu.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses cs <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id</span><br><span class="line"><span class="keyword">WHERE</span> ssc.courses_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 查询哪些课程是没有被选择的</span><br><span class="line"><span class="keyword">SELECT</span> stu.id id, stu.name studentName, stu.age studengAge, cs.id coursesId, cs.name coursesName, cs.price coursesPrice</span><br><span class="line"><span class="keyword">FROM</span> courses cs</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students stu <span class="keyword">ON</span> ssc.students_id <span class="operator">=</span> stu.id</span><br><span class="line"><span class="keyword">WHERE</span> ssc.students_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"># 查询某一个学生选择了哪些课程</span><br><span class="line"># 比如查询why id为<span class="number">1</span> 学生的选课情况</span><br><span class="line"><span class="keyword">SELECT</span> stu.id id, stu.name studentName, stu.age studengAge, cs.id coursesId, cs.name coursesName, cs.price coursesPrice</span><br><span class="line"><span class="keyword">FROM</span> students stu</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> ssc.students_id <span class="operator">=</span> stu.id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> courses cs <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id</span><br><span class="line"><span class="keyword">WHERE</span> stu.id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="将数据转换成对象-一对多"><a href="#将数据转换成对象-一对多" class="headerlink" title="将数据转换成对象(一对多)"></a>将数据转换成对象(一对多)</h3><ul><li>在真实开发中, 我们经常会将数据打包到一个对象中然后传输给客户端</li><li>这个时候我们就要用到JSON_OBJECT();</li></ul><h3 id="将多条数据组织成对象然后放到一个数组中-多对多"><a href="#将多条数据组织成对象然后放到一个数组中-多对多" class="headerlink" title="将多条数据组织成对象然后放到一个数组中(多对多)"></a>将多条数据组织成对象然后放到一个数组中(多对多)</h3><ul><li>在多对多关系中, 我们希望擦好像到的是一个数组</li><li>这个时候我们要用JSON_ARRAYAGG和JSON_OBJECT结合来使用</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 将联合查询到的数据转换成对象(一对多)</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">products.id id, products.title title, products.price price, products.score score, products.url url,</span><br><span class="line"><span class="built_in">JSON_OBJECT</span>(<span class="string">&#x27;id&#x27;</span>, brand.id, <span class="string">&#x27;name&#x27;</span>, brand.name, <span class="string">&#x27;website&#x27;</span>, brand.website, <span class="string">&#x27;phoneRank&#x27;</span>, brand.phoneRank) brand</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> brand <span class="keyword">ON</span> products.brand_id <span class="operator">=</span> brand.id;</span><br><span class="line"></span><br><span class="line"># 将查询到的多条数据, 组织成对象, 放到一个数组中(多对多)</span><br><span class="line"># 首先要将查询到的学生数据按照学生id分组</span><br><span class="line"># 通过<span class="built_in">JSON_OBJECT</span>()方法将数据转换为对象</span><br><span class="line"># 然后通过<span class="built_in">JSON_ARRAYAGG</span>()将对象存放到数组中</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">stu.id id, stu.name name, stu.age age,</span><br><span class="line"><span class="built_in">JSON_ARRAYAGG</span>(<span class="built_in">JSON_OBJECT</span>(<span class="string">&#x27;id&#x27;</span>, cs.id, <span class="string">&#x27;name&#x27;</span>, cs.name, <span class="string">&#x27;price&#x27;</span>, cs.price)) courses</span><br><span class="line"><span class="keyword">FROM</span> students stu</span><br><span class="line"><span class="keyword">JOIN</span> students_select_courses ssc <span class="keyword">ON</span> stu.id <span class="operator">=</span> ssc.students_id</span><br><span class="line"><span class="keyword">JOIN</span> courses cs <span class="keyword">ON</span> ssc.courses_id <span class="operator">=</span> cs.id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-Node中express和koa框架对比</title>
      <link href="2021/05/26/10-Node%E4%B8%ADexpress%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/"/>
      <url>2021/05/26/10-Node%E4%B8%ADexpress%E5%92%8Ckoa%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h3 id="koa和express的对比"><a href="#koa和express的对比" class="headerlink" title="koa和express的对比"></a>koa和express的对比</h3><ul><li>从架构设计上来说<ul><li>express是完整的强大的, 其帮助我们内置了很多好用的功能</li><li>koa是简洁的自由的, 只包含最核心的功能, 并不会对我们使用其他中间件进行任何的闲置<ul><li>甚至是app中最基本的get、post方法过滤都没有提供</li><li>我们需要通过自己或者路由来判断请求方式或者使用第三方库来实现其他功能</li></ul></li></ul></li><li>因为express和koa框架它们的核心其实是中间件<ul><li>但是它们的中间件的执行机制是不一样的， 特别是针对某一个中间件包含异步操作的时候</li></ul></li><li>express中执行中间件只使用了简单的函数来执行中间件</li><li>而koa中执行中间件利用了promise对象来实现的</li><li>所以koa中可以使用async await来处理中间件中的异步操作， 而express中不能</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> express </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-Node的Koa框架</title>
      <link href="2021/05/26/09-Node%E7%9A%84Koa%E6%A1%86%E6%9E%B6/"/>
      <url>2021/05/26/09-Node%E7%9A%84Koa%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="认识koa"><a href="#认识koa" class="headerlink" title="认识koa"></a>认识koa</h3><ul><li>前面我们已经学习了expresss, 另外一个非常流行的Node Web服务器框架就是koa</li><li>koa官方的介绍<ul><li>koa: next generation web framework for node.js</li><li>koa: node.js的下一代web框架</li></ul></li><li>事实上, koa是express同一个团队开发的一个新的Web框架<ul><li>目前团队的核心开发中TJ的主要精力也在维护Koa, express已经交给团队维护了</li><li>koa旨在为Web应用程序和API提供更小, 更丰富和更强大的能力</li><li>相对于express具有更强的异步处理能力</li><li>koa的核心代码只有1600+行, 是一个更加轻量级的框架, 我们可以根据需要安装和使用中间件</li></ul></li></ul><h3 id="Koa初体验"><a href="#Koa初体验" class="headerlink" title="Koa初体验"></a>Koa初体验</h3><ul><li>koa注册中间件提供了两个参数</li><li>ctx: 上下文(context)对象<ul><li>koa并没有像express一样, 将req和res分开, 而是将它们作为ctx的属性</li><li>ctx代表一次请求的上下文对象</li><li>ctx.request: 获取请求对象</li><li>ctx.response: 获取响应对象</li></ul></li><li>next: 本质是一个dispatch, 类似于express的next</li></ul><h3 id="koa中间件"><a href="#koa中间件" class="headerlink" title="koa中间件"></a>koa中间件</h3><ul><li>koa通过创建的app对象, 注册中间件只能通过use方法<ul><li>koa并没有提供method的方式来创建中间件</li><li>也灭有提供path中间件来匹配路径</li><li>也不可以通过连续注册的方式来注册中间件</li></ul></li><li>如果真实开发中需要实现将路径path和method分离<ul><li>方式一: 根据 ctx.request.path 和 ctx.request.method 用if判断来实现</li><li>方式二: 使用第三方路由中间件</li></ul></li></ul><h3 id="koa第三方路由的使用"><a href="#koa第三方路由的使用" class="headerlink" title="koa第三方路由的使用"></a>koa第三方路由的使用</h3><ul><li>koa官方并没有给我们提供路由的库, 我们可以选择第三方库: koa-router<ul><li>npm install koa-router</li></ul></li><li>先封装一个 user.router.js的文件</li><li>在app中将router.routes() 注册为中间件</li><li>注意: allowedMethods用于判断某一个method是否支持<ul><li>如果我们请求正常的请求, 将正常返回数据</li><li>如果请求put, deletd, patch没有的请求, 则会报错 Method Not Allowed; 状态码: 405</li><li>如果请求link, copy, lock没有的请求, 则会报错 Not Implemented; 状态码: 501</li></ul></li></ul><h3 id="参数解析-parmas和query"><a href="#参数解析-parmas和query" class="headerlink" title="参数解析: parmas和query"></a>参数解析: parmas和query</h3><ul><li>koa本身没有解析url的功能</li><li>可以利用 koa-router第三方库 来实现</li></ul><h3 id="参数解析-json和urlencoded"><a href="#参数解析-json和urlencoded" class="headerlink" title="参数解析: json和urlencoded"></a>参数解析: json和urlencoded</h3><ul><li>koa本身没有解析json和urlencoded的功能</li><li>可以利用koa-bodyparser来实现解析body的功能</li></ul><h3 id="参数解析-form-data"><a href="#参数解析-form-data" class="headerlink" title="参数解析: form-data"></a>参数解析: form-data</h3><ul><li>koa本身没有解析 form-data的功能</li><li>可以利用koa-multer来实现</li></ul><h3 id="图片文件的上传"><a href="#图片文件的上传" class="headerlink" title="图片文件的上传"></a>图片文件的上传</h3><ul><li>利用koa-multer来实现</li></ul><h3 id="koa中数据的响应"><a href="#koa中数据的响应" class="headerlink" title="koa中数据的响应"></a>koa中数据的响应</h3><ul><li>输出结果: body将响应主体设置为以下之一<ul><li>string: 字符串数据</li><li>Buffer: Buffer数据</li><li>Stream: 流数据</li><li>Object/ Array: 对象或者数组(会自动转换为JSON格式)</li><li>null: 不输出任何内容</li><li>如果response.status尚未设置, Koa会自动将状态设置未200或者204</li></ul></li><li>注意, ctx.response.body 和 ctx.body 可以达到相同的效果<ul><li>原因是, 本质上ctx.body 会调用 ctx.response.body, 只是做了一层代理</li></ul></li></ul><h3 id="koa中的错误处理方式"><a href="#koa中的错误处理方式" class="headerlink" title="koa中的错误处理方式"></a>koa中的错误处理方式</h3><ul><li>koa中的错误处理是通过 ctx.app.emit(“error”, new Error(), ctx) 发送错误事件来实现的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER_DOSE_NOT_LOGIN = <span class="string">&quot;user does not login&quot;</span>;</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (!isLogin) &#123;</span><br><span class="line">    <span class="comment">// 通过发送错误信息事件的方式处理错误</span></span><br><span class="line">    ctx.app.emit(<span class="string">&quot;error&quot;</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(USER_DOSE_NOT_LOGIN), ctx);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;登陆成功&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里监听错误事件</span></span><br><span class="line">app.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err, ctx</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> errMessage = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> errStatus = <span class="number">400</span>;</span><br><span class="line">  <span class="keyword">switch</span> (err.message) &#123;</span><br><span class="line">    <span class="keyword">case</span> USER_DOSE_NOT_LOGIN:</span><br><span class="line">      errMessage = err.message;</span><br><span class="line">      errStatus = <span class="number">401</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      errMessage = <span class="string">&quot;NOT FOUND&quot;</span></span><br><span class="line">      errStatus = <span class="number">404</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.body = errMessage;</span><br><span class="line">  ctx.status = errStatus;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;错误处理服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="koa洋葱模型"><a href="#koa洋葱模型" class="headerlink" title="koa洋葱模型"></a>koa洋葱模型</h3><ul><li>两层理解含义<ul><li>中间件处理代码的过程</li><li>Response返回body执行</li></ul></li><li>也就是koa执行中间件的过程是从第一个中间件开始执行到最后一个中间件, 遇到next() 就执行下一个中间件的代码, 在最后一个中间件执行完毕后, 就返回上一个中间件执行剩下的代码, 在所有中间件代码都执行完毕之后再返回结果.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-Node的express框架</title>
      <link href="2021/05/26/08-Node%E7%9A%84express%E6%A1%86%E6%9E%B6/"/>
      <url>2021/05/26/08-Node%E7%9A%84express%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="认识Web框架"><a href="#认识Web框架" class="headerlink" title="认识Web框架"></a>认识Web框架</h3><ul><li>在前面我们学习了使用http内置模块来搭建Web服务器, 为什么还要使用框架呢?<ul><li>原生http在进行很多处理的时候, 会较为复杂</li><li>比如URL判断, Method判断, 参数处理, 逻辑代码处理等, 都需要我们自己来处理和封装</li><li>并且所有的内容都放在一起, 会非常的混乱</li></ul></li><li>目前在Node中比较流行的Web服务器框架是express, koa</li><li>express早于koa出现, 并且在Node社区中迅速流行起来<ul><li>我们可以基于express快速, 方便地开发自己的Web服务器</li><li>并且可以通过一些实用工具和中间件来扩展自己的功能</li></ul></li><li>重点: Express整个框架的核心就是中间件, 理解了中间件其他一切都非常简单.中间件本质上是传递给express的回调函数.</li></ul><h3 id="Express安装"><a href="#Express安装" class="headerlink" title="Express安装"></a>Express安装</h3><ul><li>express的使用过程有两种方式<ul><li>方式一: 通过express提供的脚手架, 直接创建一个应用的骨架, 终端命令行输入 express 项目名称 , 按下回车键即可创建<ul><li>安装脚手架</li><li>npm install -g express-generator</li><li>创建项目</li><li>express express-demo</li><li>安装依赖</li><li>npm install</li><li>启动项目</li><li>node bin/www</li></ul></li><li>方式二: 从零搭建自己的express应用结构<ul><li>npm init -y</li></ul></li></ul></li></ul><h3 id="Express的基本使用"><a href="#Express的基本使用" class="headerlink" title="Express的基本使用"></a>Express的基本使用</h3><h3 id="认识中间件"><a href="#认识中间件" class="headerlink" title="认识中间件"></a>认识中间件</h3><ul><li>Express是一个路由和中间件的Web框架, 它本身的功能是非常少的<ul><li>express应用程序本质上是一系列中间件函数的调用</li></ul></li><li>中间件是什么<ul><li>中间件的本质是传递给express的一个回调函数</li><li>这个回调函数接收三个参数<ul><li>请求对象(request对象)</li><li>响应对象(response对象)</li><li>next函数(在express中定义的用于执行下一个中间件的函数)</li></ul></li></ul></li><li>中间件可以执行哪些任务?<ul><li>执行任何代码</li><li>更改请求(request)和响应(response)对象</li><li>结束请求-响应周期(返回数据)</li><li>调用栈中的下一个中间件</li></ul></li><li>如果当前中间件功能没有结束请求-响应周期,则必须调用next()函数将控制权传递给下一个中间件功能,否则,请求将被挂起</li></ul><h3 id="应用中间件-自己编写"><a href="#应用中间件-自己编写" class="headerlink" title="应用中间件-自己编写"></a>应用中间件-自己编写</h3><ul><li>如何将一个中间件应用到我们的应用程序中呢?<ul><li>express主要提供了两种方式: app/router.use 和 app.router.methods</li><li>methods指的是常用的请求方式, 比如app.get和app.post等, 其实还有app.all, 但是不常用</li></ul></li></ul><h3 id="应用中间件-body解析"><a href="#应用中间件-body解析" class="headerlink" title="应用中间件-body解析"></a>应用中间件-body解析</h3><ul><li>并非所有的中间件都需要我们从零取编写<ul><li>express中有内置一些帮助我们完成对request解析的中间件</li><li>registry仓库中也有很多可以帮助我们开发的中间件</li></ul></li><li>在客户端发送post请求的时, 会将数据放到body中<ul><li>客户端可以通过请求json的方式传递<ul><li>此时使用 app.use(express.json()) 中间件即可完成数据解析</li></ul></li><li>客户端通过form表单的方式传递<ul><li>此时使用 app.use(express.urlencoded({ extend: true })) 中间件即可完成解析<ul><li>extend是一个布尔值, 有两个值ture和false</li><li>为true的时候, 表示使用第三方库qs解析</li><li>为false的时候, 表示使用Node内置模块querystring解析</li></ul></li></ul></li></ul></li></ul><h3 id="express响应数据"><a href="#express响应数据" class="headerlink" title="express响应数据"></a>express响应数据</h3><ul><li>express响应数据的常用方法又以下几种</li><li>end方法<ul><li>类似于http中的response.end方法, 用法是一致的</li></ul></li><li>json方法<ul><li>json方法中可以传入很多的类型: object, array, string, boolean, number, null等, 都会被转换为json格式返回</li></ul></li><li>status方法<ul><li>该方法用于返回设置的状态码</li></ul></li><li>更多的响应方式: <a href="https://www.expressjs.com.cn/4x/api.html">https://www.expressjs.com.cn/4x/api.html</a></li></ul><h3 id="express的路由"><a href="#express的路由" class="headerlink" title="express的路由"></a>express的路由</h3><ul><li>如果我们将所有的代码逻辑都写在app中, 那么app会变得越来越复杂<ul><li>一方面完整的Web服务器包含非常多的处理逻辑</li><li>另一方面有些处理逻辑其实是一个整体, 我们应该将它们放在一起: 比如对users相关的处理<ul><li>获取用户列表</li><li>获取某一个用户信息</li><li>创建一个新的用户</li><li>删除一个用户</li><li>更新一个用户</li></ul></li></ul></li><li>我们可以使用express.Router来创建一个路由处理程序<ul><li>一个Router实例拥有完整的中间件和路由系统</li><li>因此, 它也被称为迷你应用程序(mini-app)</li></ul></li></ul><h3 id="静态资源服务器"><a href="#静态资源服务器" class="headerlink" title="静态资源服务器"></a>静态资源服务器</h3><ul><li>部署静态资源我们可以选择很多方式<ul><li>Node也可以作为静态资源服务器, 并且express给我们提供了方便部署静态资源的方法</li><li>直接以使用中间件的方式调用 express.static(“需要部署的项目根目录”) 即可完成部署</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-Node的Http模块</title>
      <link href="2021/05/26/07-Node%E7%9A%84Http%E6%A8%A1%E5%9D%97/"/>
      <url>2021/05/26/07-Node%E7%9A%84Http%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h3><ul><li>什么是Web服务器<ul><li>当应用程序(客户端)需要某一个资源的时候, 可以向一台服务器, 通过http请求获取这个资源; 提供资源的这个服务器, 就是一个Web服务器</li></ul></li><li>目前有很多开源的web服务器: Nginx, Apache(主要传输静态资源), Apache Tomcat(主要传输静态和动态资源), Node.js</li></ul><h3 id="Web服务器初体验-创建一个简单的服务器"><a href="#Web服务器初体验-创建一个简单的服务器" class="headerlink" title="Web服务器初体验(创建一个简单的服务器"></a>Web服务器初体验(创建一个简单的服务器</h3><ul><li>首先引入http模块, 然后通过createServer来创建服务器对象<ul><li>http.createServer会返回服务器对象</li><li>底层其实直接使用new Server对象</li></ul></li><li>创建Server对象的时候会传入一个回调函数, 在这个回调函数被调用的时候会传入两个参数<ul><li>第一个参数 req: request请求对象, 包含请求相关信息</li><li>第二个参数 res: response响应对象, 包含服务器要发送给客户端的信息</li></ul></li><li>监听主机和端口号<ul><li>Server通过listen方法来开启服务器, 并且在某一个主机和端口上监听网络请求<ul><li>也就是当我们通过ip: port的方式发送到我们监听的web服务器上时</li><li>我们就可以对其进行相关的处理</li></ul></li><li>listen方法有三个参数<ul><li>第一个参数为端口号port: 可以不传, 系统会默认分配端口, 后续项目中我们会写入到环境变量中</li><li>第二个参数为主机号host: 通用长传入loaclhost, ip地址127.0.0.1, 或者ip地址0.0.0.0, 默认为0.0.0.0<ul><li>localhost: 本质上是一个域名, 通常情况下最终会被解析成127.0.0.1</li><li>127.0.0.1: 回环地址(Loop Back Address), 表达的意思其实是我们主机自己发出去的包, 直接被自己接收<ul><li>正常的数据库经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层</li><li>而回环地址, 是在网络层直接被获取到了, 是不会经常数据链路层和物理层的</li><li>比如我们监听127.0.0.1的时候, 在同一个网段下的主机中, 通过ip地址是不能访问的</li></ul></li><li>0.0.0.0:<ul><li>监听IPV4上所有的地址, 再根据端口找到不同的应用程序</li><li>比如我们监听0.0.0.0时, 在同一个网段下的主机中, 通过ip地址是可以访问的</li></ul></li></ul></li></ul><ul><li>第三个参数为回调函数: 服务器启动成功时的回调函数</li></ul></li></ul></li></ul><h3 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h3><ul><li>在客户端向服务器端发送请求的时候, 会携带很多信息, 比如:<ul><li>本次请求的URL, 服务器需要根据不同的URL进行不同的处理</li><li>本次请求的请求方式, 比如GET, POST请求传入的参数和处理的方式是不一样的</li><li>本次请求的headers种携带的一些信息, 比如客户端信息, 客户端接收数据的格式, 客户端支持的编码格式等</li><li>等等…</li></ul></li><li>这些信息, Node会帮助我们封装到request对象中, 我们可以直接处理这个request对象</li></ul><h3 id="URL的处理"><a href="#URL的处理" class="headerlink" title="URL的处理"></a>URL的处理</h3><ul><li>客户端在发送请求的时候, 会请求不同的数据, 此时服务器端需要根据不同的请求地址, 作出不同的响应</li></ul><h3 id="URL的解析"><a href="#URL的解析" class="headerlink" title="URL的解析"></a>URL的解析</h3><ul><li>如果客户端在发送请求的时候的url携带了其他的参数</li><li>此时的url会变得很复杂</li><li>此时我们可以使用内置模块url对url进行解析</li><li>然后我们又发现解析出来的url中的query又是一个复杂的数据</li><li>此时我们可以使用内置模块querystring来对query进行解析</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入url模块</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入querystring模块</span></span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&quot;querystring&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// request对象种的url最基本用法</span></span><br><span class="line">  <span class="comment">// if(req.url === &quot;/login&quot;) &#123;</span></span><br><span class="line">  <span class="comment">//   res.end(&quot;欢迎回来&quot;)</span></span><br><span class="line">  <span class="comment">// &#125; else if (req.url === &quot;/user&quot;) &#123;</span></span><br><span class="line">  <span class="comment">//   res.end(&quot;登陆成功&quot;)</span></span><br><span class="line">  <span class="comment">// &#125; else &#123;</span></span><br><span class="line">  <span class="comment">//   res.end(&quot;请求错误, 请检查&quot;)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实际上url是很复杂的</span></span><br><span class="line">  <span class="comment">// 此时我们需要借助一个交url的模块帮助解析从客户端传输到服务器的url</span></span><br><span class="line">  <span class="built_in">console</span>.log(url.parse(req.url));</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url);</span><br><span class="line">  <span class="built_in">console</span>.log(pathname, query);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此时我们又发现传输过来的query又是很复杂的, 实际上我们可以通过字符串切割的方式来获取到需要的数据</span></span><br><span class="line">  <span class="comment">// 为了方便操作, 我们可以使用querystring模块来对处理query</span></span><br><span class="line">  <span class="built_in">console</span>.log(qs.parse(query));</span><br><span class="line">  <span class="keyword">const</span> &#123; username, password &#125; = qs.parse(query);</span><br><span class="line">  <span class="built_in">console</span>.log(username, password);</span><br><span class="line"></span><br><span class="line">  res.end(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="method的处理"><a href="#method的处理" class="headerlink" title="method的处理"></a>method的处理</h3><ul><li>在Restful规范(设计风格)中, 我们对于数据的增删改查一个通过不同的请求方式<ul><li>GET: 查询数据</li><li>POST: 新建数据</li><li>PATCH: 更新数据</li><li>DELETE: 删除数据</li></ul></li><li>所以, 我们可以通过判断不同的请求方式进行不同的处理<ul><li>比如创建一个用户</li><li>请求接口为/users</li><li>请求方式为POST请求</li><li>携带数据username和password</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> qs = <span class="built_in">require</span>(<span class="string">&quot;querystring&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个web服务器</span></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = url.parse(req.url)</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (req.method === <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果要获取到post请求中的body中的数据</span></span><br><span class="line">      <span class="comment">// 需要使用监听req中的data事件</span></span><br><span class="line">      <span class="comment">// 这是因为post请求中传输过来的数据是使用流的方式传输的</span></span><br><span class="line">      <span class="comment">// 所以注意这里传输过来的data是buffer格式的</span></span><br><span class="line">      <span class="comment">// 可以使用setEncoding方法来设置编码</span></span><br><span class="line">      req.setEncoding(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">      req.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data, <span class="keyword">typeof</span> data); <span class="comment">// 注意这里的data是字符串格式的</span></span><br><span class="line">        <span class="comment">// 为了更好的处理传输过来的data, 使用JSON.parse() 将JSON字符串转换为对象格式</span></span><br><span class="line">        <span class="keyword">const</span> &#123; username, password &#125; = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">        <span class="built_in">console</span>.log(username, password);</span><br><span class="line">      &#125;)</span><br><span class="line">      res.end(<span class="string">&quot;请求成功&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// res.end(&quot;请求成功&quot;)</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="headers属性"><a href="#headers属性" class="headerlink" title="headers属性"></a>headers属性</h3><ul><li>在requert对象中的header中包含很多有用的信息, 客户端会默认传递过来一些信息</li><li>content-type: 这次请求携带的数据类型<ul><li>application/json 表示是一个json类型</li><li>text/plain 表示是一个文本类型</li><li>application/xml 表示是一个xml类型</li><li>multipart/form-data表示是上传文件</li></ul></li><li>content-length: 文件的大小和长度</li><li>keep-alive:<ul><li>http 是基于TCP协议的, 但是通常在进行一次请求和响应结束后立刻终端</li><li>在http1.0中, 如果想要继续保持链接<ul><li>浏览器需要在请求头中添加 connection: keep-alive</li><li>服务器需要在响应头中添加: connection: keey-alive</li><li>当客户端再次请求后, 就会使用同一个链接, 直到一方中断链接</li></ul></li><li>在http1.1中, 所有链接默认是connection:keep-alive的<ul><li>不同的web服务器会有不同的保持keep-alive的时间</li><li>Node中默认是5s钟</li></ul></li></ul></li><li>accept-encoding: 告知服务器, 客户端支持的文件压缩格式, 比如js文件可以使用gzip编码, 对应.gz文件</li><li>accept: 告知服务器, 客户端可以接收文件的格式类型</li><li>user-agent: 客户端相关信息</li></ul><h3 id="response对象返回响应结果"><a href="#response对象返回响应结果" class="headerlink" title="response对象返回响应结果"></a>response对象返回响应结果</h3><ul><li>如果我们希望给客户端返回响应的结果数据, 可以通过两种方式<ul><li>write方法: 这种方式是直接返回数据, 但是并没有关闭流</li><li>end方法: 这种方式是写出最后的数据, 并且在写出后会关闭流</li></ul></li><li>如果服务器在返回响应数据后没有调用end方法, 客户端会一直等待结果<ul><li>所以客户端在发送网络请求时, 都会设置超时时间</li></ul></li></ul><h3 id="response对象返回状态码"><a href="#response对象返回状态码" class="headerlink" title="response对象返回状态码"></a>response对象返回状态码</h3><ul><li>Http状态码(Http Status Code) 是用于表示Http响应状态的数字代码<ul><li>Http状态码非常多, 可以根据不同的情况, 给客户端返回不同的状态码</li></ul></li><li>设置状态码常见的的方式有两种</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应码有两种方式</span></span><br><span class="line">  <span class="comment">// 方式一: 直接设置</span></span><br><span class="line">  <span class="comment">// req.statusCode = 400;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式二: 与响应head一起设置</span></span><br><span class="line">  res.writeHead(<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">  res.end(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="response对象响应头文件"><a href="#response对象响应头文件" class="headerlink" title="response对象响应头文件"></a>response对象响应头文件</h3><ul><li>Header设置Content-Type有很重要的作用<ul><li>该属性决定了浏览器根据服务器返回的数据做出什么样的处理方式</li></ul></li><li>常见的设置响应头文件的方式有两种<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应的Header</span></span><br><span class="line">  <span class="comment">// 设置方式一: 直接设置</span></span><br><span class="line">  <span class="comment">// res.setHeader(&quot;Content-type&quot;, &quot;text/plain&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置方式二: 通过writeHead方法设置</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;text/plain&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  res.end(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="http模块发送网络请求"><a href="#http模块发送网络请求" class="headerlink" title="http模块发送网络请求"></a>http模块发送网络请求</h3><ul><li>在http中也是可以发送网络请求的, 可以用于反向代理</li><li>实际开发中并不会使用原生的http模块来进行网络请求, 而是使用axios库来实现</li><li>axios库可以在浏览器中使用, 也可以在Node中使用<ul><li>在浏览器中使用, axios是基于xhr来实现的</li><li>在Node中, axios是基于http内置模块来实现的</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Node中Stream流</title>
      <link href="2021/05/26/06-Node%E4%B8%ADStream%E6%B5%81/"/>
      <url>2021/05/26/06-Node%E4%B8%ADStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Stream-流"><a href="#什么是Stream-流" class="headerlink" title="什么是Stream(流)"></a>什么是Stream(流)</h3><ul><li>什么是流?<ul><li>我们的第一反应应该是流水, 源源不断地流动</li><li>程序中的流也是类似的概念, 我们可以想象在我们从一个文件中读取数据的时候, 文件的二进制(字节)数据会源源不断地被读取至程序中</li><li>而这些一连串的字节, 就是程序中的流</li></ul></li><li>所以流<ul><li>是连续字节的一种表现形式和抽象概念</li><li>流应该是可读的, 也是可写的</li></ul></li><li>在之前学习文件的读写的时候, 我们可以直接通过fs模块中的readFile函数和writeFile方式读写文件, 那为什么还需要流呢?<ul><li>如果直接通过fs模块中的函数来读写文件, 虽然是比较简单和方便, 但是这种方式来操作文件无法控制一些细节的操作</li><li>比如从什么位置开始读取, 读取到什么位置, 一次性读取多少个字节</li><li>读取到某个位置后, 暂停读取, 在某个时刻又恢复读取等等的操作</li><li>又或者需要读取的文件非常大, 比如一个视频文件, 如果一次性全部读取的话是不合适的</li></ul></li></ul><h3 id="文件读写的Stream"><a href="#文件读写的Stream" class="headerlink" title="文件读写的Stream"></a>文件读写的Stream</h3><ul><li>事实上Node中很多对象是基于流实现的<ul><li>http模块的Request和Response对象</li><li>process.stdout对象</li></ul></li><li>Node官方: 另外所有的流都是EventEmitter的实例</li><li>Node.js中有四种基本流类型<ul><li>Writable: 可以向其写入数据的流(例如: fs.createWriteStream())</li><li>Readable: 可以从中读取数据的流(例如: fs.createReadStream())</li><li>Duplex: 同时为Readable和Writable的流(例如: net.Socket)</li><li>Transform: Duplex可以在写入和读取数据时修改或转换数据的流(例如: zlib.createDeflate())</li></ul></li></ul><h3 id="Readable流"><a href="#Readable流" class="headerlink" title="Readable流"></a>Readable流</h3><ul><li>之前我们读取一个文件的信息是通过fs模块中的readFile来实现的</li><li>这种方式是一次性将一个文件中所有的内容全部都读取到程序(内存)中, 但是这种读取方式就会出现上面所说的问题<ul><li>文件过大, 读取的位置不能控制, 结束的位置不能控制, 一次读取的字节大小不能控制等</li></ul></li><li>这个时候, 我们可以使用fs模块中的createReadStream来实现可控地读取文件, createReadStream有以下几个参数<ul><li>strat: 文件读取开始的位置</li><li>end: 文件读取结束的位置</li><li>highWaterMark: 一次性读取字节的长度, 默认是64kb</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先引入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用readFile方法来读取文件</span></span><br><span class="line">fs.readFile(<span class="string">&quot;./foo.txt&quot;</span> ,<span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件的Readable</span></span><br><span class="line"><span class="keyword">const</span> readable = fs.createReadStream(<span class="string">&quot;./foo.txt&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">start</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">highWaterMark</span>: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听data事件来获取读取到的数据</span></span><br><span class="line">readable.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过pause()函数来暂停读取</span></span><br><span class="line">  readable.pause()</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过resume()方法来恢复读取</span></span><br><span class="line">    readable.resume()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听open事件来接收文件打开事件</span></span><br><span class="line">readable.on(<span class="string">&quot;open&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件被打开了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听close事件来接收文件关闭事件</span></span><br><span class="line">readable.on(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件被关闭了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听end事件来接收读取结束事件</span></span><br><span class="line">readable.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;读取结束&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Writable流"><a href="#Writable流" class="headerlink" title="Writable流"></a>Writable流</h3><ul><li>之前我们写入一个文件的方式是通过fs模块中的writeFile实现的</li><li>这种方式相当于一次性将所有内容写入到文件中, 但是这种方式也有很多问题<ul><li>比如不能控制写入内容的数量, 不能控制每次写入的位置等</li></ul></li><li>这个时候, 我们可以使用createWriteStream来实现可控地写入文件, createWriteStream有主要以下两个参数<ul><li>flags: 设置写入的方式, 默认为w, 如果我们希望是追加写入, 可以使用a或者a+</li><li>start: 写入的位置</li></ul></li><li>注意<ul><li>写入流在打开后是不会自动关闭文件的</li><li>我们必须手动调用close方法来关闭文件, 来告诉Node已经写入结束了</li><li>close会发出一个finish事件</li><li>但是我们一般不会使用close方法, 更常用的是end方法: end方法相当于做了两步操作: write传入的数据和调用close方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先引入fs模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以前写入文件的方式, 通过writeFile实现</span></span><br><span class="line"><span class="comment">// fs.writeFile(&quot;./bar.txt&quot;, &quot;hello wrold&quot;, &#123;&#125;, (err) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   if(err) &#123;</span></span><br><span class="line"><span class="comment">//     console.log(err);</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用createWriteStream的方式写入</span></span><br><span class="line"><span class="comment">// 首先创建文件的Writable</span></span><br><span class="line"><span class="keyword">const</span> writable = fs.createWriteStream(<span class="string">&quot;./bar.txt&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">flags</span>: <span class="string">&quot;a+&quot;</span>, <span class="comment">// 这里的flags用于设置写入的方式</span></span><br><span class="line">  <span class="attr">start</span>: <span class="number">4</span> <span class="comment">// start设置开始写入的位置</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过调用write方法来写入</span></span><br><span class="line">writable.write(<span class="string">&quot;你好哇&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听open事件来接收文件打开的事件</span></span><br><span class="line">writable.on(<span class="string">&quot;open&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件被打开了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过监听close事件来接收文件被关闭的事件</span></span><br><span class="line">writable.on(<span class="string">&quot;close&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;文件被关闭了&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入操作的时候, 文件不会自动地关闭</span></span><br><span class="line"><span class="comment">// 而是要主动地调用 close()方法来关闭文件</span></span><br><span class="line"><span class="comment">// writable.close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是我们一般不会使用close来关闭文件</span></span><br><span class="line"><span class="comment">// 而是使用end()方法来关闭</span></span><br><span class="line"><span class="comment">// end()方法相当于做了两步操作, write写入传入的数据和调用close方法</span></span><br><span class="line">writable.end(<span class="string">&quot;最终写入&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="pipe方法"><a href="#pipe方法" class="headerlink" title="pipe方法"></a>pipe方法</h3><ul><li>pipe方法可以将读取到的数据存放在管道中</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-Node中事件循环和异步IO</title>
      <link href="2021/05/26/05-Node%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5IO/"/>
      <url>2021/05/26/05-Node%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%BC%82%E6%AD%A5IO/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h3><ul><li>事件循环可以理解成我们编写的JavaScript和浏览器或者Node之间的一个桥梁</li><li>浏览器的事件循环是一个我们编写的JavaScript代码和浏览器API调用(setTimeout/AJAX/监听事件等)的一个桥梁, 桥梁之间是通过回调函数来进行沟通的</li><li>Node的事件循环时我们编写的JavaScript代码和系统调用(file system, network等)之间的一个桥梁, 桥梁之间是通过回调函数来进行沟通的</li></ul><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li>进程和线程是操作系统中的两个概念<ul><li>进程(process): 计算机已经运行的程序</li><li>线程(thread): 操作系统能够运行运算调度的最小单位</li></ul></li><li>直观来解释就是<ul><li>进程: 启动一个应用程序, 就会默认启动一个进程(也有可能是多进程, 比如浏览器, 浏览器中的一个页面就是一个进程)\</li><li>线程: 每一个进程中, 都会启动一个线程用来执行程序中的代码, 这个线程被称为主线程</li><li>所以我们可以称进程是线程的容器</li></ul></li><li>用一个形象的例子来解释:<ul><li>操作系统类似于一个工厂</li><li>工厂中有很多个车间, 这些车间就是进程</li><li>每一个车间可能有一个以上的工人在工作, 这些工人就是线程</li></ul></li></ul><h3 id="多进程多线程开发"><a href="#多进程多线程开发" class="headerlink" title="多进程多线程开发"></a>多进程多线程开发</h3><ul><li>操作系统是如何做到同时让多个进程同时工作呢?<ul><li>这是由于CPU的运算速度非常快, 它可以快速地在多个进程之间迅速地切换</li><li>当我们的进程中的线程获取到时间片时, 就可以快速执行代码</li><li>对于用户来说是感觉不到这种快速的切换的</li></ul></li></ul><h3 id="浏览器和JavaScript"><a href="#浏览器和JavaScript" class="headerlink" title="浏览器和JavaScript"></a>浏览器和JavaScript</h3><ul><li>我们经常会说JavaScript是单线程的, 但是JavaScript的线程有自己的容器进程: 也就是浏览器或者Node</li><li>浏览器是一个进程, 而且浏览器中可以有很多的线程<ul><li>多数浏览器都是多进程的, 当打开一个tab页面的时候就会开启一个新的进程, 这是为了防止一个页面卡死的情况下造成所有页面无法响应, 整个浏览器需要强制退出的问题</li><li>浏览器中的每一个进程又有很多的线程, 其中包括执行JavaScript代码的线程</li></ul></li><li>但是JavaScript的代码执行是在一个单独的线程中执行的<ul><li>这就意味着JavaScript的代码, 在同一个时刻只能做一件事情</li><li>如果这件事是非常耗时的, 就意味着当前的线程阻塞</li></ul></li></ul><h3 id="JavaScript代码的执行过程"><a href="#JavaScript代码的执行过程" class="headerlink" title="JavaScript代码的执行过程"></a>JavaScript代码的执行过程</h3><ul><li>实际上浏览器或者Node执行JavaScript的异步代码时, 会将异步代码放到事件队列中, 然后再合适的时机, 将其回调函数放到函数调用栈中执行</li></ul><h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul><li>事件循环中并非只维护着一个队列, 事实上有两个队列<ul><li>宏任务队列 (macrotask queue): ajax, setTimeout, setInterval, DOM监听事件, UI Rendering等</li><li>微任务队列 (microtask queue): Promise的then回调, Mutation Observer API, queueMicrotask()等</li><li>注意async await是Promise的一个语法糖<ul><li>我们可以将await关键字后面执行的代码, 看作是包裹在(resolve, reject) =&gt; (函数执行) 中的代码</li><li>await的下一条语句, 可以看作是then(res =&gt; (函数执行))中的代码</li></ul></li></ul></li><li>事件循环对两个队列的优先级<ul><li><ol><li>main script中的代码优先执行(编写的顶层script代码)</li></ol></li><li><ol start="2"><li>在执行任何一个宏任务之前(不是队列, 是一个宏任务), 都会先查看微任务队列中是否有微任务需要执行</li></ol><ul><li>也就是说宏任务执行之前, 必须保证微任务队列是空的</li><li>如果微任务队列不为孔, 那么就优先执行微任务队列中的任务(回调)</li></ul></li></ul></li></ul><h3 id="Node的架构分析"><a href="#Node的架构分析" class="headerlink" title="Node的架构分析"></a>Node的架构分析</h3><ul><li>浏览器中的EventLoop是根据HTML5定义的规范来实现的, 不同的浏览器可能会有不同的实现, 而Node中是由libuv来实现的</li><li>libuv中主要维护了一个EventLoop和worker threads(线程池)</li><li>EventLoop负责调用系统的一些其他操作: 文件的IO, Network, child-processes等</li><li>libuv是一个多平台的专注于异步IO的库, 它最初是为了Node开发的, 但是现在也被使用在Luvit, Julia, pyuv等其他地方</li></ul><h3 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h3><ul><li>如果我们希望在程序中对一个文件进行操作, 那么我们就需要打开这个文件: 通过文件描述符<ul><li>JavaScript是否可以对一个文件进行操作呢?</li><li>事实上我们任何程序中的文件操作都是需要进行系统调用(操作系统的文件系统)来实现的</li><li>所以对文件的操作, 是一个操作系统的IO操作(input, output)</li></ul></li><li>操作系统为我们提供了阻塞式调用和非阻塞式调用:<ul><li>阻塞式调用: 调用结果返回之前, 当前线程处于阻塞态(阻塞态式CPU是不会分配时间片的), 调用线程只有在得到调用结果后才会继续执行下去</li><li>非阻塞式调用: 调用执行之后, 当前线程式不会停止执行的, 只会过一段时间来检查一下有没有结果返回</li></ul></li><li>所以我们开发中的很多耗时的操作, 都可以基于非阻塞式调用<ul><li>比如网络请求本身使用了Socket通讯, 而Socket本身提供了select模型, 可以进行非阻塞式工作</li><li>比如文件读写的IO操作, 我们可以使用操作系统提供的基于事件的回调机制</li></ul></li></ul><h3 id="非阻塞IO的问题"><a href="#非阻塞IO的问题" class="headerlink" title="非阻塞IO的问题"></a>非阻塞IO的问题</h3><ul><li>非阻塞IO也会存在一定的问题: 在调用结果返回之前, 我们斌没有获取到需要读取的结果<ul><li>那么就意味着为了可以知道是否读取到完整的数据, 我们需要频繁地去确定读取到的数据是否是完整地</li><li>这个过程称为轮询操作</li></ul></li><li>这个轮询工作是由谁来完成的呢?<ul><li>如果我们地主线程频繁地去进行轮询的工作, 那么必然会大大降低性能</li><li>并且开发中我们可能不只是一个文件的读写, 可能是多个文件</li><li>而且可能是多个功能: 网络的IO, 数据库的IO, 子进程的调用</li></ul></li><li>libuv提供了一个线程池(Thread Pool)<ul><li>线程池会负责所有相关的操作, 摈弃会通过轮询等方式等待结果</li><li>当获取到结果的时候, 就可以将对应的回调放到事件循环(某一个事件队列)中</li><li>事件循环就可以负责接管后续的回调工作, 告知JavaScript应用程序执行对应的回调函数</li></ul></li></ul><h3 id="阻塞和非阻塞-同步和异步的区别"><a href="#阻塞和非阻塞-同步和异步的区别" class="headerlink" title="阻塞和非阻塞, 同步和异步的区别"></a>阻塞和非阻塞, 同步和异步的区别</h3><ul><li>阻塞和非阻塞是对于被调用者来说的<ul><li>在我们这里就是系统调用, 操作系统为我们提供了阻塞调用和非阻塞调用</li></ul></li><li>同步和异步是对于调用者说的<ul><li>在我们这里就是自己编写的程序</li><li>如果我们在发起调用之后, 不会进行其他任何操作, 只是等待结果, 这个过程就称为同步调用</li><li>如果我们在发起调用之后, 并不会等待结果, 而是继续完成下面的工作, 等到调用结果出来之后再去执行, 这个过程就称为异步调用</li></ul></li><li>Libuv采用的就是非阻塞异步IO的调用方式</li></ul><h3 id="Node事件循环的阶段"><a href="#Node事件循环的阶段" class="headerlink" title="Node事件循环的阶段"></a>Node事件循环的阶段</h3><ul><li>事件循环就像是一个桥梁, 是链接应用程序的JavaScript和系统调用之间的通道<ul><li>无论是文件IO, 数据库, 网络IO, 定时器, 子进程, 再完成对应的操作之后, 都会将对应的结果和回调函数放到事件循环(任务队列)中</li><li>事件循环会不断地从任务队列中取出对应的事件(回调函数)来执行</li></ul></li><li>但是一次完整的事件循环Tic分成很多个阶段(每一个阶段执行相对应的回调函数)<ul><li>定时器(Timer): 本阶段执行已经被setTimeout() 和 setInterval() 的调度回调函数</li><li>待定回调(Pending Callback): 对某些系统操作(比如TCP错误类型)执行回调, 比如TCP连接时接收到ECONNREFUSED</li><li>idle, prepare: 仅系统内部使用</li><li>轮询(Poll): 检查新的I/O事件; 执行与I/O相关的回调 (在这个阶段会又一个小停留, 这是为了用户的IO操作可以尽可能早的获得结果)</li><li>检测: setImmediate() 回调函数在这里执行</li><li>关闭的回调函数: 一些关闭的回调函数. 比如: socket.on(‘close’, () =&gt; {})</li></ul></li></ul><h3 id="Node的微任务和宏任务"><a href="#Node的微任务和宏任务" class="headerlink" title="Node的微任务和宏任务"></a>Node的微任务和宏任务</h3><ul><li>我们会发现一次事件循环Tick来说, Node的事件循环比浏览器的事件循环更加复杂, 也分为微任务和宏任务<ul><li>宏任务(macrotask): setTimeout, setInterval, IO事件, setImmediate, close事件</li><li>微任务(microtask): Promise的then回调, process.nextTick, queueMicrotask</li></ul></li><li>但是, Node中的事件循环不只是微任务和宏任务<ul><li>微任务队列又分为<ul><li>next tick queue: process.nextTick</li><li>other queue : Promise的then回调, queueMicrotask</li></ul></li><li>宏任务又分为<ul><li>timer queue: setTimeout, setInterval</li><li>poll queue: IO事件</li><li>check queue: setImmediate</li><li>close queue: close事件</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Node中常见的内置模块</title>
      <link href="2021/05/26/04-Node%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/"/>
      <url>2021/05/26/04-Node%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="内置模块path"><a href="#内置模块path" class="headerlink" title="内置模块path"></a>内置模块path</h3><ul><li>path模块是用于对路径的文件进行处理的模块, path提供了很多好用的方法</li><li>需要知道, 在不同的操作系统中, 使用的文件分隔符是不一样的<ul><li>在window操作系统中使用的文件分隔符为 “/“, “&quot; 和 “\“</li><li>而在Linux和mac os操作系统中使用的文件分隔符为 “/“</li></ul></li><li>如果我们在window上使用”&quot;分隔符开发了一个程序, 而要将这个程序部署在Linux上面<ul><li>此时文件的路径就会出现问题</li><li>所以为了解决这个问题, 在开发中对路径的操作需要使用path模块来对文件的路径进行转换</li></ul></li><li>课外知识:<ul><li>为什么window操作系统和Linux操作系统使用的文件分隔符是不一样的?<ul><li>这是由于 Linux和mac os操作系统都实现了POSIX接口(可移植操作系统接口), 在这个规范中文件分隔符规定使用”/“</li><li>而window操作系统在早期并没有实现POSIX接口, 就没有使用这个规范, 但是在现在新版本的window操作系统中已经支持了这个接口, 所以也可以使用”/“分隔符了</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> basePath = <span class="string">&quot;/User/xiaoLam&quot;</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;good.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用path模块中的 resolve接口来进行路径的拼接</span></span><br><span class="line"><span class="keyword">const</span> filePath = path.resolve(basePath, filename)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filePath); <span class="comment">// C:\User\xiaoLam\good.txt</span></span><br></pre></td></tr></table></figure><h3 id="path常见的API"><a href="#path常见的API" class="headerlink" title="path常见的API"></a>path常见的API</h3><ul><li>从路径中获取信息<ul><li>dirname: 获取传入文件路径参数的父文件夹</li><li>basename: 获取文件名</li><li>extname: 获取文件的后缀名</li></ul></li><li>路径的拼接<ul><li>如果我们希望将多个路径进行拼接, 但是在不同的操作系统中使用的分隔符可能不一样(上面讲过)</li><li>这个时候可以使用 path.json方法来对路径进行拼接</li></ul></li><li>将文件和某个文件夹拼接<ul><li>如果我们希望将某个文件和文件夹进行拼接, 可以使用path.resolve</li><li>resolve函数会判断传入的路径参数的前面是否以 / 或者 ./ 或者 // 开头</li><li>如果有表示是一个绝对路径, 此时函数返回对应的拼接路径</li><li>如果没有, 此时函数会将当前执行文件所在的文件夹的路径拼接在前面再进行返回</li></ul></li><li>一般来说resolve 比join 更加常用</li><li>在webpack中获取路径或者起别名的地方都是使用resolve方法来实现的</li></ul><h3 id="内置模块fs"><a href="#内置模块fs" class="headerlink" title="内置模块fs"></a>内置模块fs</h3><ul><li>fs是file system的缩写, 表示文件系统</li><li>对于任何一个为服务器端服务的语言或者框架通常都会有自己的文件系统<ul><li>因为服务器需要将各种数据, 文件等放置到不同的地方</li><li>比如用户数据可能放到数据库中</li><li>比如某些配置文件或者用户资源(图片, 音频视频等) 都是以文件的形式放到操作系统中</li></ul></li><li>Node也有自己的文件系统操作模块, 就是fs<ul><li>借助于Node帮我们封装的文件系统, 我们可以在任何的操作系统(window, mac os, Linux)中直接去操作文件</li><li>这也是Node可以开发服务器的一大原因, 也是它可以成为前端自动化脚本等热门工具的原因</li></ul></li></ul><h3 id="fs的API介绍"><a href="#fs的API介绍" class="headerlink" title="fs的API介绍"></a>fs的API介绍</h3><ul><li>Node文件操作系统fs的API非常多<ul><li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/fs.html">https://nodejs.org/dist/latest-v14.x/docs/api/fs.html</a></li><li>不可能, 也没必要一个个学习</li><li>更应该作为一个API查询手册, 等到用到的时候查询即可</li><li>学习阶段只需学习最常用的API</li></ul></li><li>Node中的fs的API大多数都提供了三种操作方式<ul><li>方式一: 同步操作文件, 这种方法操作文件会让代码阻塞, 后续的代码会在操作结束后继续执行</li><li>方式二: 异步操作文件, 异步回调函数操作文件, 这种方式操作文件代码不会阻塞, 这种方法需要传入回调函数, 当获取到结果时, 回调函数会被执行</li><li>方式三: 通过异步Promise操作文件, 这种方法操作文件代码不会阻塞, 通过fs.promises调用方法来操作, 会返回一个Promise对象, 通过then, catch进行处理返回的数据</li></ul></li></ul><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><ul><li><p>文件描述符(File descriptors)</p><ul><li>在POSIX系统中, 对于每一个进程, 内核都维护者一张当前打开着的文件和资源的表格</li><li>每一个打开的文件都分配了一个称为文件描述符的简单的数字标识符</li><li>在系统层, 所有文件系统操作都使用这些文件描述符来标识和跟踪每一个特定的文件</li><li>window系统使用了一个虽然不同但是概念上类似的机制来跟着资源</li></ul></li><li><p>为了简化用户的工作, Node.js抽象出操作系统之间的特定差异, 并为所有打开的文件分配了一个数字型的文件描述符</p></li><li><p>通过fs模块中的open()方法来分配新的文件描述符</p><ul><li>一旦被分配, 则文件描述符可以用于从文件中读取数据, 向文件中写入数据, 或者请求关于文件的信息</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用fs中的open方法来获取文件描述符</span></span><br><span class="line"><span class="comment">// open方法需要传入两个参数, 第一个参数时文件的路径, 第二个参数时一个回调函数, 回调函数中的err为错误信息, fd为文件描述符</span></span><br><span class="line">fs.open(<span class="string">&quot;./test.txt&quot;</span>, <span class="function">(<span class="params">err, fd</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过文件描述符 fd 就可以获取到对应的文件</span></span><br><span class="line">  <span class="comment">// node中有对应的接口来通过文件描述符 fd 获取到对应的文件</span></span><br><span class="line">  fs.fstat(fd, <span class="function">(<span class="params">err, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><ul><li><p>如果我们希望对文件的内容进行操作, 这个时候就可以使用fs模块中对文件读写的方法</p><ul><li>fs.readFile(path[, options], callback): 用于读取文件的内容</li><li>fs.writeFile(path[, options], callback): 用于在文件中写入内容</li></ul></li><li><p>[, options] 为可填写参数, 其作用是对读写进行一些设置, options参数一般有两项, flag属性和 encoding属性</p><ul><li>flag属性设置写入数据的方式</li><li>encoding属性设置字符编码</li></ul></li></ul><h3 id="flag-选项"><a href="#flag-选项" class="headerlink" title="flag 选项"></a>flag 选项</h3><ul><li>flag的值有很多: <a href="https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags">https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_file_system_flags</a></li><li>常用的有以下几个<ul><li>w 打开文件写入，默认值；</li><li>w+打开文件进行读写，如果不存在则创建文件；</li><li>r+ 打开文件进行读写，如果不存在那么抛出异常；</li><li>r打开文件读取，读取时的默认值；</li><li>a打开要写入的文件，将流放在文件末尾。如果不存在则创建文件；</li><li>a+打开文件以进行读写，将流放在文件末尾。如果不存在则创建文件</li></ul></li></ul><h3 id="encoding-选项"><a href="#encoding-选项" class="headerlink" title="encoding 选项"></a>encoding 选项</h3><ul><li>关于字符编码的文章：<a href="https://www.jianshu.com/p/899e749be47c">https://www.jianshu.com/p/899e749be47c</a></li><li>目前基本用的都是UTF-8编码</li><li>注意: 在文件的读取操作, 即使用 fs.readFile() 方法的时候<ul><li>如果不填写encoding选项, 此时返回的结果是Buffer(二进制编码)</li><li>所以一般使用该方法的时候都会设置encoding选项</li></ul></li></ul><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><ul><li>新建一个文件夹<ul><li>使用fs.mkdir() 或者 fs.mkdirSync() 创建一个文件夹</li><li>基本语法为 fs.mkdir(dirname, callback)</li></ul></li><li>获取文件夹中的内容<ul><li>使用 fs.readdir() 方法来获取文件夹中的内容</li><li>基本语法为 fs.readdir(dirname[, options], callback)</li></ul></li><li>文件重命名<ul><li>使用 fs.rename() 方法来给文件重命名</li><li>基本语法为 fs.rename(olddirname, newdirname, callback)</li></ul></li></ul><h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><ul><li>Node中的核心API都是基于异步事件驱动的<ul><li>在这个体系中, 某些对象(发射器(Emitters)) 发出某一个事件</li><li>我们可以监听这个事件(监听器Listeners), 并且传入回调函数, 这个回调函数会在监听到事件的时候调用</li></ul></li><li>发出事件和监听事件都是通过EventEmitter类来完成的, 它们都是属于events对象的<ul><li>emitter.on(eventName, listener): 监听事件, 也可以使用addListener, addListener和on方法是完全一样的</li><li>emitter.off(eventName, listener): 移除事件监听, 也可以使用removeListener, 这两个也是完全一样的</li><li>emitter.emit(eventName[, …args]): 发出事件, 可以携带参数</li></ul></li></ul><h3 id="events模块中常见的方法"><a href="#events模块中常见的方法" class="headerlink" title="events模块中常见的方法"></a>events模块中常见的方法</h3><ul><li>除了以上所用的常见方法外, 还有一些比较常见的方法</li><li>emitter.eventNames()：返回当前 EventEmitter对象注册的事件字符串数组；</li><li>emitter.getMaxListeners()：返回当前 EventEmitter对象的最大监听器数量，可以通过setMaxListeners()来修改，默认是10；</li><li>emitter.listenerCount(事件名称)：返回当前 EventEmitter对象某一个事件名称，监听器的个数；</li><li>emitter.listeners(事件名称)：返回当前 EventEmitter对象某个事件监听器上所有的监听器数组；</li></ul><h3 id="events方法的补充-不太常用的"><a href="#events方法的补充-不太常用的" class="headerlink" title="events方法的补充(不太常用的)"></a>events方法的补充(不太常用的)</h3><ul><li>emitter.once(eventName, listener)：事件监听一次</li><li>emitter.prependListener()：将监听事件添加到最前面</li><li>emitter.prependOnceListener()：将监听事件添加到最前面，但是只监听一次</li><li>emitter.removeAllListeners([eventName])：移除所有的监听器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Node的全局对象</title>
      <link href="2021/05/26/03-Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/05/26/03-Node%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的全局对象"><a href="#常见的全局对象" class="headerlink" title="常见的全局对象"></a>常见的全局对象</h3><ul><li>Node中给我们提供了一些全局对象, 方便我们进行一些操作<ul><li>这些全局变量很多</li><li>某些全局变量不常用</li></ul></li></ul><h3 id="特殊的全局对象"><a href="#特殊的全局对象" class="headerlink" title="特殊的全局对象"></a>特殊的全局对象</h3><ul><li>什么是特殊的全局对象<ul><li>某些全局对象可以在模块中任意使用, 但是在命令行交互中是不可以使用的</li><li>包括: __dirname, __filename, export, module, require</li></ul></li><li>__dirname: 获取当前文件所在的路径<ul><li>注意: 这个不包括文件名</li></ul></li><li>__filename: 获取当前文件所在的路径和文件名<ul><li>注意: 这个包含文件名</li></ul></li></ul><h3 id="常见的全局对象-1"><a href="#常见的全局对象-1" class="headerlink" title="常见的全局对象"></a>常见的全局对象</h3><ul><li>process对象: process提供了Node进程中的相关信息<ul><li>比如Node的运行环境, 参数信息等等</li><li>后面的项目中, 会讲到如何将一些环境变量读取到process的env中</li></ul></li><li>console对象: 这个对象提供了简单的调试控制台</li><li>定时器函数: 在Node中使用定时器有好几种<ul><li>setTimeout(): callback会在设置的毫秒后执行一次</li><li>setInterval(): callback会在每设置的后面间隔重复执行一次</li><li>setImmediate(): callbackI/O时间后的回调的”立即”执行<ul><li>这里不展开讨论setImmediate和setTimeout设置0毫秒之前的区别</li><li>实质上这两个涉及事件循环的阶段问题</li></ul></li><li>process.nextTick(): 添加到下一次tick队列中<ul><li>以后详细讲解</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定时器函数</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意如果要使用clearInterval等的清除定时器的方法则需要给对应的定时器函数赋名</span></span><br><span class="line"><span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setInterval&quot;</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;process.nextTick&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(interval)</span><br><span class="line">&#125;,<span class="number">3000</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><ul><li>global是一个全局对象, 事实上前面中提到的process, console, setTimeout等都有被放到global对象中</li></ul><h3 id="global对象和浏览器中的window对象的区别"><a href="#global对象和浏览器中的window对象的区别" class="headerlink" title="global对象和浏览器中的window对象的区别"></a>global对象和浏览器中的window对象的区别</h3><ul><li>在浏览器中，全局变量都是在window上的，比如有document、setInterval、setTimeout、alert、console等等</li><li>在Node中，我们也有一个global属性，并且看起来它里面有很多其他对象。<ul><li>但是在浏览器中执行的JavaScript代码，如果我们在顶级范围内通过var定义的一个属性，默认会被添加到window对象中</li><li>而在node中, 定义了一个变量, 它只是在当前模块中有一个变量, 不会存放在全局中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-Node参数传递</title>
      <link href="2021/05/26/02-Node%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
      <url>2021/05/26/02-Node%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<h3 id="Node的REPL"><a href="#Node的REPL" class="headerlink" title="Node的REPL"></a>Node的REPL</h3><ul><li>REPL就是Read Eval-Print Loop 的简称, 翻译为”读取-求值-输出-循环”</li><li>REPL是一个简单的, 交互式的编程环境</li><li>事实上, 浏览器的console就可以看成一个REPL</li><li>Node也提供一个REPL环境, 我们可以在其中演练简单的代码</li></ul><h3 id="Node程序传递参数"><a href="#Node程序传递参数" class="headerlink" title="Node程序传递参数"></a>Node程序传递参数</h3><ul><li>正常情况下执行一个node程序, 通过 node + 对应的js文件 命令行即可<ul><li>比如: node index.js</li></ul></li><li>但是, 在某些情况下执行node程序的过程中, 我们希望给node传递一些参数<ul><li>比如: node index.js env=development xiaoLam</li></ul></li><li>如果我们通过上面的命令行来执行程序, 就意味着我们需要在程序中获取到传递过来的参数<ul><li>传递过来的参数其实是存放在process的内置全局对象中的</li><li>如果我们直接打印这个内置全局对象, 就会发现它里面包含很多信息</li><li>比如node的版本, 操作的系统等等</li><li>我们传递过来的参数就存放在一个名为 argv的数组中<ul><li>这个数组里面就包含了我们传来的参数</li></ul></li></ul></li></ul><h3 id="为什么叫argv呢"><a href="#为什么叫argv呢" class="headerlink" title="为什么叫argv呢?"></a>为什么叫argv呢?</h3><ul><li>在C/C++程序中的main函数中, 实际上可以获取到两个参数<ul><li>argc: argument counter的缩写, 意为传递参数的个数</li><li>argv: argument vector的缩写, 意为传入的具体参数<ul><li>vector翻译过来式矢量的意思, 在程序中表示的是一种数据结构</li><li>在C++, Java中都有这种数据结构, 是一种数组结构</li><li>在JavaScript中也是一个数组, 里面存储一些参数信息</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(process.argv);</span><br><span class="line"></span><br><span class="line">process.argv.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Node的输出"><a href="#Node的输出" class="headerlink" title="Node的输出"></a>Node的输出</h3><ul><li>console.log<ul><li>最常用的输出内容的方式: console.log</li></ul></li><li>console.clear<ul><li>清空控制台的打印: console.clear</li></ul></li><li>console.trace<ul><li>打印函数的调用栈: console.trace</li></ul></li><li>还有很多其他的console方法<ul><li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/console.html">https://nodejs.org/dist/latest-v14.x/docs/api/console.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-认识Node</title>
      <link href="2021/05/26/01-%E8%AE%A4%E8%AF%86Node/"/>
      <url>2021/05/26/01-%E8%AE%A4%E8%AF%86Node/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node"></a>什么是node</h3><ul><li>官方定义:<ul><li>Node.js是一个基于V8 JavaScript引擎的JavaScript运行环境</li></ul></li><li>这个定义是很笼统的<ul><li>首先什么是JavaScript的运行环境呢?</li><li>为什么JavaScript需要特别的运行环境呢?</li><li>什么是JavaScript引擎呢?</li><li>什么是V8?</li></ul></li></ul><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><ul><li>浏览器是如何运行JavaScript代码的?</li><li>不同的浏览器由不同的浏览器内核组成<ul><li>Gecko: 早期Netscape和Mozilla Firefox浏览器使用</li></ul><ul><li>Trident: 微软开发, IE浏览器使用, 但是现在Edge浏览器已经转向Blink了</li><li>Webkit: 苹果基于KHTML开发, 开源的, 用于Safari, Google Chrome之前也使用</li><li>Blink: 是Webkit的一个分支, Google开发, 目前应用于Google Chrome, Edge, Opera等</li></ul></li><li>事实上, 浏览器内核指的就是浏览器的排版引擎<ul><li>排版引擎, 也称为浏览器引擎, 页面渲染引擎或者样板引擎</li></ul></li></ul><h3 id="渲染引擎工作过程"><a href="#渲染引擎工作过程" class="headerlink" title="渲染引擎工作过程"></a>渲染引擎工作过程</h3><ul><li>页面渲染的这个执行过程中, 当HTML解析的时候遇到JavaScript标签, 浏览器会停止解析HTML, 而去加载和执行JavaScript代码</li><li>为什么不直接异步加载执行JavaScript代码, 而是样停止执行HTML代码呢?<ul><li>这个是因为JavaScript代码可以操作DOM</li><li>所以浏览器希望将HTML解析的DOM和JavaScript操作之后的DOM放在一起来生成最终的DOM树, 而不是频繁的去生成新的DOM树</li></ul></li><li>而JavaScript代码就是由浏览器中的JavaScript引擎来执行的</li></ul><h3 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h3><ul><li>为什么需要JavaScript引擎<ul><li>实际上JavaScript代码无论是交给浏览器还是Node去执行, 最后都是被CPU执行的</li><li>但是CPU只认识特定的指令集, 这个指令集实际上就是机器语言</li><li>所以我们需要JavaScript引擎将JavaScript代码翻译成CPU指令来执行</li></ul></li><li>比较常见的JavaScript引擎<ul><li>SpiderMonkey: 第一款JavaScript引擎, 由Brendan Eich开发(JavaScript作者)</li><li>Chakra: 微软开发, 用于IT浏览器</li><li>JavaScriptCore: WebKit中的JavaScript引擎, 苹果公司开发</li><li>V8: Google开发的强大的JavaScript引擎, Chrome牛逼之处</li></ul></li></ul><h3 id="WebKit内核"><a href="#WebKit内核" class="headerlink" title="WebKit内核"></a>WebKit内核</h3><ul><li>WebKit内核实际上是由两个部分来组成的<ul><li>WebCore: 负责HTML解析, 布局, 渲染等等相关的工作</li><li>JavaScriptCore: 解析, 执行JavaScript代码</li></ul></li><li>小程序中编写的JavaScript代码就是由JavaScriptCore执行的</li></ul><h3 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h3><ul><li>官方对V8引擎的定义<ul><li>V8是用C++编写的Google开源高性能JavaScript和WebAssembly引擎, 它用于Chrome和Node.js等</li><li>V8引擎实现了ECMAScript和WebAssembly(另外一门前端语言), 并在Window7或者更高版本, macOS和使用x64, IA-32, ARM或MIPS处理器的Linux系统上运行</li><li>V8可以独立运行, 也可以嵌入到任何C++应用程序中</li></ul></li><li>V8引擎的强大之处在于<ul><li>它可以将一个多次调用的函数(一般来说是会转换为字节码运行), 标记为热点函数, 这个热点函数会转换为优化的机器码, 机器码的运行比字节码更快, 更符合计算机的运行规则</li><li>如果, 热点函数中的参数类型发生了变化, 这个热点函数又会被还原为原来的函数</li><li>第二个强大的原因是, V8的内存回收模块</li></ul></li></ul><h3 id="回顾-Node-js是什么"><a href="#回顾-Node-js是什么" class="headerlink" title="回顾: Node.js是什么"></a>回顾: Node.js是什么</h3><ul><li>通过上面的解析, 已经很容易地理解Node.js是什么了</li><li>Node.js是基于V8引擎来执行JavaScript代码, 但是不仅仅只有V8引擎, Nodejs还有很多其他的模块来进行其他的操作的(比如文件系统的读取写入, 网络IO, 加密, 压缩解压文件等操作)</li></ul><h3 id="浏览器和Node-js的区别"><a href="#浏览器和Node-js的区别" class="headerlink" title="浏览器和Node.js的区别"></a>浏览器和Node.js的区别</h3><ul><li>浏览器不仅仅有解析JavaScript代码的模块, 还有解析渲染HTML/CSS的模块</li><li>Node.js就没有解析和渲染HTML/CSS的模块</li><li>Node.js和浏览器共有的模块是中间层和它们的操作系统的模块</li></ul><h3 id="NodeJS的架构"><a href="#NodeJS的架构" class="headerlink" title="NodeJS的架构"></a>NodeJS的架构</h3><h3 id="JavaScript代码的执行"><a href="#JavaScript代码的执行" class="headerlink" title="JavaScript代码的执行"></a>JavaScript代码的执行</h3><ul><li>一个js文件, 里面存放JavaScript代码, 如何去执行它呢?</li><li>目前我们知道有两种方式去执行它<ul><li>将代码交给浏览器去执行</li><li>将代码载入到node环境中执行</li></ul></li><li>如果我们希望把代码交给浏览器去执行<ul><li>需要通过让浏览器加载, 解析html代码, 所以需要创建一个html文件</li><li>在html文件中通过script标签, 来引入这个js文件</li><li>当浏览器遇到script标签的时候, 就会根据src加载, 并执行对应的js代码</li></ul></li><li>如果我们希望把js文件交给node来执行<ul><li>首先电脑上需要安装nodeJS环境, 安装过程中会自动配置环境变量</li><li>然后就可以通过终端命令node js文件名的方式来载入和执行对应的js文件</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6常用语法规范</title>
      <link href="2021/05/25/ES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/"/>
      <url>2021/05/25/ES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h3 id="let和var"><a href="#let和var" class="headerlink" title="let和var"></a>let和var</h3><ul><li>以后定义变量的时候不要用var了, 尽量使用ES6语法的let</li><li>var的设计有错误, 但是这种错误不好去修复和移除, 于是就有了新的关键字let</li><li>let是更完美的var</li><li>let的完美之处在于拥有块级作用域</li><li>var是没有作用域的</li><li>变量作用域: 就是指变量在什么范围内是可用的</li><li>if和for是没有块级作用域的,造成的问题是, if 和for 大括号中的变量可以被外面访问到， 所以ES5之前都是借助闭包(function的作用域)来解决外面可以访问内部变量的问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 问题</span></span><br><span class="line"><span class="comment">// 需求是点击按钮的时候, 输出该按钮的索引号</span></span><br><span class="line"><span class="comment">// 假如有4个按钮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以上代码并不能满足需求, 每次点击按钮的时候输出的都是5</span></span><br><span class="line"><span class="comment">// 因为输出的i因为没有块级作用域,被for中的i++改变了</span></span><br></pre></td></tr></table></figure><ul><li>以前解决这种问题使用的是引入第三变量记录每一个btn的索引, 或者使用闭包, 用function的作用域来限制i的访问</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; btns.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; <span class="comment">// 这个i是一个形参</span></span><br><span class="line">    btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)  <span class="comment">// 函数里面的i就有作用域了，不会被外面访问到</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)(i) <span class="comment">// 这个i是每一次传入的实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有了let后，简直爽到！</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 这里的i就不需要借助function的作用域了!</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><ul><li>const关键字定义的变量不可以再次赋值, 称为常量</li><li>当我们的变量不需要再赋值的时候, 用const来定义可以保证安全性, 而且不需要内存区监听这个变量, 提高效率</li><li>建议在开发中优先使用const定义变量, 在遇到需要重新赋值的标识符才使用let</li><li>const定义的标识符不能重新赋值</li><li>const定义标识符的时候, 必须同时赋值</li><li>常量的定义是指向的对象不能被改变, 而对象内部的属性可以被改变</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意点3, 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">      <span class="attr">tall</span>: <span class="number">170</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部的属性可以被修改</span></span><br><span class="line">    obj.name = <span class="string">&quot;xiaoLamLam&quot;</span>;</span><br><span class="line">    obj.age = <span class="number">21</span>;</span><br><span class="line">    obj.tall = <span class="number">171</span>;</span><br></pre></td></tr></table></figure><h3 id="ES6-对象字面量增强写法"><a href="#ES6-对象字面量增强写法" class="headerlink" title="ES6 对象字面量增强写法"></a>ES6 对象字面量增强写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">const</span> tall = <span class="number">1.70</span>;</span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: name,</span><br><span class="line">  <span class="attr">age</span>: age,</span><br><span class="line">  <span class="attr">tall</span>: tall,</span><br><span class="line">  <span class="attr">run</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I can run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 属性增强写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  tall</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 函数增强写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I can run&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6-for…in-循环遍历数组"><a href="#ES6-for…in-循环遍历数组" class="headerlink" title="ES6 for…in 循环遍历数组"></a>ES6 for…in 循环遍历数组</h3><ul><li>for(let index in arr) {}  这里的index拿到的是arr里面数据的下标</li><li>与for(let i =0; i &lt;arr.length; i++) 其实很相似, 就是代码更加简洁了</li></ul><h3 id="ES6-for…of-循环遍历数组"><a href="#ES6-for…of-循环遍历数组" class="headerlink" title="ES6 for…of 循环遍历数组"></a>ES6 for…of 循环遍历数组</h3><ul><li>for(let item of arr) {} 这里的item拿到的式arr中的数据</li></ul><h3 id="编程范式-命令式编程-声明式编程"><a href="#编程范式-命令式编程-声明式编程" class="headerlink" title="编程范式: 命令式编程/声明式编程"></a>编程范式: 命令式编程/声明式编程</h3><h3 id="编程范式-面向对象编程-第一公民-对象-面向函数编程-第一共鸣-函数"><a href="#编程范式-面向对象编程-第一公民-对象-面向函数编程-第一共鸣-函数" class="headerlink" title="编程范式: 面向对象编程(第一公民: 对象) / 面向函数编程(第一共鸣: 函数)"></a>编程范式: 面向对象编程(第一公民: 对象) / 面向函数编程(第一共鸣: 函数)</h3><h3 id="高阶函数-高阶函数的阅读性很强"><a href="#高阶函数-高阶函数的阅读性很强" class="headerlink" title="高阶函数 高阶函数的阅读性很强"></a>高阶函数 高阶函数的阅读性很强</h3><ul><li>filter/map/reduce</li><li>filter<ul><li>filter中传入一个回调函数, 这个回调函数有一个要求, 必须返回一个Boolean值</li><li>当这个boolean值为true时, 函数内部会自动将这个回调的数据添加到一个新的数组中 这个新数组要定义一个数组来接</li><li>当这个boolean值为false时, 函数内部会过滤掉这次的数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">445</span>,<span class="number">412</span>,<span class="number">4546</span>,<span class="number">1231</span>,<span class="number">44</span>];</span><br><span class="line"><span class="keyword">let</span> newArr1 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">100</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr1);</span><br></pre></td></tr></table></figure><ul><li>map<ul><li>map中也是传入一个回调函数</li><li>对数组中的每一项都运行传入的函数, 返回由每次函数调用的结果构成的数组 也定义一个数组来接</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newArr2 = newArr1.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr2);</span><br></pre></td></tr></table></figure><ul><li>reduce方法<ul><li>reduce()中接收两个参数, 第一个参数是会对每一项都会运行的归并函数, 第二个参数是可选的参数,为归并起点的初始值</li><li>归并函数可以接收四个参数, 第一个参数是上一个归并值, 第二个参数是当前项, 第三个参数是当前项的索引值, 第四个参数是数组本身</li><li>函数返回的任何值都会作为下一次调用同一个函数的第一个参数</li><li>如果reduce()中没有传入可选的第二个参数作为归并起点值, 那么第一次迭代将从数组的第二项开始,因此第一次迭代传给归并函数的第一个参数是数组的第一项,第二个参数是数组的第二项, 所以第二个参数通常会传入一个0</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = newArr2.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + cur;</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><ul><li>以上的高级函数用法可以使用链式编程写法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum2 = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item &lt; <span class="number">100</span>;</span><br><span class="line">&#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, cur</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum2);</span><br></pre></td></tr></table></figure><ul><li>配合箭头函数可以一行代码写完</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum3 = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item &lt; <span class="number">100</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>).reduce(<span class="function">(<span class="params">preValue,cur</span>) =&gt;</span> preValue + cur,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum3);</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 基本使用</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">参数列表</span>) =&gt;</span> &#123;函数体&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 参数问题</span></span><br><span class="line"><span class="comment">// 2.1 放入多个参数</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2 &#125;</span><br><span class="line"><span class="comment">// 2.2 放入一个参数 (可以将小括号省略掉)</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function"><span class="params">num</span> =&gt;</span> &#123; <span class="keyword">return</span> num * <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 函数体中代码数量问题</span></span><br><span class="line"><span class="comment">// 3.1有多行代码</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第二行代码&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;第三行代码&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 3.2 只有一行代码 (花括号和return可以省略)</span></span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;省略花括号&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> test = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure><h3 id="什么时候使用箭头函数"><a href="#什么时候使用箭头函数" class="headerlink" title="什么时候使用箭头函数"></a>什么时候使用箭头函数</h3><ul><li>在普通的情况下, 使用箭头函数的情况并不多</li><li>在当我们将一个函数作为一个参数传入另外一个函数的情况下, 使用箭头函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="箭头函数中的this指向问题"><a href="#箭头函数中的this指向问题" class="headerlink" title="箭头函数中的this指向问题"></a>箭头函数中的this指向问题</h3><ul><li>普通函数中的this, 是谁调用指向谁</li><li>箭头函数中的this, 是指向最近一层作用域的this<ul><li>也就是说, 箭头函数中的this, 会想外层作用域中,一层层查找this, 直到找到有this的定义</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 这里是因为setTimeout是由window调用的</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为test中的this是指向obj对象的</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// obj对象</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// obj对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h3><ul><li>Promise是ES6中的一个非常重要和好用的特性</li><li>Promise是做什么的<ul><li>Promise是一个异步编程的解决方案</li></ul></li><li>在什么时候我们会处理异步事件呢?<ul><li>在网络请求中我们会大量处理异步事件</li><li>比如, 我们封装了一个网络请求函数, 向服务器请求数据是不能立即拿到结果的</li><li>所以我们往往会传入另外一个函数, 在数据请求成功的时候, 将数据通过传入的函数回调出去, 简单来说就是在网络请求函数中嵌套另外一个函数</li><li>如果只是一个简单的网络请求, 那么这种方案还是可行的</li></ul></li><li>但是, 当网络请求非常复杂的时候, 就会出现回调地狱</li><li>回调地狱是指: 如果很多的异步操作需要安装顺序来的时候, 就需要回调函数的嵌套, 如果过多的函数嵌套会造成回调地狱, 这样不利于后期代码的维护</li><li>可以使用promise对象来解决这个问题</li></ul><h3 id="Promise的基本语法"><a href="#Promise的基本语法" class="headerlink" title="Promise的基本语法"></a>Promise的基本语法</h3><ul><li>创建一个Promise实例</li><li>在这个实例中传入一个函数, 这个函数包含两个参数, resolve 和 reject</li><li>resolve 和 reject 分贝是两个函数</li><li>resolve函数会在异步操作执行成功后调用, 这个函数中也可以传入参数, 一般是异步操作中获得的数据data</li><li>reject函数会在异步操作执行失败后调用, 这个函数中也是可以传入参数的, 一般是异步操作失败后的错误信息err</li><li>在调用resolve函数后, 后续的then函数会被回调, then中还是传入一个函数, 函数中也是传入一个参数data, 这个data就是resolve中的data数据</li><li>在调用reject函数后, 后续的catch函数会被回调, catch中也是传入一个函数, 函数中也是传入一个参数err, 这个err就是reject中的err错误信息</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;再见再见&quot;</span>)</span><br><span class="line">      reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实可以简单理解为</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行异步操作</span></span><br><span class="line">  <span class="comment">// 异步操作成功后调用</span></span><br><span class="line">  resolve(data) <span class="comment">// data为操作成功后传入的数据</span></span><br><span class="line">  <span class="comment">// 异步操作失败后调用</span></span><br><span class="line">  reject(err) <span class="comment">// err为操作失败后传入的错误信息</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用resolve后会进入这个函数中进行下面的操作</span></span><br><span class="line">  <span class="comment">// 这个函数中的data是由resolve中传过来的data</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 调用reject后会进入这个函数中进行下面的操作</span></span><br><span class="line">  <span class="comment">// 这个函数中的err错误信息是从reject中传过来的err</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise补充知识点"><a href="#Promise补充知识点" class="headerlink" title="Promise补充知识点"></a>Promise补充知识点</h3><ul><li>Promise中的then回调函数其实可以传入两个参数的</li><li>这两个参数都是函数, 第一个函数会在resolve执行后回调, 第二个函数会在reject执行后回调, 这样就省略了catch回调函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">          reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// then传入两个函数, 第一个函数会在resolve执行后调用, 第二个含税会在reject执行后调用</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="comment">// 这样写就省略了catch回调函数</span></span><br></pre></td></tr></table></figure><h3 id="Promise的链式操作"><a href="#Promise的链式操作" class="headerlink" title="Promise的链式操作"></a>Promise的链式操作</h3><ul><li>可以在then回调函数中 return一个new Promise 来进行下一步的异步操作</li><li>如果每次执行成功想要进行下一步异步操作的话, 都要return 一个new Promise, 很麻烦, 所以ES6提供了简写方法和超级简写方法</li><li>如果想要进入catch回调函数的话, 就要使用 return Promise.reject(“错误信息”) 或者 throw “错误信息”</li><li>具体看代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次进行下一步操作的时候都要return 一个new Promise很麻烦, 所以ES6提供简写模式</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span></span><br><span class="line">  <span class="comment">// return Promise.resolve(res) // 简写模式</span></span><br><span class="line">  <span class="comment">// 如果是要进入catch回调的话, 就用 return Promise.reject()</span></span><br><span class="line">  <span class="comment">// return Promise.reject(&quot;错误错误&quot;)</span></span><br><span class="line">  <span class="comment">// 或者使用 throw &quot;错误信息&quot;</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&quot;错误错误&quot;</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行成功后每次都要写Promise.resolve, ES6觉得也很麻烦, 所以还可以更简写</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;你好你好&quot;</span>)</span><br><span class="line">    reject(<span class="string">&quot;错误错误&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第一层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;111&quot;</span></span><br><span class="line">  <span class="keyword">return</span> res <span class="comment">// 超级简写模式, 只能在then中使用</span></span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第二层十行代码&quot;</span>);</span><br><span class="line">  res += <span class="string">&quot;222&quot;</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res + <span class="string">&quot;第三层十行代码&quot;</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise中的all方法"><a href="#Promise中的all方法" class="headerlink" title="Promise中的all方法"></a>Promise中的all方法</h3><ul><li>如果有一个需求, 需要两个异步请求都完成了, 才能执行</li><li>如果用普通的方法</li></ul><ul><li>定义第三变量, 来记录异步请求是否完成</li><li>定义一个函数, 在进入函数体之前通过第三变量来判断异步请求是否都完成了, 如果都完成了就执行</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result2 = <span class="literal">false</span>;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;url1&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    result1 = <span class="literal">true</span>;</span><br><span class="line">    resulthandle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;url2&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    result2 = <span class="literal">true</span>;</span><br><span class="line">    resulthandle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resulthandle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (result1 &amp;&amp; result2) &#123;</span><br><span class="line">    <span class="comment">// 执行需求的操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果使用Promise.all方法就可以轻松完成需求</li><li>Promise.all() 方法要求传入一个数组, 这个数组包含你想要进行的异步操作</li><li>当数组中的异步操作都完成的时候会调用then回调函数, 这个then中传入一个函数, 函数中又一个参数</li><li>这个函数的参数是一个数组, 数组中包含的是异步操作中返回的data数据</li><li>如果有异步请求失败的话就会进入catch回调函数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;url1&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">      <span class="function"><span class="title">success</span>(<span class="params">data1</span>)</span> &#123;</span><br><span class="line">        resolve(data1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;url2&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">      <span class="function"><span class="title">success</span>(<span class="params">data2</span>)</span> &#123;</span><br><span class="line">        resolve(data2)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 这个result就是一个数组, 数组中是异步操作中返回的数据data</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 如果有异步操作失败的话, 就会进入catch, err是返回的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="for-in-和-for-of的区别"><a href="#for-in-和-for-of的区别" class="headerlink" title="for-in 和 for-of的区别"></a>for-in 和 for-of的区别</h3><ul><li>for-in 遍历的item是 元素的键</li><li>for-of 遍历的item是 元素的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 前端小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化</title>
      <link href="2021/05/25/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>2021/05/25/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript原始功能"><a href="#JavaScript原始功能" class="headerlink" title="JavaScript原始功能"></a>JavaScript原始功能</h3><ul><li>在早期的网页开发时期, js的代码很少, 都是直接将js代码写到html代码中的script标签中就可以了</li><li>随着ajax异步请求的出现, 慢慢形成了前后端分离<ul><li>用户需求越来越多, 代码与日俱增</li><li>为了应对代码量的剧增, 我们将代码写到多个js文件中, 进行维护</li><li>但是这样容易引起变量泄露等等的严重问题</li><li>可以使用匿名函数闭包来解决变量泄露的问题<ul><li>但是这样又引入了另外的一个问题, 代码不能复用了</li></ul></li></ul></li></ul><h3 id="如何使用闭包防止变量泄露"><a href="#如何使用闭包防止变量泄露" class="headerlink" title="如何使用闭包防止变量泄露"></a>如何使用闭包防止变量泄露</h3><ul><li>原理<ul><li>利用函数自身的块级作用域特性, 函数内部的变量, 外部无法访问</li><li>将想要暴露出去的变量和函数, 打包在一个对象中</li><li>通过return 的方法 将打包好的对象暴露出去</li><li>在函数的外面用一个变量接收这一个对象</li><li>在其他的模块中引用</li></ul></li><li>具体代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ModuleA = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这些是函数内部的变量和函数, 外部无法访问</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 将变量和函数放入变量中</span></span><br><span class="line">  obj.sum = sum;</span><br><span class="line">  obj.flag = flag;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将这个对象暴露出去</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码是在其他模块中引用</span></span><br><span class="line">ModuleA.sum() <span class="comment">// 这样就调用了ModelA的sum方法</span></span><br><span class="line">ModuleA.flag;  <span class="comment">// 这样就访问了ModelA的flag变量</span></span><br></pre></td></tr></table></figure><ul><li>以上的代码就是模块最基础的封装了, 事实上模块的封装还有很多高级的写法</li><li>很幸运的是, 前端模块化的开发已经又很多的既有规范, 已经对应的实现方案</li></ul><h3 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h3><ul><li>CommonJS AMD CMD 还有ES6的Modules</li><li>开发常用的是NodeJS中的CommonJS 和 ES6中的Modules</li></ul><h3 id="CommonJS模块化规范"><a href="#CommonJS模块化规范" class="headerlink" title="CommonJS模块化规范"></a>CommonJS模块化规范</h3><ul><li>模块化规范都是围绕两个核心来进行的, 导出和导入</li><li>CommonJS的导出和导入基本雏形</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonJS的导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">flag</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS的导入</span></span><br><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123;flag,test&#125; = <span class="built_in">require</span>(<span class="string">&quot;module&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6的模块化"><a href="#ES6的模块化" class="headerlink" title="ES6的模块化"></a>ES6的模块化</h3><ul><li>在引入js文件的script标签中, 定义type属性, 值为module, 来模块化js文件</li><li>在各个模块中通过export导出信息, import导入信息</li><li>注意事项<ul><li>导入默认的信息时, 不需要加大括号, 而且名字可以自定义</li><li>通过通配符 * 导入所有被导出的信息 import * as 自定义名字 from “模块地址”<ul><li>这个自定义名字就是 * 的别名, 方便后续的使用</li><li>实际上就是将 ModuleA 中导出的所有信息 * , 集合到 自定义名字 这个对象中</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ES6中的模块化, 引入模块的script标签必须添上值为module的type类型属性,使js文件模块化 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在添加上值为module的type类型属性后, 各个模块之间的就不会有变量泄露的问题 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ModuleA.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ModuleB.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模块A ModuleA</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这个模块中定义变量, 函数, 类等</span></span><br><span class="line"><span class="comment">// 1. 通过对象的形式导出</span></span><br><span class="line"><span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;flag, name, sum&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 单独形式导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我在跑&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 导出一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">walk</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我在走&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 默认导出 default</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="comment">// 注意一个模块内只能由一个默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> me;</span><br></pre></td></tr></table></figure><ul><li>模块B ModuleB</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这个模块中导入ModuleA中的变量 函数 类 等</span></span><br><span class="line"><span class="comment">// 通过import导入</span></span><br><span class="line"><span class="keyword">import</span> &#123;flag, name,sum&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(flag);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;age, run&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line">run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;Person&#125; <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xiaoLam = <span class="keyword">new</span> Person();</span><br><span class="line">xiaoLam.walk();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入默认导出</span></span><br><span class="line"><span class="comment">// 导入默认的信息时, 不需要加大括号, 而且名字可以自定义</span></span><br><span class="line"><span class="keyword">import</span> you <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(you);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过通配符 * 导入所有被导出的信息 import * as 自定义名字 from &quot;模块地址&quot;;</span></span><br><span class="line"><span class="comment">// 这个自定义名字就是 * 的别名, 方便后续的使用</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> objA <span class="keyword">from</span> <span class="string">&quot;./ModuleA.js&quot;</span>;</span><br><span class="line"><span class="comment">// 实际上就是将 ModuleA 中导出的所有信息, 集合到objA这个对象中</span></span><br><span class="line"><span class="built_in">console</span>.log(objA);</span><br><span class="line"><span class="built_in">console</span>.log(objA.name);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> JS模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack项目打包工具详解</title>
      <link href="2021/05/25/webpack%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/webpack%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="认识webpack"><a href="#认识webpack" class="headerlink" title="认识webpack"></a>认识webpack</h3><ul><li><p>webpack是什么</p><ul><li>本质上来说, webpack是一个现代的javaScript应用的静态模块打包工具</li><li>实质上, webpack就是 将代码进行模块化和打包的工具</li></ul></li><li><p>前端模块化</p><ul><li>前端模块化的一些方案有, AMD CMD CommonJS ES6</li><li>在ES6之前, 我们想要进行模块化开发, 就必须借助于其他的工具进行</li><li>而且在通过模块化开发完成项目后, 还需要处理模块和模块之间的各种依赖, 进行整合打包</li><li>而webpack和其中一个核心就是帮助我们进行模块化开发, 并且帮助我们处理模块之间的依赖关系</li><li>不仅仅时JS文件, CSS, 图片, json文件等等都可以被webpack中当作模块来使用</li><li>这就是webpack中模块化的概念</li></ul></li><li><p>什么是打包</p><ul><li>webpack可以帮助我们进行模块化, 并且处理模块之间的各种复杂关系</li><li>打包就是将webpack中的各种资源模块进行打包, 合并成一个或者多个包(bundle)</li><li>在打包的过程中,还可以对资源进行处理, 比如压缩图片, scss转换为css, 将ES6语法转化为ES5语法进行兼容, 将TypeScript 转换成JavaScript语法等等的操作</li><li>这种打包的操作, grunt/gulp 也可以完成, 他们有什么区别呢?</li></ul></li><li><p>webpack和grunt/gulp的区别</p><ul><li><p>grunt/gulp 的核心是 task</p><ul><li>我们可以配置一系列的task代码, 并且定义task要处理的事物(ES6转化, ts转化, 图片压缩, scss转化等)</li><li>然后让grunt/gulp 来依次执行task, 并且让整个流程自动化</li><li>所以grunt/gulp 也被称为前端自动化任务管理工具</li></ul></li><li><p>什么时候用grunt/gulp 呢?</p><ul><li>工程模块依赖非常简单, 甚至没有用到模块化的概念</li><li>只需要进行简单的合并, 压缩, 就只使用grunt/gulp就可以了</li><li>当项目使用了模块化管理, 而且模块之间的相互依赖非常强, 就要使用功能更加强大的webpack了</li></ul></li><li><p>所以grunt/gulp 和 webpack的区别</p><ul><li>grunt/gulp 更加强调的是前端流程的自动化, 模块化并不是它的和兴</li><li>webpack更加强调的是模块化开发管理, 而文件压缩合并, 代码预处理等功能是附加功能</li></ul></li></ul></li></ul><h3 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h3><ul><li>安装webpack需要安装Node.js 建议使用8.0以上的Node.js版本</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--查看自己的node版本,终端输入命令行 --&gt;</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><ul><li>全局安装 webpack (这里使用的版本是3.6.0 因为vue cli2 依赖这个版本, 如果版本过高, webpack底层代码被隐藏起来不利于学习, 所以这里使用3.6.0版本)</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install webpack@3.6.0 -g</span><br></pre></td></tr></table></figure><ul><li>局部安装webpack (后续需要)<ul><li>–save-dev 是开发时依赖, 项目打包后不需要继续使用, -save 是运行时依赖, 项目打包后也是要继续使用的</li><li>一般webpack时 开发时依赖安装 </li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 对应的目录路径</span><br><span class="line">npm install webpack@3.6.0 --save-dev</span><br></pre></td></tr></table></figure><ul><li>为什么全局安装后, 还需要局部安装?<ul><li>在终端直接执行webpack命令, 使用的是全局安装的webpack</li><li>当在package.json中定义script时, 其中包含了webpack命令, 那么使用的是局部webpack</li></ul></li></ul><h3 id="准备工作-文件和文件夹的创建"><a href="#准备工作-文件和文件夹的创建" class="headerlink" title="准备工作, 文件和文件夹的创建"></a>准备工作, 文件和文件夹的创建</h3><ul><li>文件和文件夹解析<ul><li>dist 文件夹, 里面的代码是经过处理的, 最终上传到服务器的代码</li><li>src 文件夹, 里面的代码源码, 所有的源码都应该在src文件夹里面<ul><li>main.js : 项目的入口文件</li><li>其他的js文件, 通常一个js文件就是一个模块</li></ul></li><li>index.html文件, 浏览器打开展示的首页html</li><li>package.json: 通过npm init 生成的, 里面记录了这个项目所需要的包的信息</li></ul></li><li>注意作为入口的文件, 不需要放到文件夹中, 放在文件夹外面是最合适的</li></ul><h3 id="JS文件的打包"><a href="#JS文件的打包" class="headerlink" title="JS文件的打包"></a>JS文件的打包</h3><ul><li>现在的js文件中使用了模块化的方式进行开发, 是不可以直接使用的<ul><li>因为直接在index.html文件中引入模块化开发的js文件, 浏览器是不会识别里面的模块化代码的</li><li>另外, 项目中有很多的js模块文件, 如果一个一个地按照顺序在html文件中引用是非常麻烦, 而且不利于后期的维护和管理的</li></ul></li><li>使用webpack工具, 对多个js文件进行打包<ul><li>webpack是一个模块化打包工具, 所以它支持我们在代码中写模块化代码, 而且是各种各样的模块化, 混合使用都可以</li><li>处理完各个模块之间的关系后, 只需要将多个js打包到一个js文件中, 引入的时候就变得非常方便了</li><li>打包的命令行</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webpack ./src/main.js ./dist/bundle.js</span><br><span class="line">&lt;!-- 这段代码的意思是将src目录下的main.js和其导入的所有模块文件, 打包到dist目录下的一个叫bundle.js的文件中, 如果没有这个文件, 则会自动创建该文件 --&gt;</span><br></pre></td></tr></table></figure><ul><li><p>使用打包后的文件</p><ul><li>打包后会在dist文件夹下生成一个bundle.js文件<ul><li>这个文件是webpack处理了项目直接文件依赖生成的一个js文件, 现在只需要将这个js文件在index.html中引入即可</li></ul></li></ul></li><li><p>具体代码如下</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js的代码</span></span><br><span class="line"><span class="comment">// 1. 使用CommonJS规范 导入信息</span></span><br><span class="line"><span class="keyword">const</span> &#123;sum, mul&#125; = <span class="built_in">require</span>(<span class="string">&quot;./mathUtils.js&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"><span class="built_in">console</span>.log(mul(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用ES6规范 导入信息</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, age, height&#125; <span class="keyword">from</span> <span class="string">&quot;./info.js&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用webpack 打包模块</span></span><br><span class="line"><span class="comment">// 终端命令行输入 webpack 路径1 路径2</span></span><br><span class="line"><span class="comment">// 路径1 为想要打包的模块main 代码</span></span><br><span class="line"><span class="comment">// 路径2 为目标的js</span></span><br><span class="line"><span class="comment">// 例如 webpack ./src/main.js ./dist/bundle.js</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mathUtils.js 的代码</span></span><br><span class="line"><span class="comment">// 1. 使用CommonJS规范</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CommonJS规范导出信息</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;sum, mul&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// info.js 的代码</span></span><br><span class="line"><span class="comment">// 2. 使用ES6 规范导出信息</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;xiaoLam&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> height = <span class="number">1.88</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html 的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="入口和出口"><a href="#入口和出口" class="headerlink" title="入口和出口"></a>入口和出口</h3><ul><li>如果每次使用webpack的命令都需要写上入口和出口作为参数, 这样是很麻烦的, 特别是真实开发的时候这些参数都很长</li><li>解决方法, 在项目根目录中创建一个叫 webpack.config.js 的文件<ul><li>在文件内编写入口和出口的参数</li><li>然后再命令行中直接输入 webpack 命令, node就会找到这个文件按照里面编写好的的参数来运行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js 的代码</span></span><br><span class="line"><span class="comment">// path模块是node中的内置模块, 是用于处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 编写入口</span></span><br><span class="line">  <span class="attr">entry</span> : <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 编写出口, output 是一个对象, 对象包含两个属性, path 路径 和fliename 文件名, 其中path路径必须是绝对路径</span></span><br><span class="line">  <span class="comment">// path绝对路径, 借助了node中的内置模块 path 的resolve方法 这个方法是用来拼接路径的</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>), <span class="comment">// __dirname 指的是当前文件的绝对路径</span></span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span> <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h3><ul><li>目前使用的webpack都是全局安装的webpack, 那么就会有问题出现了<ul><li>一般来说, 一个项目往往依赖某个特定版本的webpack, 全局的版本可能与当前项目的webpack版本不一致, 导出打包的时候就会出现问题</li><li>所以通常来说, 一个项目都有自己的局部webpack</li></ul></li><li>所以要安装局部webpack<ul><li>在项目根目录的路径下, 命令行输入 npm install <a href="mailto:&#x77;&#x65;&#x62;&#x70;&#x61;&#x63;&#107;&#x40;&#x33;&#x2e;&#54;&#x2e;&#x30;">&#x77;&#x65;&#x62;&#x70;&#x61;&#x63;&#107;&#x40;&#x33;&#x2e;&#54;&#x2e;&#x30;</a> –save-dev (–save-dev 就是局部安装, 并且是开发依赖的意思)</li></ul></li><li>运行局部webpack<ul><li>只要是在终端中直接输入 webpack 命令 都是运行的全局安装的webpack</li><li>如何运行局部webpack呢?<ul><li>第一种方法, 通过路径运行启动webpack打包<ul><li>在项目的根目录下 命令行输入 node_modules/.bin/webpack 启动webpack打包 (太繁琐不推荐)</li></ul></li><li>第二种方法 package.json中定义启动</li></ul></li></ul></li></ul><h3 id="在package-json中定义启动局部安装的webpack"><a href="#在package-json中定义启动局部安装的webpack" class="headerlink" title="在package.json中定义启动局部安装的webpack"></a>在package.json中定义启动局部安装的webpack</h3><ul><li>在package.json文件中的 scripts中定义自己的执行脚本</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="comment">// 下面这个就是自定义的执行脚本</span></span><br><span class="line">    <span class="comment">// 这句话的意思是 在命令行中输入 npm run build 的时候就会执行对应的代码</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span> : <span class="string">&quot;webpack&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ul><li><p>package.json中的scripts脚本在执行时, 会按照一定的顺序寻找命令对应的位置</p><ul><li>首先 会寻找本地的node_modules/.bin 路径中对应的命令</li><li>如果没有找到, 会在全局的环境变量中寻找</li></ul></li><li><p>执行build指令</p><ul><li>在项目根目录路径下, 命令行输入 npm run build 即可执行指令</li></ul></li></ul><h3 id="什么是loader"><a href="#什么是loader" class="headerlink" title="什么是loader"></a>什么是loader</h3><ul><li>loader是webpack中一个非常核心的概念<ul><li>它是用来扩展webpack的功能的, webpack自身是不会处理css, 图片, typeScript等等的文件的, 也就是说webpack本身只会处理js的文件</li></ul><ul><li>但是我们在开发中不仅仅需要有基本的js代码管理, 还需要夹中css, 图片, ES6转换ES5, TypeScript转换ES5代码等等等等的需求</li></ul><ul><li>那么就需要用loader来扩展webpack的功能</li></ul></li><li>loader的使用过程<ul><li>步骤一: 通过npm安装需要使用的loader<ul><li>可以通过查阅webpack官方文档来查询各种loader的功能</li></ul></li><li>步骤二: 在webpack.config.js 中的module关键字中进行配置<ul><li>具体配置方法可以查阅webpack官方文档</li></ul></li></ul></li><li>大部分loader都可以在webpack官网中找到用法</li></ul><h3 id="通过loader处理css文件"><a href="#通过loader处理css文件" class="headerlink" title="通过loader处理css文件"></a>通过loader处理css文件</h3><ul><li><p>第一步: npm局部安装css-loader和style-loader</p></li><li><p>第二步: 在入口js文件中编写css文件依赖 require=(“css文件的路径”)</p><ul><li>不需要用变量去接收这个css文件, 只需要让js文件依赖这个css文件就行, 实际上就是让css文件与项目有了联系</li></ul></li><li><p>第三步: 在webpack.config.js 的module关键字下进行配置</p><ul><li>webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</li></ul></li><li><p>注意点:</p><ul><li>css-loader 只负责加载css文件, 但是不会负责将css具体样式嵌入到DOM中</li><li>style-loader 会负责将css具体样式嵌入到DOM中</li><li>所以这两个loader 是一起使用的, 用来处理css文件的</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 局部安装css-loader和 style-loader 命令行输入--&gt;</span><br><span class="line">npm install css-loader@需要的版本号 --save-dev</span><br><span class="line">npm install style-loader@需要的版本号 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在入口的js文件中编写css文件依赖</span></span><br><span class="line"><span class="built_in">require</span> = (<span class="string">&quot;css文件的路径&quot;</span>) <span class="comment">// 不需要用变量去接收这个css文件, 只需要让js文件依赖这个css文件就行, 实际上就是让css文件与项目有了联系</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js 中的module关键字中编写配置</span></span><br><span class="line"><span class="comment">// 可以在webpack官网中查阅各个loader的用法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span> : &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 这个test的作用为导入以 .css结尾的文件</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">        <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="less文件处理"><a href="#less文件处理" class="headerlink" title="less文件处理"></a>less文件处理</h3><ul><li>准备工作<ul><li>在css文件夹中创建less文件</li></ul></li><li>局部安装less-loader 和 less<ul><li>这里不仅安装了less-loader 还安装了less<ul><li>因为webpack并不会编译less文件, 需要借助less来进行编译</li></ul></li></ul></li><li>根据官方文档修改对应的配置文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js文件中新增的代码</span></span><br><span class="line"><span class="comment">// 4. 在这里依赖一下less文件, 让less文件与项目有关系</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./css/special.less&quot;</span>)</span><br><span class="line"><span class="comment">// 为了可以看到效果, 给页面中填写一些文字</span></span><br><span class="line"><span class="built_in">document</span>.writeln(<span class="string">&quot;&lt;h2&gt;你好你好&lt;/h2&gt;&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是webpack.config.js 中的修改后的module对象, 其实就是按照官方文档复制粘贴就行</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">      <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">      use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片文件的处理"><a href="#图片文件的处理" class="headerlink" title="图片文件的处理"></a>图片文件的处理</h3><ul><li>资源准备阶段<ul><li>在src文件夹中的img文件夹中准备两张图片, 一张大于设定的limit大小, 一张小于设定的limit大小</li></ul></li><li>局部安装url-loader<ul><li>按照webpack官网设置webpack.config.js文件</li><li>先在css文件中引用小于设定的limit大小的图片作为页面背景</li><li>命令行输入 npm run build 进行打包</li><li>浏览器运行后发现, 小于limit大小的图片是经过base64编码成字符串后渲染出来的</li></ul></li><li>现在用大于设定的limit大小的图片作为页面背景<ul><li>命令行输入 npm run build 进行打包</li><li>会发现报错, 提示项目中没有file-loader模块</li><li>安装file-loader模块后 再次进行打包</li><li>会发现dist文件夹下多了一个图片文件<ul><li>原理: 如果图片的大小大于webpack.config.js中limit设定的大小的话, webpack会用file-loader模块进行图片文件的导出</li></ul></li></ul></li></ul><h3 id="图片文件处理-修改文件名称"><a href="#图片文件处理-修改文件名称" class="headerlink" title="图片文件处理-修改文件名称"></a>图片文件处理-修改文件名称</h3><ul><li>我们会webpack 通过file-loader导出的图片的名字是一个很长的名字<ul><li>这是一个32位hash值, 目的是为了防止名字的重复</li><li>但是, 真实开发中, 我们可能对打包的图片名字有一定的要求</li><li>比如, 将图片放到一个文件夹中, 跟上图片原来的名字, 同时要防止文件名的重复</li></ul></li><li>所以在webpack.config.js 中de1options中添加如下选项<ul><li>name : “img.[name].[hash:8].[ext]”</li><li>img : 文件要打包到的文件夹</li><li>[name] : 获取图片原来的名字,放在该位置</li><li>[hash:8] : 防止图片名称冲突,依然使用hash,但是保留8位,以免文件名字过长</li><li>[ext] : 使用图片原来的扩展名</li></ul></li><li>做完以上处理后, 再次打包, 会发现图片并没有显示出来, 这是因为图片使用的路径不正确<ul><li>默认情况下, webpack会将生成的路径直接返回给使用者</li><li>但是, 我们整个程序打包是在dist文件夹下的, 所以在这里我们需要在路径下再添加一个dist/</li><li>在实际开发中并不需要添加在路径下再添加dist/ ,因为项目最终入口文件都会放到dist文件夹中, 现在是在学习阶段, 所以需要添加, 到后面要删除整个多余的dist/路径的</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里是css中引入的两张图片 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="comment">/* background: pink; */</span></span><br><span class="line">  <span class="comment">/* 这是一张小于limit 大小的图片 */</span></span><br><span class="line">  <span class="comment">/* background: url(../img/OIP.jfif) */</span></span><br><span class="line">  <span class="comment">/* 这是一张大于limit 大小的图片 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">../img/sunlogo.jpg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里是webpack.config.js 代码 */</span></span><br><span class="line"><span class="comment">/* 引用内置的path模块 */</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 编写入口</span></span><br><span class="line">  <span class="attr">entry</span> : <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 编写出口, output 是一个对象, 对象包含两个属性, path 路径 和fliename 文件名, 其中path路径必须是绝对路径</span></span><br><span class="line">  <span class="comment">// path绝对路径, 借助了node中的内置模块 path 的resolve方法</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">    <span class="comment">// 设置publicPath, 让导出的每一个url地址在开头都添加上一个前缀地址</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&quot;dist/&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 引入css文件需要局部安装 css-loader 和 style-loader</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 这里注意了, webpack在读取使用的loader的过程中，是按照从右向左的顺序读取的。</span></span><br><span class="line">        <span class="comment">// 所以是先执行css-loader 再执行 style-loader 顺序不能写错</span></span><br><span class="line">        use: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span> ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;style-loader&quot;</span> <span class="comment">// creates style nodes from JS strings</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;css-loader&quot;</span> <span class="comment">// translates CSS into CommonJS</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;less-loader&quot;</span> <span class="comment">// compiles Less to CSS</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif|jpeg)$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// 设置limit 限制图片的大小, 单位是B, 一般设置位8Kb, </span></span><br><span class="line">            <span class="attr">limit</span>: <span class="number">16000</span>,</span><br><span class="line">            <span class="comment">// 设置name属性, 来设置导出的图片名字</span></span><br><span class="line">            <span class="attr">name</span> : <span class="string">&quot;img/[name].[hash:8].[ext]&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ES6语法处理"><a href="#ES6语法处理" class="headerlink" title="ES6语法处理"></a>ES6语法处理</h3><ul><li>如果仔细阅读webpack打包的js文件, 会发现写的ES6语法并没有转换成ES5语法, 这就意味着我们的代码不能兼容一些对ES6还不支持的浏览器</li><li>如果要将ES6语法转换为ES5, 那么就需要使用babel<ul><li>命令行输入 npm install –save-dev <a href="mailto:&#x62;&#x61;&#x62;&#101;&#x6c;&#45;&#x6c;&#x6f;&#97;&#100;&#101;&#114;&#64;&#x37;&#46;&#49;&#x2e;&#x35;">&#x62;&#x61;&#x62;&#101;&#x6c;&#45;&#x6c;&#x6f;&#97;&#100;&#101;&#114;&#64;&#x37;&#46;&#49;&#x2e;&#x35;</a> babel-core@6.26.3 <a href="mailto:&#98;&#x61;&#x62;&#x65;&#x6c;&#x2d;&#x70;&#x72;&#101;&#115;&#x65;&#x74;&#x2d;&#x65;&#115;&#x32;&#x30;&#49;&#x35;&#64;&#54;&#46;&#x32;&#x34;&#x2e;&#49;">&#98;&#x61;&#x62;&#x65;&#x6c;&#x2d;&#x70;&#x72;&#101;&#115;&#x65;&#x74;&#x2d;&#x65;&#115;&#x32;&#x30;&#49;&#x35;&#64;&#54;&#46;&#x32;&#x34;&#x2e;&#49;</a> (这里是为了模块版本的兼容, 所以需要安装特定版本号的模块)</li><li>配置webpack.config.js文件</li><li>打包即可</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 这句是匹配所有.js结尾的文件</span></span><br><span class="line">  <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  <span class="comment">// 这句是表示除了 node_modules|bower_components 文件夹内的文件</span></span><br><span class="line">  exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">  use: &#123;</span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="comment">// 这里是转换位 ES5代码 的意思</span></span><br><span class="line">      <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入Vue-js"><a href="#引入Vue-js" class="headerlink" title="引入Vue.js"></a>引入Vue.js</h3><ul><li>在后续的项目中, 我们会使用Vuejs进行开发, 而且会以特殊的文件来组织Vue的组件<ul><li>所以需要在webpack环境中集成Vuejs</li></ul></li><li>利用npm安装Vue<ul><li>在项目文件目录下, 命令行输入 npm install vue –save</li><li>注意这里要使用 运行时依赖安装 –save<ul><li>因为项目在浏览器中运行的时候要依赖vue的</li></ul></li></ul></li><li>在需要的js文件中引入vue, 并且按照之前学习的语法使用Vue</li><li>编写好vue代码后, 进行打包, 浏览器运行, 会发现报错<ul><li>错误信息提示, 我们使用的时runtime-only(运行时版本)的vue<ul><li>按照vue官网的意思是, 运行时版本的vue比runtime-compiler(完整版的vue)的文件大小要小30%, 所以默认vue是使用运行时版本的, 但是运行时版本的vue不包括编译template模块的功能, 而我们的root组件其实就算是一个template模块, 所以这里会报错</li><li>解决方法, 在webpack.config.js打包工具中配置别名即可(其实就是将默认vue使用的版本修改问完整版的版本)</li></ul></li></ul></li><li>重新打包, 浏览器运行, 就不会报错了</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目文件夹下, 终端输入命令行安装vue --&gt;</span><br><span class="line">npm install vue --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在需要使用vue的js文件中的js代码</span></span><br><span class="line"><span class="comment">// 5. 使用Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span> : &#123;</span><br><span class="line">    <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时webpack.config.js中配置Vue的别名</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;vue$&#x27;</span>: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span> <span class="comment">// 用 webpack 1 时需用 &#x27;vue/dist/vue.common.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="el和template的区别"><a href="#el和template的区别" class="headerlink" title="el和template的区别"></a>el和template的区别</h3><ul><li>如果我们希望修改页面中由vue解析的数据, 那么就必须修改index.html的代码</li><li>如果我们后面自定义了组件, 也必须修改index.html的代码来使用组件</li><li>但是html模板在之后的开发中, 我们不会频繁地修改</li><li>这个时候就需要给Vue实例定义template属性了<ul><li>在Vue实例中,我们定义了el属性, 用域与index.html中的节点进行绑定, 让Vue实例之后可以管理节点中的内容</li><li>在这里我们再给Vue实例再定义一个template属性, 并且编写渲染在页面中的模板</li><li>如果Vue实例中同时定义了template和el, 那么template模板的内容就会替换掉挂载的对应的el的模板</li></ul></li><li>这样做的好处<ul><li>这样做只会, 就不需要再开发中操作index.html了, 只需要再template中写入对应的标签, Vue编译的时候就会将template中的模板替换掉index.html中被el挂载的标签</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 使用Vue</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="comment">// 这个template中的模板,在Vue编译的时候,会替换el绑定的标签</span></span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  <span class="attr">data</span> : &#123;</span><br><span class="line">    <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span>,</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue组件化开发引入"><a href="#Vue组件化开发引入" class="headerlink" title="Vue组件化开发引入"></a>Vue组件化开发引入</h3><ul><li>Vue开发过程中, 我们都会采用组件化开发的思想<ul><li>在当前项目中, 我们也可以采用组件化的形式开发</li></ul></li><li>这里是将Vue实例中的emplate, data 抽取出来作为一个js文件模块, 同理也可以抽取实例中的其他option的, 例如 computed, methods等等</li><li>然后再在main中导入这个js文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">template</span> : <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;button&gt;按钮&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;h2&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span> : <span class="string">&quot;你好你好,我是Vue&quot;</span>,</span><br><span class="line">      <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main中导入上面的js文件</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./vue/test.js&quot;</span> </span><br></pre></td></tr></table></figure><h3 id="vue文件的封装处理"><a href="#vue文件的封装处理" class="headerlink" title=".vue文件的封装处理"></a>.vue文件的封装处理</h3><ul><li>一个组件以一个对象的形式进行组织和使用是非常不方便的<ul><li>一方面编写template模块很麻烦, 模块的代码写在ES6中的模板字符串中, 代码会很乱</li><li>另外, 如果元素有样式的话, 也不知道应该写在哪一个地方</li></ul></li><li>所以现在, 使用一个全新的组件来组织Vue的组件<ul><li>.vue文件就可以解决这个问题</li><li>.vue文件 由三个标签组成<ul><li><template>标签, 里面编写组件模板</li><li><script>标签, 里面编写组件的组件构造器</li><li><style>标签, 里面编写组件模板的样式</li></ul></li></ul></li><li>这是一个新的文件类型, 所以我们需要用webpack中新的loader来处理这类文件</li><li>在项目文件目录下, 命令行输入 npm install –save-dev vue-loader vue-template-compiler  (开发时依赖安装) 注意:这里使用的两个模块的版本分别是 <a href="mailto:&#118;&#117;&#101;&#x2d;&#x6c;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#49;&#x33;&#x2e;&#x30;&#46;&#48;">&#118;&#117;&#101;&#x2d;&#x6c;&#x6f;&#97;&#100;&#x65;&#114;&#64;&#49;&#x33;&#x2e;&#x30;&#46;&#48;</a> 和 <a href="mailto:&#118;&#117;&#101;&#45;&#x74;&#101;&#x6d;&#112;&#108;&#x61;&#x74;&#x65;&#45;&#x63;&#111;&#x6d;&#x70;&#105;&#108;&#101;&#114;&#64;&#50;&#x2e;&#53;&#46;&#x32;&#49;">&#118;&#117;&#101;&#45;&#x74;&#101;&#x6d;&#112;&#108;&#x61;&#x74;&#x65;&#45;&#x63;&#111;&#x6d;&#x70;&#105;&#108;&#101;&#114;&#64;&#50;&#x2e;&#53;&#46;&#x32;&#49;</a>版本</li><li>在webpack.config.js 文件中修改配置</li><li>然后在main.js文件中引用模块</li><li>并且在Vue实例的components中注册, 这样就可以在Vue实例中的template中使用该组件模块了, 再进行打包即可</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 再项目文件目录下, 命令行输入以下代码, 安装模块 --&gt;</span><br><span class="line">npm install --save-dev vue-loader vue-template-compiler</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是.vue文件</span><br><span class="line">// template标签内编写组件模板</span><br><span class="line">&lt;template&gt; </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;btnClick&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;test2&gt;&lt;/test2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// script标签内编写组件构造器, 如果有其他依赖的模块, 也可以用import导入其他的模块</span><br><span class="line">import test2 from &quot;./Test2.vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;test&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;你好你好,我是Vue&quot;,</span><br><span class="line">      name: &quot;xiaoLam&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    btnClick() &#123;</span><br><span class="line">      console.log(&quot;我被点击了&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    test2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">/* style标签内编写样式 */</span><br><span class="line">.title &#123;</span><br><span class="line">  color: pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后在main.js中导入模块</span></span><br><span class="line"><span class="comment">// 并且在Vue实例的components中注册, 这样就可以在Vue实例中的template中使用该组件模块了</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&quot;./vue/Test.vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span> : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;test&gt;&lt;/test&gt;`</span>,</span><br><span class="line">  <span class="attr">components</span> : &#123;</span><br><span class="line">    test</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="认识plugin"><a href="#认识plugin" class="headerlink" title="认识plugin"></a>认识plugin</h3><ul><li><p>什么时plugin</p><ul><li>plugin的意思时插件的意思, 通常是用于对某个现有的架构进行的扩展</li><li>webpack中的插件, 就是对webpack现有功能的各种扩展,比如打包优化,文件压缩等等</li></ul></li><li><p>loader和plugin的区别</p><ul><li>loader主要用于转换某些类型的模块, 他是一个转换器</li><li>而plugin是插件, 是对webpack本事的扩展, 是一个扩展器</li></ul></li><li><p>plugin的使用过程:</p><ul><li>步骤一: 通过npm安装需要使用的plugins(有一写plugin在webpack已经内置了,就不需要安装)</li><li>步骤二: 在webpack.config.js中的plugins中配置插件</li></ul></li></ul><h3 id="添加版权的plugin"><a href="#添加版权的plugin" class="headerlink" title="添加版权的plugin"></a>添加版权的plugin</h3><ul><li>我们可以给打包的文件添加版权声明<ul><li>什么是版权声明<ul><li>百度五分钟</li></ul></li></ul></li><li>添加版权的插件名为BannerPlugin, 属于webpack的内置插件(所以不需要npm安装)</li><li>按照下列代码配置webpack.config.js中的plugins后重新打包程序, 就可以看到打包出来的文件头部多了版权的注释</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用webpack内置的模块</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&quot;webpack&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 在plugins中编写版权plugin</span></span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&quot;最终版权归xiaoLam所有&quot;</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包html的plugin"><a href="#打包html的plugin" class="headerlink" title="打包html的plugin"></a>打包html的plugin</h3><ul><li><p>目前, 我们的index.html文件时存放在项目的根目录中的</p><ul><li>但是,当我们要发布项目到服务器中的时候, 发布的是dist文件夹中的内容, 但是dist文件夹中没有index.html文件, 那么打包的js文件就没有意义了</li><li>所以我们要将index.html文件打包到dist文件夹中, 这个时候就需要用到webpack中的HtmlWebpackPlugin插件了</li></ul></li><li><p>HtmlWebpackPlugin插件有什么用?</p><ul><li>可以自动生成一个index.html文件(并且可以指定模板)</li><li>会将打包的js文件,自动通过script标签插入到body中, 所以原本的index.html文件就不需要script标签了</li></ul></li><li><p>htmlwebpackplugin插件的使用</p><ul><li>安装<ul><li>当前项目目录下 命令行输入 npm install html-webpack=plugin –save-dev (开发时依赖安装)</li></ul></li><li>在webpack.config.js文件中引用插件</li><li>编辑webpack.config.js文件中的plugins部分的内容<ul><li>template填入一个html文件的路径, 表示根据什么模板来生成index.html</li><li>注意, 我们从现在开始就不需要output中以前添加的publicPath属性了, 因为已经将html打包进dist文件夹中了, 否则html文件中的路径引用会有问题</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--在当前项目目录下命令行输入  --&gt;</span><br><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js 文件</span></span><br><span class="line"><span class="comment">// 引入webpack中的html-webpack-plugin模块</span></span><br><span class="line"><span class="keyword">const</span> htmlwebpackplugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">output : &#123;</span><br><span class="line">  <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;dist&quot;</span>),</span><br><span class="line">  <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  <span class="comment">// 设置publicPath, 让导出的每一个url地址在开头都添加上一个前缀地址</span></span><br><span class="line">  <span class="comment">// 在将index.html也一起打包到dist文件夹中的时候, 这句代码就要去掉了 把它注释掉</span></span><br><span class="line">  <span class="comment">// publicPath: &quot;dist/&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">plugins</span> : [</span><br><span class="line">  <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">&quot;最终版权归xiaoLam所有&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> htmlwebpackplugin(&#123;</span><br><span class="line">  <span class="comment">// 给htmlwebpackplugin实例添加一个对象, 对象里面包含template,值为html模板的路径</span></span><br><span class="line">  <span class="attr">template</span> : <span class="string">&quot;./index.html&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="压缩js的Plugin"><a href="#压缩js的Plugin" class="headerlink" title="压缩js的Plugin"></a>压缩js的Plugin</h3><ul><li>在项目发布的时候, 我们必然需要将js等文件进行压缩<ul><li>将所有的注释, 空格, 换行删除, 并将变量名和函数名转换为最简单的字符串</li><li>以达到文件最小化, 增加传输加载效率</li><li>所以在这里我们使用一个第三方插件uglifyjs-webpack-plugin, 并且为了与接下来学习的脚手架CLI2保持一致, 使用的版本号为 1.1.1</li></ul></li><li>安装uglifyjs-webpack-plugin<ul><li>在项目目录下, 命令行输入, npm install <a href="mailto:&#117;&#x67;&#x6c;&#x69;&#x66;&#x79;&#106;&#x73;&#45;&#119;&#x65;&#98;&#x70;&#x61;&#x63;&#107;&#45;&#112;&#108;&#x75;&#103;&#x69;&#x6e;&#x40;&#49;&#x2e;&#49;&#x2e;&#x31;">&#117;&#x67;&#x6c;&#x69;&#x66;&#x79;&#106;&#x73;&#45;&#119;&#x65;&#98;&#x70;&#x61;&#x63;&#107;&#45;&#112;&#108;&#x75;&#103;&#x69;&#x6e;&#x40;&#49;&#x2e;&#49;&#x2e;&#x31;</a> –save-dev (使用开发依赖安装)</li></ul></li><li>修改webpack.config.js 配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下， 命令行输入 --&gt;</span><br><span class="line">npm install uglifyjs-webpack-plugin@1.1.1 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js 中进行配置</span></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">const</span> uglifyjswebpackplugin = requrie(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在plugins中使用该模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> uglifyjswebpackplugin();</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><ul><li>本地服务器的原理<ul><li>在开发过程中，新增的代码代码是经常需要调试的</li><li>但是如果我们每次调试代码的时候, 都要将所有文件打包一次到本地磁盘中, 再在浏览器中运行, 这样的效率是十分低的</li><li>我们可以搭建一个本地服务器, 将这个服务器服务于我们的某个文件夹, 此时这个服务器就会实时地监听代码有没有发生改变</li><li>如果有发生改变的时候, 就会对改变的代码进行编译</li><li>编译后并不会立即生成最终的文件, 也就是不会将编译好的代码存入硬盘中</li><li>而是会将编译好的代码先放入内存中, 让我们进行测试 (这一点很重要), 内存的读取速度是远远大于硬盘的<ul><li>实际上本地服务器的作用就是, 将编写的代码先放入内存中, 而不是原来的放入某个文件夹中, 在测试的时候调用的是内存中的代码, 这样就不需要, 调试新增或者修改的代码的时候, 都要将代码打包到某个文件夹中, 再进行调试, 本地服务器可以实时地监听代码地更新  </li></ul></li><li>在最终想要发布的时候, 再打包一次代码即可</li></ul></li><li>如何搭建本地服务器<ul><li>webpack提供了一个本地开发服务器, 这个本地服务器是基于node.js搭建地, 内部使用express框架, 可以实现我们想要的浏览器自动刷新显示修改代码地效果</li><li>webpack-dev-server 是一个单独的模块, 在webpack中使用需要先安装<ul><li>命令行输入 npm install <a href="mailto:&#119;&#101;&#98;&#112;&#x61;&#99;&#x6b;&#x2d;&#x64;&#x65;&#118;&#45;&#115;&#101;&#x72;&#x76;&#x65;&#x72;&#x40;&#x32;&#46;&#x39;&#46;&#49;">&#119;&#101;&#98;&#112;&#x61;&#99;&#x6b;&#x2d;&#x64;&#x65;&#118;&#45;&#115;&#101;&#x72;&#x76;&#x65;&#x72;&#x40;&#x32;&#46;&#x39;&#46;&#49;</a> –save-dev (为了配合其他模块指定版本问2.9.1, 开发时依赖安装)</li></ul></li><li>在webpack.config.js中配置webpack-dev-server<ul><li>devserver是webpack中的一个option选项, 所以不需要引用</li><li>devserver选项本身可以设置如下属性:<ul><li>contentBase: 填写一个路径, 表示为哪一个文件夹提供本地服务, 默认是根文件夹, 这里我们填写 ./dist</li><li>port : 端口号, 默认是8080</li><li>inline : 设置页面是否实时刷新, 填入一个布尔值</li><li>historyApiFallback: 在SPA页面中, 依赖HTML5的history模式</li></ul></li></ul></li></ul></li><li>运行服务器<ul><li>配置好以上文件后, 在命令行输入 webpack-dev-server 来运行服务器<ul><li>会发现报错, 说没有找到该模块</li><li>原因是, 在命令行直接输入模块名来运行模块, 终端会在全局中寻找该模块, 而我们的webpack-dev-server是局部安装的,所以会报错</li></ul></li><li>局部运行模块的两种方法<ul><li>第一种, 在命令行中完整输入模块路径</li><li>第二种, 配置package.json中的scripts脚本属性<ul><li>–open参数表示, 运行同时直接打开浏览器</li></ul></li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下 命令行输入 --&gt;</span><br><span class="line">npm install webpack-dev-server@2.9.1 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">devServer</span> : &#123;</span><br><span class="line">    <span class="comment">// 指定建立本地服务器的文件夹</span></span><br><span class="line">    <span class="attr">contentBase</span> : <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定是否进行实时刷新页面</span></span><br><span class="line">    <span class="attr">inline</span> : <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置package.json文件中的 scripts脚本属性</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 配置好后, 在命令行输入 npm run dev 就可以运行本地服务器了</span></span><br><span class="line">    <span class="comment">// --open是指, 能够在运行本地服务器的同时打开浏览器</span></span><br><span class="line">    <span class="string">&quot;dev&quot;</span> : <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="webpack的webpack-config-js配置分离"><a href="#webpack的webpack-config-js配置分离" class="headerlink" title="webpack的webpack.config.js配置分离"></a>webpack的webpack.config.js配置分离</h3><ul><li>在实际开发过程中<ul><li>开发时用的配置文件, 和 最终打包的配置文件是不一样的<ul><li>比如说, 在开发中,我们不需要用到uglifyjs-webpack-plugin压缩js这个插件, 在最终打包中不需要用到webpack-dev-server构建本地服务器这个插件</li></ul></li><li>所以我们应该将webpack.config.js中的配置进行抽取分离, 实现在开发中使用一套配置文件, 在打包时使用另一套配置文件</li></ul></li><li>进行配置分离的详细过程<ul><li>第一步, 创建配置文件的文件夹<ul><li>分离出来的配置文件会由一份变成好几份, 所以我们需要用一个新的文件夹来存储它们</li><li>在项目根目录中创建名为build的文件夹, 里面存储配置文件</li></ul></li><li>第二步, 创建配置文件<ul><li>base.config.js 这个配置文件里面包含的是公共的配置</li><li>prod.config.js 这个配置文件里面包含的是打包的时候使用的配置</li><li>dev.config.js 这个配置文件里面包含的是开发的时候使用的配置</li></ul></li><li>第三步, 下载合并配置文件的模块, webpack-merge , 这个模块用于将公共的配置和需要使用的配置合并在一起<ul><li>命令行输入 npm install <a href="mailto:&#119;&#101;&#98;&#112;&#97;&#99;&#x6b;&#x2d;&#109;&#101;&#x72;&#103;&#101;&#x40;&#52;&#46;&#x31;&#46;&#x35;">&#119;&#101;&#98;&#112;&#97;&#99;&#x6b;&#x2d;&#109;&#101;&#x72;&#103;&#101;&#x40;&#52;&#46;&#x31;&#46;&#x35;</a> –save-dev (开发依赖安装)</li></ul></li><li>第四步, 配置webpack-merge模块, 就是简单的引用模块, 使用模块</li><li>第五步, 调整原本配置的出口, 因为将配置文件放在了不同的位置, 所以要将原本配置中的路径修改一下</li><li>第六步, 调整package.json中的scripts脚本, 因为npm执行配置文件的时候, 默认是寻找webpack.config.js文件的, 现在我们修改了文件的名称, 所以要修改scripts脚本</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在当前项目根目录下, 命令行输入 --&gt;</span><br><span class="line">npm install webpack-merge@4.1.5 --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是base.config.js 中的代码</span></span><br><span class="line"><span class="comment">// 其余的代码不变, 只保留公共的部分</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">output</span> : &#123;</span><br><span class="line">    <span class="comment">// 修改了path</span></span><br><span class="line">    <span class="attr">path</span> : path.resolve(__dirname,<span class="string">&quot;../dist&quot;</span>),</span><br><span class="line">    <span class="attr">filename</span> : <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 填写需要保存为的文件名</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是prod.config.js的代码</span></span><br><span class="line"><span class="comment">// 将只在打包时需要的配置抽取到这里</span></span><br><span class="line"><span class="comment">// 引入压缩js的webpack-plugin的模块</span></span><br><span class="line"><span class="keyword">const</span> uglifyjswebpackplugin = <span class="built_in">require</span>(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入webpack-merge 配置文件合并模块</span></span><br><span class="line"><span class="keyword">const</span> webpackmerge = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入base基本配置文件</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&quot;./base.config.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackmerge(baseConfig, &#123;</span><br><span class="line">  <span class="attr">plugins</span> : [</span><br><span class="line">    <span class="keyword">new</span> uglifyjswebpackplugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是dev.config.js的代码</span></span><br><span class="line"><span class="comment">// 将开发时需要的配置抽取到这里</span></span><br><span class="line"><span class="comment">// 引入配置文件合并模块</span></span><br><span class="line"><span class="keyword">const</span> webpackmerge = <span class="built_in">require</span>(<span class="string">&quot;webpack-merge&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入base基本配置文件</span></span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&quot;./base.config.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用CommonJS规范书写</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackmerge(baseConfig, &#123;</span><br><span class="line">  <span class="attr">devServer</span> : &#123;</span><br><span class="line">    <span class="comment">// 指定建立本地服务器的文件夹</span></span><br><span class="line">    <span class="attr">contentBase</span> : <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定是否进行实时刷新页面</span></span><br><span class="line">    <span class="attr">inline</span> : <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时package.json的代码</span></span><br><span class="line"><span class="comment">// 修改scripts</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  <span class="comment">// --config 可以将默认使用的webpack.config.js配置文件修改为自定义的配置文件</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --config ./build/prod.config.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --open --config ./build/dev.config.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端小知识 </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-Vue的响应式原理</title>
      <link href="2021/05/25/15-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>2021/05/25/15-Vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue是如何实现响应式的"><a href="#Vue是如何实现响应式的" class="headerlink" title="Vue是如何实现响应式的"></a>Vue是如何实现响应式的</h3><ul><li>Vue实现响应式要了解两个核心<ul><li>第一个: Vue如何监听data数据的改变</li><li>第二个: data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</li></ul></li></ul><h3 id="Vue如何监听data数据的改变"><a href="#Vue如何监听data数据的改变" class="headerlink" title="Vue如何监听data数据的改变"></a>Vue如何监听data数据的改变</h3><ul><li>实质上vue是通过 defineProperty 方法来监听data数据的改变的</li><li>defineProperty方法需要传入三个参数<ul><li>第一个参数是需要监听的对象(目标对象)</li><li>第二个参数是监听对象的值(引用的目标对象上的字符串键属性)</li><li>第三个参数是一个对象, 对象中编写对应事件</li></ul></li></ul><h3 id="data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素"><a href="#data数据改变的时候-Vue如何知道应该修改哪一个使用了data数据的元素" class="headerlink" title="data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素"></a>data数据改变的时候, Vue如何知道应该修改哪一个使用了data数据的元素</h3><ul><li>vue是通过一种名叫 “发布者订阅者” 的模式来知道当data数据修改的时候, 应该修改哪一个使用了data数据的元素的</li></ul><h3 id="代码简单模拟vue的响应式原理"><a href="#代码简单模拟vue的响应式原理" class="headerlink" title="代码简单模拟vue的响应式原理"></a>代码简单模拟vue的响应式原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是简单地模拟一下vue的响应式原理</span></span><br><span class="line"><span class="comment">// vue实现响应式核心为两个</span></span><br><span class="line"><span class="comment">// 第一个: vue如何监听data数据的更改</span></span><br><span class="line"><span class="comment">// 第二个: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先来解决第一个问题</span></span><br><span class="line"><span class="comment">// 实质上vue是通过defineProperty方法来监听数据的更改的</span></span><br><span class="line"><span class="comment">// 比如这里的obj对象就是vue中的data对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xiaolam&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue中会获得这个obj对象, 然后遍历里面的键</span></span><br><span class="line"><span class="comment">// 通过 Object.keys(obj) 来获取obj中的键并组成一个数组</span></span><br><span class="line"><span class="comment">// 然后通过forEach 遍历这个数组, 给数组中的键通过defineProperty方法监听里面的所有key</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> value = obj[key];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 通过defineProperty中的set方法就可以监听obj对象中数据的更改了</span></span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的set&quot;</span>);</span><br><span class="line">      <span class="comment">// 在更改obj中的数据的时候, 调用发布者中的notify方法, 这个方法会调用所有订阅者中的update方法</span></span><br><span class="line">      <span class="comment">// 而update方法里面可以编写更新页面的代码</span></span><br><span class="line">      dep.notify()</span><br><span class="line">      value = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通过defineProperty中的get方法就可以监听页面中什么元素的通过mustache语法取用obj数据</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;进入defineProperty中的get&quot;</span>);</span><br><span class="line">      <span class="comment">// 在使用obj的数据后, 将使用数据的元素做一个记录</span></span><br><span class="line">      <span class="comment">// 存储在发布者中</span></span><br><span class="line">      <span class="keyword">const</span> w1 = <span class="keyword">new</span> Watcher(<span class="string">&quot;w1&quot;</span>)</span><br><span class="line">      dep.addSub(w1)</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过上面的过程就可以实现第一个问题: vue如何实现监听data数据的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在解决第二个问题: vue如何知道应该修改页面中的哪个元素</span></span><br><span class="line"><span class="comment">// 实质上vue使用的是一个 发布者订阅者 的技术</span></span><br><span class="line"><span class="comment">// 发布者就是指vue实例</span></span><br><span class="line"><span class="comment">// 而订阅者就是指使用mustache语法的元素</span></span><br><span class="line"><span class="comment">// 发布者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个数组用于存储订阅者</span></span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 在元素取用data数据的时候调用Dep中的这个方法, 来将元素(订阅者)加入到subs数组中用于记录订阅者都有谁</span></span><br><span class="line">  <span class="function"><span class="title">addSub</span>(<span class="params">watcher</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher)</span><br><span class="line">  &#125;; </span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      item.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里做更新页面的操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;更新&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br></pre></td></tr></table></figure><ul><li>思路为: 订阅者和发布者是两个类, 在项目运行的时候, 就new对应的data属性发布者出来(一个data属性对应一个发布者), 在当有页面元素使用了data数据的时候, 触发了defineProperty中的get, 在get中new一个对应的订阅者出来, 并把这个订阅者通过对应发布者中的addSub方法记录在发布者中, 在data数据中某个属性发生改变的时候, 触发defineProperty中的set方法, 在set方法中调用对应发布者的notify方法, 这个方法会调用其中的每个订阅者中的update方法, 在update方法中就编写更新页面的操作, 就是这样发布者就知道应该让哪个订阅者更新自身的展示数据了, 从而实现响应式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-Vue中axios网络模块封装思路</title>
      <link href="2021/05/25/14-Vue%E4%B8%ADaxios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E6%80%9D%E8%B7%AF/"/>
      <url>2021/05/25/14-Vue%E4%B8%ADaxios%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的网络请求模块-以及它们的优缺点对比"><a href="#常见的网络请求模块-以及它们的优缺点对比" class="headerlink" title="常见的网络请求模块, 以及它们的优缺点对比"></a>常见的网络请求模块, 以及它们的优缺点对比</h3><ul><li>传统Ajax请求<ul><li>缺点: 配置和调用方式等非常混乱</li><li>真实开发中真的很少直接使用, 而是使用Jquery-Ajax</li></ul></li><li>Jquery-ajax<ul><li>相对于传统的Ajax非常好用</li><li>但是我们在整个vue的开发中都是不需要使用Jquery的</li><li>那么就意味着为了方便我们进行一个网络请求, 特意引用了一个jQuery, 这显然不合理, Vue的代码才一万多行, jQuery的代码就一万多行了</li><li>完全没有必要为了使用网络请求就引用jQuery这个框架</li></ul></li><li>官方在Vue1.x的时候, 推出了Vue-resource<ul><li>Vue-resource的体积相对于jQuery小很多</li><li>而且Vue-resource是Vue官方推出的</li><li>但是在Vue2.0以后, Vue-resource就不再更新了</li><li>这就意味着如果继续使用Vue-resource的话对项目的开发和维护都存在很大的隐患</li></ul></li><li>axios<ul><li>在尤雨溪宣布不再更新vue-resource的时候, 推荐使用axios</li><li>所以就选axios了</li><li>vue作者都让你选这个了, 你还想啥呢?</li><li>可能你会说, 尤雨溪只是个写轮子的, 他懂个P的vue(/滑稽)</li></ul></li></ul><h3 id="axios的基本使用"><a href="#axios的基本使用" class="headerlink" title="axios的基本使用"></a>axios的基本使用</h3><ul><li>安装axios 在项目根目录下, 命令行输入<ul><li>npm install axios –save (运行时依赖)</li></ul></li><li>导入axios, 直接通过 axios() 使用, 并不需要使用Vue.use(axios) 来install, 因为axios本身并不是vue中的模块, vue并不具有axios的install方法</li><li>axios支持多种请求方式<ul><li>axios(config)</li><li>axios.request(config)</li><li>axios.get(url[, config])</li><li>axios.delete(url[, config])</li><li>axios.head(url[, config])</li><li>axios.post(url[, data[, config]])</li><li>axios.put(url[, data[, config]])</li><li>axios.patch(url[, data[, config]])</li></ul></li><li>但是我们一般使用第一个 axios(config) 因为这个灵活, 可以在config里面设置请求方式</li><li>axios的特点: axios() 在网络请求完成后会返回一个Promise对象, 所以我们可以在axios() 后直接使用then() 和catch() </li><li>请看下列代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios 是不需要使用 Vue.use() 方法, 因为axios并不是vue中的模块</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// axios有很多种请求方式, 默认的请求方式为get请求</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 提问这里为什么没有跨域问题?</span></span><br><span class="line">  <span class="comment">// 因为在后端已经处理过跨域了</span></span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;请求的url&quot;</span>,</span><br><span class="line">  <span class="comment">// 可以通过 method 属性来指定请求方式</span></span><br><span class="line">  <span class="attr">method</span> : <span class="string">&quot;post&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果使用get请求的话, 如果带有参数的话, 需要拼接到url上, 这样会导致url很长, 所以axios提供了一个parmas对象, 用于参数的拼接</span></span><br><span class="line">  <span class="attr">params</span> : &#123;</span><br><span class="line">    <span class="attr">type</span> : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    <span class="attr">page</span> : <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// axios 在网络请求操作完成之后会返回一个 new Promise 对象, 所以这里可以使用then 和catch</span></span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios处理并发请求"><a href="#axios处理并发请求" class="headerlink" title="axios处理并发请求"></a>axios处理并发请求</h3><ul><li>如果我们需要多个axios请求完成后, 再进行下一步的操作</li><li>axios提供了一个 axios.all() 方法, 用于处理这种需求</li><li>这个方法里面传入一个数组, 数组中传入axios请求</li><li>在axios请求都完成后, axios.all() 方法会调用then(), then()中传入一个函数, 函数中有一个result参数</li><li>result是一个数组, 数组中第一个数据即是第一个axios请求返回的数据, 依此类推</li><li>如果想要将各个返回的数据分开的话, then() 中还可以传入一个 axios.spread() 方法, 方法中传入一个函数</li><li>该函数的参数就是对应的axios请求返回的数据</li><li>看以下实例代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios处理并发请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;http://123.207.32.32:8000/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6/home/data&quot;</span>,</span><br><span class="line">    <span class="attr">params</span> : &#123;</span><br><span class="line">      <span class="attr">type</span> : <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      <span class="attr">page</span> : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line"><span class="comment">/* .then((result =&gt; &#123;</span></span><br><span class="line"><span class="comment">  // 这里的result是一个数组, 里面按顺序存放了各个axios请求返回的数据</span></span><br><span class="line"><span class="comment">  console.log(result);</span></span><br><span class="line"><span class="comment">  console.log(result[0]);</span></span><br><span class="line"><span class="comment">  console.log(result[1]);</span></span><br><span class="line"><span class="comment">&#125;)) */</span></span><br><span class="line">.then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios设置全局配置信息"><a href="#axios设置全局配置信息" class="headerlink" title="axios设置全局配置信息"></a>axios设置全局配置信息</h3><ul><li>其实我们的请求中有很多东西都是相同的, 比如url中的baseURL, 和设置的请求超时时间等等</li><li>如果我们每次请求都要重写这些config, 这样代码就很重复了</li><li>所以我们会将固定的参数抽取出来</li><li>axios提供了一个 defaults 对象用于进行全局配置</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span> <span class="comment">// 这里设置了baseURL</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span>  <span class="comment">// 这里设置了请求超时时间</span></span><br><span class="line">axios.all([</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">url</span> : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">    <span class="attr">params</span> : &#123;</span><br><span class="line">      <span class="attr">type</span> :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">      <span class="attr">page</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]).then(axios.spread(<span class="function">(<span class="params">res1, res2</span>)=&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 axios.spread() 将各个axios请求返回的数据, 分开</span></span><br><span class="line">  <span class="built_in">console</span>.log(res1);</span><br><span class="line">  <span class="built_in">console</span>.log(res2);</span><br><span class="line">&#125;))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="常见的axios配置项"><a href="#常见的axios配置项" class="headerlink" title="常见的axios配置项"></a>常见的axios配置项</h3><ul><li>请求地址<ul><li>url: ‘/user’,</li></ul></li><li>请求类型<ul><li>method: ‘get’,</li></ul></li><li>请根路径<ul><li>baseURL: ‘<a href="http://www.mt.com/api&#39;">http://www.mt.com/api&#39;</a>,</li></ul></li><li>请求前的数据处理<ul><li>transformRequest:[function(data){}],</li></ul></li><li>请求后的数据处理<ul><li>transformResponse: [function(data){}],</li></ul></li><li>自定义的请求头<ul><li>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li></ul></li><li>URL查询对象 (注意只有get请求方式才用params)<ul><li>params:{ id: 12 }</li></ul></li><li>查询对象序列化函数<ul><li>paramsSerializer: function(params){ }</li></ul></li><li>request body (注意只用post请求方式才用这个)<ul><li>data: { key: ‘aa’},</li></ul></li><li>超时设置s<ul><li>timeout: 1000,</li></ul></li><li>跨域是否带Token<ul><li>withCredentials: false,</li></ul></li><li>自定义请求处理<ul><li>adapter: function(resolve, reject, config){},</li></ul></li><li>身份验证信息<ul><li>auth: { uname: ‘’, pwd: ‘12’},</li></ul></li><li>响应的数据格式 json / blob /document /arraybuffer / text / + stream<ul><li>responseType: ‘json’,</li></ul></li></ul><h3 id="创建axios实例"><a href="#创建axios实例" class="headerlink" title="创建axios实例"></a>创建axios实例</h3><ul><li>在实际开发中, 很有可能会遇到这种状况</li><li>网络请求的baseURL是不一样的, 或者说不同的网络请求设置的请求超时时间是不一样的</li><li>这个时候, 如果我们还是使用全局配置的 axios.default 就无法正确地请求正确的数据了</li><li>所以我们要创建axios实例</li><li>创建axios实例, 通过axios.create创建</li><li>看以下代码实例</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如这里的网络请求, 需要设置的请求超时时间为 5000毫秒</span></span><br><span class="line"><span class="keyword">const</span> instans1 = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 在这里设置配置</span></span><br><span class="line">  <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span> : <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用axios实例</span></span><br><span class="line"><span class="comment">// 与全局中使用axios基本一致</span></span><br><span class="line">instans1(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如这里需要设置请求超时时间为10000</span></span><br><span class="line"><span class="keyword">const</span> instans2 = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">  <span class="attr">timeout</span> : <span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在这里使用instans2进行网络请求</span></span><br><span class="line">instans2(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/data&quot;</span>,</span><br><span class="line">  <span class="attr">params</span> : &#123;</span><br><span class="line">    <span class="attr">type</span> :<span class="string">&quot;pop&quot;</span>,</span><br><span class="line">    <span class="attr">page</span> : <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios的封装"><a href="#axios的封装" class="headerlink" title="axios的封装"></a>axios的封装</h3><ul><li>如果我们没有把axios封装到一个文件中, 而是在需要用到axios的组件中都引用axios</li><li>那么如果在未来的某一天, axios突然宣布不再更新</li><li>那我们的项目想要使用另外的替代品将会变得十分困难, 因为我们每个组件都依赖了axios</li><li>为了降低我们各个组件对axios的依赖性</li><li>我们要将axios封装在一个独立的文件中</li><li>封装过程及引用方法请看下列示例代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建文件 src/network/request.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios实例并导出</span></span><br><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span>,</span><br><span class="line">    <span class="attr">timeout</span> : <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span> : <span class="string">&quot;/home/multidata&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过组件传入一个函数, 然后回调这个函数返回数据给组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config,success,error</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如何使用</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;./network/request&quot;</span></span><br><span class="line">request(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 通过组件传入一个函数, 然后回调这个函数返回数据给组件的另外一种形式</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  instans(config.baseConfig)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    config.success(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    config.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">baseConfig</span>: &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 实际上, 我们并不会使用以上的两种方法, 而是使用 Promise来返回数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    instans(config)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      reject(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.res = res;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 实际上, 我们也不会像上面那样, 因为axios本身就返回一个Promise, 没有必要再包一层</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">request(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/home/multidata&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.res = res;</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="axios拦截器的使用"><a href="#axios拦截器的使用" class="headerlink" title="axios拦截器的使用"></a>axios拦截器的使用</h3><ul><li>axios提供了拦截器, 用于我们再发送每次请求或者得到相应数据后, 进行对应的处理</li><li>拦截器分为: 请求拦截器 interceptors.request 和 响应拦截器 interceptors.response</li><li>请求拦截器主要用法<ul><li>1.当发送网络请求的时候, 在页面中添加一个loading组件, 作为动画</li><li>2.某些请求是要求用户必须登陆的, 这是请求拦截器就可以判断请求是否带有token(令牌), 如果没有token就跳转到login页面</li><li>3.对请求的参数进行序列化, 就是对请求的参数做一些修改或者添加一些参数</li></ul></li><li>响应拦截器主要用法<ul><li>1.响应的成功拦截中,主要是对数据进行过滤</li><li>2.响应失败的拦截中, 跨域根据status判断报错的错误码, 跳转到不同的错误提示页面</li></ul></li><li>拦截器使用注意事项, 使用拦截器后, 一定要将数据 return 出去, 否则, 拦截器会把数据拦截住</li><li>基本使用方法看下列代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> instans = axios.create(&#123;</span><br><span class="line">    <span class="attr">baseURL</span> : <span class="string">&quot;http://152.136.185.210:8000/api/w6&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 使用拦截器</span></span><br><span class="line">  <span class="comment">// 请求拦截器</span></span><br><span class="line">  instans.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(config);</span><br><span class="line">    <span class="keyword">return</span> config  <span class="comment">// 将数据在return出去</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应拦截器</span></span><br><span class="line">  instans.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> res.data  <span class="comment">// 将数据进行过滤, 只返回data</span></span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送真实的网络请求</span></span><br><span class="line">  <span class="keyword">return</span> instans(config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-Vue-Vuex全局状态管理详解</title>
      <link href="2021/05/25/13-Vue-Vuex%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/13-Vue-Vuex%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h3><ul><li>官方解释: Vuex是一个专门为Vue.js 应用程序开发的状态管理模式<ul><li>采用集中式存储管理应用的所有组件的状态, 并以相应的规则保证状态以一种可以预测的方式发生变化</li><li>Vuex 也继承到Vue官方调试工具 devtools extension, 提供了诸如零配置的 time-travel 调试 状态快照导入导出等高级调试功能</li></ul></li><li>官方解释其实有点晦涩难懂<ul><li>状态管理模式, 集中式存储管理其实</li><li>就是将需要多个组件共享的变量存储在一个对象中</li><li>然后将这个对象放在顶层的Vue实例中,让其他组件也可以使用</li><li>而且这个对象是响应式的, 这个优点是最牛逼的优点</li></ul></li><li>什么状态需要我们在多个组件间共享呢?<ul><li>用户的登陆状态,用户名称,头像,地理位置信息等等</li><li>商品的收藏,购物车中的物品</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们可以尝试一下自己写一下这个共享的对象</span></span><br><span class="line"><span class="comment">// 通过将数据集成在一个共享对象中, 然后将这个对象加入到Vue.prototype 原型对象中, 可以做到将对象中的数据共享出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用给Vue.prototype Vue的原型对象添加一个对象来达到所有组件都可以访问这个对象</span></span><br><span class="line"><span class="keyword">const</span> shareObj = &#123;</span><br><span class="line">  <span class="attr">name</span> : <span class="string">&quot;xiaoLam&quot;</span>,</span><br><span class="line">  <span class="attr">age</span> : <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">Vue.prototype.shareObj = shareObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是有一个问题, 这个共享对象不是响应式的, 所以我说vuex的共享数据是响应式的是最牛逼的优点</span></span><br></pre></td></tr></table></figure><h3 id="vuex基本使用"><a href="#vuex基本使用" class="headerlink" title="vuex基本使用"></a>vuex基本使用</h3><ul><li>vuex的安装<ul><li>在项目根目录下命令行输入 npm install vuex –save (运行时依赖安装)</li></ul></li><li>不建议在main.js中使用vuex</li><li>在项目目录下创建一个叫 store的文件夹, 里面创建一个名为 index.js 的文件, 在这个文件中编写vuex的代码</li><li>vuex插件基本使用 在store/index.js文件中<ul><li>引入 vue 和 vuex 因为vuex是依赖vue的</li><li>执行 Vue.use(Vuex) 执行 Vuex中的 install</li><li>创建Vuex实例: 注意,这里创建的是 Vuex.Store实例</li><li>在实例中创建一个 state对象, 在这个对象中写入想要共享的数据</li><li>导出实例</li></ul></li><li>在组件中使用vuex中的共享数据<ul><li>在main.js 中导入上面的实例</li><li>在根组件中注册store , 这样才可以在所有组件中通过 $store 获得store这个对象</li><li>在组件中使用 $store.state 获得这个包含共享数据的对象</li></ul></li><li>修改vuex中的共享数据<ul><li>其实我们可以通过 $store.state 来修改数据</li><li>但是vue官方不建议这样做</li><li>因为 State -&gt; Vue Components -&gt; Actions -&gt; Mutations -&gt; State 是一个单向循环</li><li>官方推荐做法是 我们通过 Vue Components 去修改 Actions 来修改 Mutations 最终达到修改 State 的目的</li><li>因为我们会需要知道是哪一个组件修改了State, 如果直接从 Vue Components 修改State的话就不能追踪是哪个组件修改了State</li><li>Backend API 会监测 Action的改变, Devtools 会监测 Mutations的改变, 按照官方的推荐做法就可以追踪是哪个组件修改了State</li><li>当然也可以跳过Actions, 通过 Vue Components -&gt; Mutations -&gt; State 修改 </li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 文件的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一步: 引入插件后, 调用Vue.use() 来进行install Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步: 创建Vuex实例: 注意这里创建的是 Vuex中的Store实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三步: 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是main.js中的代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./store&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 在根组件中注册 store, 这样就可以在所用组件通过 $store 来获得store这个对象</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用过$store.state 来获得store对象中的state中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>------------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;hello-vuex :count=&quot;count&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 后面会讲如何正确地修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$store.state.count--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue-devtools-和-mutations"><a href="#vue-devtools-和-mutations" class="headerlink" title="vue-devtools 和 mutations"></a>vue-devtools 和 mutations</h3><ul><li>什么是vuex-devtools<ul><li>这是一个vue官方的浏览器插件, 用于调试vue应用</li><li>这个插件可以用于监控mutations操作</li></ul></li><li>什么是mutations操作<ul><li>其实就是使用同步的操作去修改state共享数据</li></ul></li><li>简单来说, 浏览器插件vuex-devtools可以监控mutations操作, 达到追踪是什么组件修改了state共享数据的效果</li></ul><h3 id="vue-devtools-和-mutations-的使用的注意事项"><a href="#vue-devtools-和-mutations-的使用的注意事项" class="headerlink" title="vue-devtools 和 mutations 的使用的注意事项"></a>vue-devtools 和 mutations 的使用的注意事项</h3><ul><li><p>浏览器安装vue-devtools</p><ul><li>chrome应用商店搜索, vue.js devtools 安装即可</li><li>如果进入不了chrome应用商店, 可以离线下载谷歌访问助手</li><li>安装完成后会在浏览器开发者工具中多了一个”vue”选项卡</li></ul></li><li><p>通过mutations来修改state共享数据</p><ul><li>在 store/index.js 中的Vuex.Store实例中创建 mutations对象</li><li>在对象中编写方法</li><li>mutations中的方法默认会有一个名为state的参数, 这个state就是 state共享数据对象</li><li>定义好方法后, 通过提交的方式来调用方法</li><li>具体看以下代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是组件中定义的methods</span></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span><br><span class="line">    <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="以上就是Vuex最简单的使用了"><a href="#以上就是Vuex最简单的使用了" class="headerlink" title="以上就是Vuex最简单的使用了"></a>以上就是Vuex最简单的使用了</h3><ul><li>1.提取出一个公共的store对象，用于保存在多个组件中共享的状态</li><li>2.将store对象放置在new Vue对象中，这样可以保证在所有的组件中都可以使用到</li><li>3.在其他组件中使用store对象中保存的状态即可<ul><li>通过this.$store.state.属性的方式来访问状态</li><li>通过this.$store.commit(‘mutation中方法’)来修改状态</li></ul></li><li>注意事项：<ul><li>我们通过提交mutation的方式，而非直接改变store.state.count。</li><li>这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li></ul></li></ul><h3 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h3><ul><li>State, Getters, Mutation, Action, Module</li></ul><h3 id="Vuex概念理解-State单一状态树"><a href="#Vuex概念理解-State单一状态树" class="headerlink" title="Vuex概念理解-State单一状态树"></a>Vuex概念理解-State单一状态树</h3><ul><li>Vuex提出单一状态树, 什么是单一状态树呢?<ul><li>单一状态树英文名称为 Single Source of Truth 也可以翻译成单一数据源</li></ul></li><li>简单来说, 就是将所有的数据都放在同一个Store对象中, 不要因为数据的类型不同, 数据量多而分开放</li><li>如果我们将数据保存在多个Store对象中的话, 那么之后的管理和维护等都会变得特别困难</li><li>所以Vuex推荐使用单一状态树来管理应用层级的全部状态</li><li>单一状态树能够让我们用最直接的方式找到某个状态的片段,而且在以后的维护和调试过程中, 也可以非常方便地管理和维护</li><li>总的来说, 就是不要创建多个Store对象, 只创建一个!!! 所有数据, 所有方法, 都放在这个Store对象中</li></ul><h3 id="Vuex核心概念之-getters"><a href="#Vuex核心概念之-getters" class="headerlink" title="Vuex核心概念之 getters"></a>Vuex核心概念之 getters</h3><ul><li>如果我们需要将state中的共享数据经过处理后再将其渲染在页面中的话, 就需要使用 Vuex中的getters对象</li><li>实质上, getters 相当于Vue中的计算属性 computed</li><li>getters的使用<ul><li>在Vue.store实例中定义getters对象</li><li>在getters对象中定义方法</li><li>在getters对象中的方法都具有两个参数, state 和 getters<ul><li>state参数指向state对象</li><li>getters参数指向getters对象</li></ul></li><li>getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</li><li>在组件中通过 $store.getters 来获得这个getters对象</li></ul></li><li>具体使用方法看下列代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是 store/index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="attr">students</span> : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span> : &#123;</span><br><span class="line">    <span class="comment">// 在我们需要将共享数据进行处理后再展示在页面的情况下, 就需要使用getters对象, 相当于计算属性computed</span></span><br><span class="line">    <span class="comment">// getters中的方法也是有一个state参数, 指向state对象</span></span><br><span class="line">    <span class="function"><span class="title">powerCount</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * state.count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求1, 过滤state中的students, 取出年龄大于15的</span></span><br><span class="line">    <span class="function"><span class="title">getAge15</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; <span class="number">15</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求2, 获得年龄大于15的student的个数</span></span><br><span class="line">    <span class="function"><span class="title">getAge15Num</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// return state.students.filter(students =&gt; students.age &gt; 15).length</span></span><br><span class="line">      <span class="comment">// getters对象中的方法, 除了state这个参数外, 还有getters参数, 这个参数指向getters对象</span></span><br><span class="line">      <span class="comment">// 所以上面的写法可以写成</span></span><br><span class="line">      <span class="keyword">return</span> getters.getAge15.length</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 需求3, 想要通过用户输入的年龄, 来决定输出大于该年龄的student</span></span><br><span class="line">    <span class="comment">// getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">    <span class="comment">// 要达到这个需求的话, 需要在方法中返回一个函数, 具体如下</span></span><br><span class="line">    <span class="comment">// 思路是return出去一个函数, 这个函数有一个形参, 这个形参由用户来决定</span></span><br><span class="line">    <span class="function"><span class="title">getAge</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">students</span> =&gt;</span> students.age &gt; age)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过$store.getters 来获取getters中的数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.powerCount &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15 &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge15Num &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 传入参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; $store.getters.getAge(17) &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vuex核心概念之-mutations"><a href="#Vuex核心概念之-mutations" class="headerlink" title="Vuex核心概念之 mutations"></a>Vuex核心概念之 mutations</h3><ul><li>Vuex的store状态的更新唯一方式是: 提交 Muattion</li><li>Mutation主要包括两个部分<ul><li>字符串的事件类型(type)</li><li>一个回调函数是(handler), 这个回调函数的第一个参数就是state 指向state对象</li></ul></li><li>mutation的基本使用<ul><li>在 store/index.js 中的Vue.store实例中创建 mutations对象</li><li>这个对象中编写方法</li><li>这个对象中的方法中的第一个参数为 state , 指向state对象</li><li>后面的参数是Vue Components传递过来的额外参数(称为载荷Payload)</li><li>定义好方法后, 在组件中使用 $state.commit(“事件类型”) 提交, 达到更新状态的效果</li><li>具体使用看下列代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是 store/index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="attr">students</span> : [</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>, <span class="attr">age</span>:<span class="number">18</span> &#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&quot;kobe&quot;</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">112</span>, <span class="attr">name</span>: <span class="string">&quot;suoer&quot;</span>, <span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">id</span>:<span class="number">113</span>, <span class="attr">name</span>: <span class="string">&quot;yangcong&quot;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建mutations 对象</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// mutations 中的方法中默认会传入一个state的参数, 这个参数就是上面定义的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count--</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">    <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">      state.count += count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果参数的个数不是一个的时候, 我们可以传入一个对象</span></span><br><span class="line">    <span class="function"><span class="title">addStudent</span>(<span class="params">state,student</span>)</span> &#123;</span><br><span class="line">      state.students.push(student)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这些是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果向修改vuex中的共享数据, 可以通过 $store.state修改, 但是官方不建议, 不推荐, 不允许这样修改 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count++&quot;&gt;+&lt;/button&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;button @click=&quot;$store.state.count--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 官方建议这样来修改vuex中的共享数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addtion&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;subtraction&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(5)&quot;</span>&gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addCount(10)&quot;</span>&gt;</span>+10<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addStudent&quot;</span>&gt;</span>添加学生<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// ..</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里并不是直接使用 this.$store.mutation.increment() 来执行increment这个方法</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 而是用 this.$store.commit(&quot;方法名&quot;) 来提交要使用的方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;increment&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">subtraction</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;decrement&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果带有参数(载荷)， 则在 $store.commit(&quot;事件类型&quot;, 载荷)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$store.commit(&quot;incrementCount&quot;, count);</span></span></span><br><span class="line"><span class="javascript">      </span></span><br><span class="line"><span class="javascript">      <span class="comment">// </span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> student = &#123; <span class="attr">id</span>: <span class="number">115</span>, <span class="attr">name</span>: <span class="string">&quot;wuming&quot;</span>, <span class="attr">age</span>: <span class="number">40</span> &#125;;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果参数不止一个, 载荷也可以是一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addStudent&quot;</span>, student);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mutation提交风格"><a href="#Mutation提交风格" class="headerlink" title="Mutation提交风格"></a>Mutation提交风格</h3><ul><li>上面的通过commit进行提交时一种普通的方式</li><li>Vue还提供了另外一种风格, 它是一个包含type属性的对象</li><li>提交的风格不同, Mutation中的处理方式也会不同<ul><li>普通的提交方式, mutations中的payload就是传入的参数</li><li>包含type属性的对象提交风格, mutations中的payload是整个commit提交的对象</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 普通的提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(<span class="string">&quot;incrementCount&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个包含type属性的对象提交风格</span></span><br><span class="line">      <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;incrementCount&quot;</span>, <span class="comment">// type属性, 值为 &quot;事件类型&quot;</span></span><br><span class="line">        count, <span class="comment">// 后面跟的是需要传入的参数</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations : &#123;</span><br><span class="line">  <span class="comment">// 如果在mutations更新数据的时候, 携带一些参数的时候</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 下文的 payload 指 count形参</span></span><br><span class="line">    <span class="comment">// 普通的提交风格接收参数, 这个 payload 就是传入的参数</span></span><br><span class="line">    <span class="comment">// state.count += count</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个包含type属性的对象提交的时候, 这个payload就不是传入的参数了, 而是整个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(count); <span class="comment">// &#123;type: &quot;incrementCount&quot;, count: 5&#125;</span></span><br><span class="line">    <span class="comment">// 要获得传入的参数, 则是 payload.count</span></span><br><span class="line">    state.count += count.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutation的响应式规则"><a href="#Mutation的响应式规则" class="headerlink" title="Mutation的响应式规则"></a>Mutation的响应式规则</h3><ul><li>Vuex的store中的state是响应式的, 当state中的数据发生改变的时候, Vue组件也会跟着自动更新</li><li>如果我们想要使用响应式, 那么我们必须遵守一些Vuex的规则<ul><li>拥有响应式的数据必须提前在state中初始化所需的属性</li></ul></li><li>例如: 如果我们给一个对象添加一个新属性的话, 这个操作不是响应式的, 因为这个新属性没有提前在state中初始化</li><li>又例如: 我们给一个对象删除一个属性, 这个操作也不是响应式的</li><li>那么我们如何让这些操作达到响应式的效果呢?<ul><li>这是要是用 Vue.set() 和 Vue.delete() 这两个方法了<ul><li>Vue.set(要修改的数组或对象, Number/String, 修改后的值)</li><li>Vue.delete(要修改的数组或对象, Number/String)</li></ul></li><li>这两个方法Vue中的内部操作就是, 将要修改的属性添加到 Vue中的响应式系统中</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">info</span> : &#123; <span class="attr">id</span> : <span class="number">102</span>, <span class="attr">name</span> : <span class="string">&quot;fanghuonv&quot;</span>, <span class="attr">age</span> : <span class="number">16</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">infoUpdate</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 如果给state中的对象属性修改值, 这个操作是响应式的, 因为修改的属性提前在state种初始化了</span></span><br><span class="line">      <span class="comment">// state.info.age = 19;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象添加新的属性, 这个操作不是响应式的, 因为这个新属性并没有提前在state中初始化</span></span><br><span class="line">      <span class="comment">// state.info[&quot;address&quot;] = &quot;jisichang&quot;</span></span><br><span class="line">      <span class="comment">// 如果要想这个操作也变成响应式的话, 就要使用Vue.set(要修改的数组或对象, Number/String, 修改后的值)</span></span><br><span class="line">      <span class="comment">// Vue.set(state.info, &quot;address&quot;, &quot;jisichang&quot;) </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果给state中的对象删除属性, 这个操作也不是响应式的</span></span><br><span class="line">      <span class="comment">// delete state.info.id;</span></span><br><span class="line">      <span class="comment">// 如果想要这个操作也变成响应式的话, 就要使用Vue.delete(要修改的数组或对象, Number/String)</span></span><br><span class="line">      Vue.delete(state.info, <span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Vue.set() 和 Vue.delete() 这两个方法内部会将 要修改的属性也一起添加到Vue的响应式系统里面了 </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation常量类型"><a href="#Mutation常量类型" class="headerlink" title="Mutation常量类型"></a>Mutation常量类型</h3><ul><li>在mutation中, 我们定义了很多事件类型(也就是其中的方法名称)</li><li>当我们的项目越来越大的时候, Vuex管理的状态越来越多, 需要更新状态的情况也越来越多, 那么就意味着Mutation中的方法越来越多</li><li>方法过多的时候, 使用者需要花费大量的精力去记住这些方法,甚至是多个文件间切换, 查看方法名称, 甚至如果不是复制方法名称的时候, 还有可能出现写错的情况</li><li>那么如何解决上述的问题呢?<ul><li>一种常见的方案就是使用常量替代Mutation事件类型</li><li>我们可以将这些常量放在一个单独的文件中, 方便管理以及让整个app所有的事件类型都一目了然</li></ul></li><li>具体做法<ul><li>在store文件夹中创建一个名为 mutations-type.js 的文件</li><li>定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是store/mutations-type.js中的代码</span></span><br><span class="line"><span class="comment">// 在这里定义常量 用于 替代Mutation事件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&quot;increment&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT =<span class="string">&quot;decrement&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT_COUNT =<span class="string">&quot;incrementCount&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_STUDENT = <span class="string">&quot;addStudent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INFO_UPDATE = <span class="string">&quot;infoUpdate&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是组件中的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 引入定义常量名称的文件</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123;</span></span><br><span class="line"><span class="javascript">  INCREMENT,</span></span><br><span class="line"><span class="javascript">  DECREMENT,</span></span><br><span class="line"><span class="javascript">  INCREMENT_COUNT,</span></span><br><span class="line"><span class="javascript">  ADD_STUDENT,</span></span><br><span class="line"><span class="javascript">  INFO_UPDATE,</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">from</span> <span class="string">&quot;./store/mutations-type&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">addtion</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里就可以直接使用常量名字代替mutation事件类型了</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(INCREMENT);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是 store/index.js 中的文件</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT,</span><br><span class="line">  DECREMENT,</span><br><span class="line">  INCREMENT_COUNT,</span><br><span class="line">  ADD_STUDENT,</span><br><span class="line">  INFO_UPDATE,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./mutations-type&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="comment">// 定义mutation方法的时候, 可以使用ES2015中的风格, 使用一个常量来作为函数的名称</span></span><br><span class="line">    [INCREMENT](state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mutation同步函数"><a href="#Mutation同步函数" class="headerlink" title="Mutation同步函数"></a>Mutation同步函数</h3><ul><li>通常情况下, Vuex要求我们的Mutation中的方法必须都是同步方法<ul><li>原因是, 当我们使用devtools时, devtools可以帮助我们捕捉mutation的快照</li><li>但是如果时异步操作的话, devtools就不能追踪这个异步操作是什么时候被完成</li></ul></li><li>所以, 通常情况下, 不能在mutation种进行异步操作</li></ul><h3 id="Action的基本定义"><a href="#Action的基本定义" class="headerlink" title="Action的基本定义"></a>Action的基本定义</h3><ul><li>如果我们需要在Vuex中进行一些异步操作, 比如网络请求</li><li>这个时候我们就要将异步操作在actions中进行</li><li>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的<ul><li>actions中定义方法与在mutation中定义方法的方式基本一样</li><li>要注意的是, actions中的方法中第一个参数不是state 而是 context<ul><li>context 意为 上下文, 指向store 对象</li></ul></li><li>还有一点, 组件中向actions提交事件类型, 并不是通过 commit, 而是通过 dispatch</li></ul></li><li>actions的基本使用<ul><li>注意: 我们不可以直接在actions中通过异步操作直接更新store的状态</li><li>更新store的状态的唯一方式为 mutations</li><li>所以actions中的方法实质上只是一个中转站, 更新store的状态这个操作最终还是要在mutations中进行</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是store/index.js中的代码</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    [INFO_UPDATE](state) &#123;</span><br><span class="line">      <span class="comment">// actions中的方法最终还是要回到mutations中来更新store的状态</span></span><br><span class="line">      state.info.name = <span class="string">&quot;huixinge&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span> : &#123;</span><br><span class="line">    <span class="comment">// 在actions中编写方法, 跟在mutations中编写方法差不多, 但是方法中传入的第一个参数并不是state, 而是 context</span></span><br><span class="line">    <span class="comment">// context意为 上下文, 可以理解为store这个对象</span></span><br><span class="line">    <span class="comment">// 如果想要传入参数, 也是跟mutations中的方法一样, 也是有普通方式, 和传入一个包含type属性的对象方式</span></span><br><span class="line">    [A_INFO_UPDATE](context) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需求, 需要异步操作完成后, 给组件返回一个信息</span></span><br><span class="line">    <span class="comment">// 第一种方式, 通过组件传参的时候传入一个函数, 在actions中进行异步操作, 异步操作完成后回调这个函数</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 注意, 不能再actions的方法中更新store的状态, 要记住一点, 更新store状态的唯一方式是mutations中的方法</span></span><br><span class="line">        <span class="comment">// 所以这里做的操作是使用 commit 提交</span></span><br><span class="line">        context.commit(INFO_UPDATE)</span><br><span class="line">        <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">        payload.finsh();</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种方式不够优雅, vue官方推荐我们通过 return 一个new Promise 对象来实现</span></span><br><span class="line">    [A_INFO_UPDATE](context, payload) &#123;</span><br><span class="line">      <span class="comment">// 在这里return 出去的是回到组件那里的, 所以组件那里的代码可以用then</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          context.commit(INFO_UPDATE)</span><br><span class="line">          <span class="built_in">console</span>.log(payload.message);</span><br><span class="line">          resolve(<span class="string">&quot;完成了完成了&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是组件中的代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">aInfoUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 提交给actions 要用 dispatch 而不是commit</span></span><br><span class="line">      <span class="comment">// commit是提交给mutations的</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(A_INFO_UPDATE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第一种方式: 通过传入一个函数, 在异步操作完成后进行回调</span></span><br><span class="line">      <span class="built_in">this</span>.$store.dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>: A_INFO_UPDATE,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        <span class="function"><span class="title">finsh</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;完成了&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 第二种方式: 通过 Promise 对象</span></span><br><span class="line">      <span class="built_in">this</span>.$store</span><br><span class="line">        .dispatch(&#123;</span><br><span class="line">          <span class="attr">type</span>: A_INFO_UPDATE,</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// actions中return回来的 Promise 是在这里的, 所以这里能用then</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="认识Module"><a href="#认识Module" class="headerlink" title="认识Module"></a>认识Module</h3><ul><li>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<ul><li>Vue使用单一状态树, 那就意味着很多状态都会交给同一个store管理</li><li>当应用变得非常复杂的时候, store对象就会变得十分臃肿</li><li>为了解决这个问题啊,Vuex允许我们将store分割成模块(Module), 而每个模块都拥有自己的state, mutations, actions, getters</li></ul></li><li>实质就是将共性多的store抽离出去, 这样易于后期维护</li><li>在Module中的 state, mutations, actions, getters 和原来的没有什么区别</li><li>只是有一些需要注意的点<ul><li><ol><li>在组件中想要使用模块中的state共享数据, 通过 $store.state.模块名.数据名 , 来获取</li></ol></li><li><ol start="2"><li>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象.</li></ol></li><li><ol start="3"><li>在actions中的第一个参数里面 可以通过 context.rootState 来获取根的state</li></ol></li><li><ol start="4"><li>在actions中使用 context.commit(“事件类型”) 是提交给模块中的mutations, 而不是根的</li></ol></li><li><ol start="5"><li>在getters的方法中, 拥有第三个参数 rootState, 这个参数指向根的state</li></ol></li><li><ol start="6"><li>其余大多数使用方法与原本的一致</li></ol></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ModuleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">name</span> : <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">    <span class="comment">// 在组件中如果要获取这个name, 则是通过 $store.state.ModuleA.name 来获取</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="number">111</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullName2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName + <span class="number">222</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 除了基本的写法外, 模块中的getters中的函数还有第三个参数, 为 rootState, 指向根的state</span></span><br><span class="line">    <span class="function"><span class="title">fullName3</span>(<span class="params">state,getters,rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullName2 + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span> : &#123;</span><br><span class="line">    <span class="function"><span class="title">nameUpdate</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span> : &#123;</span><br><span class="line">    <span class="comment">// context 意为上下文 所以这里指向这个模块</span></span><br><span class="line">    <span class="function"><span class="title">AnameUpdate</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(context);</span></span><br><span class="line">        context.commit(<span class="string">&quot;nameUpdate&quot;</span>, payload)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span> : &#123;</span><br><span class="line">    <span class="attr">count</span> : <span class="number">100</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">modules</span> : &#123;</span><br><span class="line">    ModuleA</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>当我们Vuex帮助我们管理过多内容的时候, 会发现index.js文件变得很乱, 我们要将index.js文件解构, 让我们的代码更加清晰</li><li>以下操作都在store文件夹中进行<ul><li>创建getters.js文件, 将index.js中的getters对象抽取到这个文件中</li><li>创建mutations.js文件, 将index.js中的mutations对象抽取到这个文件中</li><li>创建actions.js文件, 将index.js中的actions对象抽取到这个文件中</li><li>创建modules文件夹, 里面创建ModuleA.js文件, 将ModuleA模块抽取到这个文件中</li></ul></li><li>这样我们的代码就变得很清晰了, 方便后期的维护和更新</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-Vue-Router路由详解</title>
      <link href="2021/05/25/12-Vue-Router%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/12-Vue-Router%E8%B7%AF%E7%94%B1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><ul><li>路由是一个网络工程中的一个术语<ul><li>路由(routing) 就是通过互联的网络把信息从源地址传输到目的地址的活动</li></ul></li><li>路由器提供了两种机制: 路由和传送<ul><li>路由是绝对数据包从来源到目的地的路径</li><li>传送将输入端的数据转移到合适的输出段</li></ul></li><li>路由中有一个非常重要的概念叫路由表<ul><li>路由表本质就是一个映射表, 决定了数据包的指向</li></ul></li><li>相关概念<ul><li>内网IP, 每一个链接上网络的设备都有一个内网IP, 这个内网IP是为了区分链接同一个局域网的不同设备, 在同一个局域网中的每个设备的内网IP是唯一的</li><li>公网IP, 公网IP是一个局域网对外链接是用于区分不同局域网的, 每一个局域网的公网IP都是唯一的</li><li>路由中有一个映射表, 将局域网中的内网IP和设备的mac地址对应起来</li></ul></li><li>举个例子<ul><li>现在有一条信息从北京发到广东</li><li>这条信息途中会进过很多路由, 并根据公网IP找到对应的局域网</li><li>再通过路由中的映射表, 找到要传送的设备mac地址对应的内网IP, 再传送给正确的设备</li></ul></li></ul><h3 id="认识web开发的三个阶段"><a href="#认识web开发的三个阶段" class="headerlink" title="认识web开发的三个阶段"></a>认识web开发的三个阶段</h3><h4 id="后端路由阶段"><a href="#后端路由阶段" class="headerlink" title="后端路由阶段"></a>后端路由阶段</h4><ul><li>在早期的网站开发中, 整个HTML页面都是由服务器渲染出来的</li><li>用户在浏览器中输入URL后, 浏览器向服务器发出请求</li><li>服务器直接生产整个渲染好的html页面, 返回给客户端进行展示</li><li>一个网站有那么多个页面, 服务器是怎么处理的呢?<ul><li>一个页面对应一个URL</li><li>URL会发送给服务器, 服务器通过正则对URL进行匹配, 并且最后交给一个Controller进行处理</li><li>Controller进行各种各样的处理后, 将最终生成的HTML页面, 返回给前端</li><li>这就完成了一个IO(input/output)操作</li></ul></li><li>以上的操作就是后端路由(也称为后端渲染)<ul><li>当页面需要请求不同的页面路径内容的时候, 全部交给后端服务器处理, 后端服务器渲染好整个页面后, 将页面返回给客户端</li><li>这种情况下渲染好的页面, 不需要单独加载任何的js和css, 因为在后端服务器已经加载完毕了, 可以直接交给浏览器展示, 这样的操作有利于SEO(搜索优化)</li></ul></li><li>后端路由(后端渲染)的缺点<ul><li>整个页面的模块由后端人员来编写和维护</li><li>前端开发人员如果要开发页面, 需要通过PHP和java等语言来编写页面代码</li><li>而且通常情况下, HTML代码和数据以及它们的对应逻辑会混合在一起, 编写和维护都是非常糟糕的事情</li></ul></li><li>总流程就是, 后端路由就是, 客户端输入URL请求页面, 服务器端接收URL, 服务器端处理URL和页面的映射关系, 服务器端通过java从数据库中读取数据结合html和css加载整个页面, 将整个页面返回给客户端</li></ul><h4 id="前后端分离阶段"><a href="#前后端分离阶段" class="headerlink" title="前后端分离阶段"></a>前后端分离阶段</h4><ul><li>随着Ajax的出现, 就有了前后端分离的开发模式</li><li>前端通过Ajax请求数据, 后端提供API来返回数据, 前端通过JavaScript将返回来的数据渲染到页面中</li><li>这样做的最大优点就是将前后端的责任清晰化, 前端专注于交互和可视化, 后端专注于数据</li><li>并且在移动端(IOS/Android)出现后, 后端不需要再开发其他的接口, 依然使用之前的一套API即可</li><li>目前很多网站都是采用这种开发模式</li><li>总流程是, 前后端分离就是, 客户端输入URL请求页面的时候, 服务器会先从静态资源服务器中返回html+css+js, 然后在前端使用js代码通过Ajax请求API数据, 服务器端再提供API接口服务, 在前端接收到API数据后渲染页面</li><li>大部分代码都是在前端执行并渲染的, 所以叫前端渲染</li></ul><h4 id="单页面富应用-SPA-阶段"><a href="#单页面富应用-SPA-阶段" class="headerlink" title="单页面富应用(SPA)阶段"></a>单页面富应用(SPA)阶段</h4><ul><li>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由</li><li>也就是前端来维护一套路由规则</li><li>静态资源服务器中的html+css+js代码只有一套, 这一套代码包含了很多的组件, 用户在客户端请求页面的时候, 会将这一套代码全部返回给客户端, 用户在该页面请求其他页面的时候, 通过前端路处理URL和页面映射关系, 然后通过Ajax请求API数据, 实现显示不同的组件</li></ul><h4 id="一些概念问题"><a href="#一些概念问题" class="headerlink" title="一些概念问题"></a>一些概念问题</h4><ul><li>如何区分前端渲染和后端渲染<ul><li>前端渲染就是大部分代码都是在前端执行并且渲染</li><li>后端渲染是指客户端请求页面时, 后端服务器渲染整个页面并返回,称为后端渲染</li></ul></li><li>什么是前后端分离<ul><li>前端负责页面交互和可视化, 通过Ajax来请求数据, 后端专注于数据</li></ul></li><li>什么是前端路由,什么是后端路由<ul><li>前端路由是指, 在前端处理URL和页面的映射关系</li><li>后端路由是指, 在客户端发送URL请求后, 在后端服务器处理URL和页面的映射关系</li></ul></li></ul><h3 id="前端路由的核心-改变URL-但是页面不进行整体的刷新"><a href="#前端路由的核心-改变URL-但是页面不进行整体的刷新" class="headerlink" title="前端路由的核心: 改变URL, 但是页面不进行整体的刷新"></a>前端路由的核心: 改变URL, 但是页面不进行整体的刷新</h3><ul><li>通过改变URL的hash值<ul><li>URL的hash也就是锚点(#), 本质是改变window.loaction和href属性</li><li>我们可以通过直接复制loaction.hash来改变href, 但是页面不发生刷新</li></ul></li><li>通过HTML5的history模式: pushState<ul><li>history接口时HTML5新增的, 它有五种模式改变URL而不刷新页面<ul><li>history.pushState(state, title, url), 通过栈结构压入一个新的URL</li><li>history.replaceState(), 修改当前的 history 实体。通过这个接口改变的URL, 不能使用history.back() 后退历史记录</li><li>history.go(num) 前进或者后退指定数量历史记录 num可以时负数, 代表后退</li><li>history.back() 后退, 相当于history.go(-1)</li><li>history.forward() 前进, 相当于history.go(1)</li></ul></li></ul></li></ul><h3 id="vue-router的安装"><a href="#vue-router的安装" class="headerlink" title="vue-router的安装"></a>vue-router的安装</h3><ul><li>我们已经学习过webpack了, 后续开发都是通过工程化的方式进行开发<ul><li>所以在后续, 我们直接使用npm进行安装路由即可</li></ul></li><li>步骤一: 安装路由vue-router (在使用脚手架初始化项目的时候, 会询问是否安装vue-router, 如果安装过了可以在package.json中看到已经有vue-router模块了, 那就不需要再安装了, 如果当时没有安装, 那么现在就可以用npm安装)<ul><li>在当前项目目录下, 命令行输入 npm install vue-router –save(注意时运行时依赖安装)</li></ul></li><li>步骤二: 在模块化工程中使用路由(因为vue-router是一个插件, 所以要通过Vue.use()来安装路由功能)<ul><li>第一步: 在src文件夹中的router文件夹中的index.js文件中(遵循模块化管理代码), 导入vue-router和vue, 并且调用Vue.use()来安装路由功能<ul><li>为什么要使用Vue.ues(), Vue.use() 会去执行插件中的 install方法</li></ul></li><li>第二步: 创建路由实例, 并且编写路由映射配置</li><li>第三步: 在Vue实例中挂载创建的路由实例 </li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是src/router/index.js 中的代码</span></span><br><span class="line"><span class="comment">// 引入路由需要的相关模块 vue 和 vue-router</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建路由需要三步</span></span><br><span class="line"><span class="comment">// 1. 通过Vue.use() 使用路由</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个路由实例</span></span><br><span class="line"><span class="comment">// 抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  <span class="comment">// 注意这个option名 必须是routes</span></span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将路由导出, 并在main.js中的Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在main.js中导入并在Vue实例中挂载创建的路由实例</span></span><br><span class="line"><span class="comment">// 导入router路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 挂载路由实例</span></span><br><span class="line">  <span class="comment">// router : router  可以简写成, 对象增强语法</span></span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="vue-router的使用"><a href="#vue-router的使用" class="headerlink" title="vue-router的使用"></a>vue-router的使用</h3><ul><li>第一步: 创建路由组件, 因为路由时一个一个的url和组件的映射关系, 所以先创建好路由组件</li><li>第二步: 配置路由映射, 在router文件夹中的index.js 中配置组件和路径的映射关系</li><li>第三步: 在根组件中, 通过标签 router-link  和  router-view 使用路由<ul><li>router-link&gt;: 这个标签是一个vue-router中内置的组件, 它最终会被渲染成一个 a 标签</li><li>router-view&gt;: 这个标签会根据当前的路径, 动态渲染出不同的组件</li><li>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等等回合 router-view&gt; 处于同一个等级</li><li>在路由切换的时候, 切换的是 router-view&gt; 中挂载的组件, 其他内容是不会发生改变的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里时在src/components文件夹中的两个子组件</span></span><br><span class="line"><span class="comment">// 这些是Home组件中的代码</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是Home内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时About组件的代码</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是关于里面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;About&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">message</span>: <span class="string">&quot;这里是关于&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些是src/router文件夹中的index.js代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;../components/Home.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;../components/About.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是抽离出来的路由与组件的映射关系</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// 一条映射信息就是一个对象, 对象中的path和component构成一个映射</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    <span class="attr">component</span>: Home <span class="comment">// 挂载组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 在根组件中的template中使用<span class="tag">&lt;<span class="name">router-link</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">router-view</span>&gt;</span> 来使用路由</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> // 这个标签会根据 to属性中的值来修改 url, 此时<span class="tag">&lt;<span class="name">router-view</span>&gt;</span>显示对应的组件</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span>  // 这个标签是用来决定组件显示的位置的</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h3><ul><li>在通常情况下, 我们输入网站URL, 进入网站的首页, 我们希望 router-view  直接渲染出首页的内容</li><li>但是现在, 默认是没有显示首页的组件内容的, 而是要用户点击了首页的 router-link 标签才会显示</li><li>那么如何让路径默认跳转到首页, 而且 router-view  渲染首页组件呢?<ul><li>非常简单, 只要在路由配置中多配置一个映射就可以了<ul><li>配置内容为 path: “/“ 这里的意思是, 配置根路径</li><li>redirect : “/name” redirect翻译为重定向, 就是重新定义方向</li></ul></li><li>配置解析<ul><li>在routes中新配置一个映射</li><li>path 配置的是一个根路径 “/“</li><li>redirect是重定向, 表示我们将根路径重新定向到 /home 的路径下,这样我们就可以等我们想要的结果了</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置的index.js文件</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&quot;/&quot;</span>, <span class="comment">// 将path配置为根路径</span></span><br><span class="line">    <span class="attr">redirect</span> : <span class="string">&quot;/home&quot;</span> <span class="comment">// 重定向, 将根路径重新定向给 /home</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="HTML5的History模式"><a href="#HTML5的History模式" class="headerlink" title="HTML5的History模式"></a>HTML5的History模式</h3><ul><li>通过改变hash值来改变网页的URL, 地址末尾会有一个/# 不好看</li><li>如果通过HTML5的history模式来改变网页的URL, 地址就会好看很多</li><li>只要进行对路由配置文件进行简单的配置即可<ul><li>在路由配置文件中那个的router实例中添加一个option</li><li>mode : “history” 其实这个option值默认是hash, 只是我们手动把它改成history而已</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置文件 index.js 的代码</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 编写路由与组件的映射关系, 可以将其抽离出去</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 将修改url中的hash值来改变展示的组件, 转换为通过history方法来改变</span></span><br><span class="line">  <span class="attr">mode</span> : <span class="string">&quot;history&quot;</span> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="router-link-标签的补充"><a href="#router-link-标签的补充" class="headerlink" title="router-link 标签的补充"></a>router-link 标签的补充</h3><ul><li>在前面我们只用了 to 这个属性来指定跳转的路径</li><li>router-link 还有一些其他的属性<ul><li>tag : router-link标签默认最终会渲染成 a 标签, 通过tag 属性, 我们可以修改router-link标签最终会渲染成什么标签, 比如设置 tag=”button”, 则该router-link标签最终会被渲染成button标签</li><li>replace : replace不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个路径, 使用方法: 直接给router-link标签添加replace属性即可, 这个属性没有值</li><li>active-class: 当router-link标签对应的路由匹配成功时, 会自动给当前标签设置了一个router-link-active的class类名, 我们可以通过这个类名修改活动的router-link标签的样式, 设置active-class可以修改这个router-link-active这个默认类名<ul><li>关于router-link-active类, 在进行高亮显示的导航菜单或者底部tabbar时, 会使用这个类</li><li>一般不会修改这个默认的类名, 直接使用默认的router-link-active类名即可</li></ul></li><li>还有另外一种方法改变router-link-active这个默认类名<ul><li>在路由配置文件 index.js中的路由实例对象中添加 linkActiveClass 选项, 值为要修改成的类名, 也可以修改这个默认类名</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过tag改变最终渲染成的标签</span><br><span class="line">    // 通过replace禁止使用后退功能</span><br><span class="line">    // 通过active-class改变默认的 router-link-active 类名</span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;首页&lt;/router-link&gt;</span></span><br><span class="line"><span class="comment">    &lt;router-link to=&quot;/about&quot; tag=&quot;button&quot; replace active-class=&quot;active&quot;&gt;关于&lt;/router-link&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过代码来实现路由跳转"><a href="#通过代码来实现路由跳转" class="headerlink" title="通过代码来实现路由跳转"></a>通过代码来实现路由跳转</h3><ul><li>有的时候, 页面的跳转可能需要执行对应的JS代码, 这个时候可以使用第二种跳转方式</li><li>本质上为跳转的标签监听事件, 通过methods方法来实现跳转<ul><li>注意不能在方法中通过修改 history.pushState 的值来实现跳转, 这样会跳过了 vue-router 组件</li><li>$router时vue-router 模块给每一个组件构造器添加的</li><li>通过 this.$router.push(“要跳转的路径”) 来实现跳转</li><li>如果想要禁止后退功能, 那么就将push方法改成replace方法即可</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过代码来实现路由跳转 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;aboutClick&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 通过监听事件来使用 $router 中的方法来实现跳转</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这个$router 时vue-router 模块绑定到所有的组件构造器中的</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/home&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果想要做到禁用后退键的效果, 可以使用replace方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/home&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&quot;/about&quot;);</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.replace(<span class="string">&quot;/about&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ul><li>在某些情况下, 一个页面的path路径是不确定的, 比如我们进入用户界面的时候, 希望路径是这样的<ul><li>/user/aaa 或者 /user/bbb</li><li>除了前面的/user之外, 后面还跟上了用户的ID</li><li>这种path和component的匹配关系, 我们称为动态路由</li></ul></li><li>如何实现动态路由<ul><li>第一步: 在组件的路由设置中path, 通过冒号 : 表示后面的路径是不确定的</li><li>第二步: 使用v-bind 绑定根组件的 router-link 中的 to 属性, 使其值 = 确定的路径 + 一个从data传过来的数据</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里使路由设置index.js的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span> : <span class="string">&quot;/user/:userId&quot;</span>,  <span class="comment">// 这里的 /user/ 为确定的路径, :userId 为不确定的路径, 不过要记住冒号后面的名字, 因为可以在组件中获取这个名字 </span></span><br><span class="line">    <span class="attr">component</span> : User</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 通过v-bind绑定 to 来使to可以使用组件构造器中的数据</span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27; + Id&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> <span class="attr">replace</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;App&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">Id</span>: <span class="string">&quot;lisi&quot;</span>,  <span class="comment">// 这个Id 模拟从服务器接收的数据</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传递活动的路由的数据"><a href="#传递活动的路由的数据" class="headerlink" title="传递活动的路由的数据"></a>传递活动的路由的数据</h3><ul><li>前面讲到vue-router 有一个 $router 对象, 里面有方法可以实现路径的跳转</li><li>vue-router 中还有一个对象, 为 $route , 这个对象获取的是页面中当前活跃的路由</li><li>$route是一个路由对象 (route object) 表示当前激活的路由的状态信息，包含了当前 URL 解析得到的信息，还有 URL 匹配到的路由记录 (route records)。</li><li>这个对象有很多属性, 可以查看 vue-router 的官方文档</li><li>$route.params 这个属性是一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; userId &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;User&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">userId</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// $route对象, 是页面中当前活跃的路由</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过params获取路由中的path 中对应的字符串</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.userId;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue打包文件解析"><a href="#vue打包文件解析" class="headerlink" title="vue打包文件解析"></a>vue打包文件解析</h3><ul><li>命令行输入 npm run build 后, 就会对项目进行打包<ul><li>打包完成后项目中会生成一个新的文件夹名叫 dist</li></ul></li><li>dist文件夹解析<ul><li>static文件夹: 里面包含两个文件夹, css文件夹 和 js文件夹<ul><li>css文件夹: 里面存放的是我们的css代码</li><li>js文件夹: 里面存放的是我们的js代码<ul><li>app.xxxx.js文件: 存放的是我们的业务代码, 也就是我们自己写的代码</li><li>manifest.xxxxx.js文件: 存放的是底层支撑的代码, 比如说, 支撑模块和模块之间的导入导出等等</li><li>vendor.xxxxx.js文件: 存放的是提供商也就是第三方的代码, 比如, vue的代码, vue-router的代码等等</li></ul></li></ul></li><li>index.html文件: 入口HTML文件</li></ul></li></ul><h3 id="认识路由的懒加载"><a href="#认识路由的懒加载" class="headerlink" title="认识路由的懒加载"></a>认识路由的懒加载</h3><ul><li>官方解释<ul><li>在打包构建应用的时候, JavaScript 文件会变得非常大, 会影响页面的加载</li><li>如果我们能把不同路由对应的组件分割成不同的代码块, 然后当路由被访问的时候才加载对应组件, 这样就更加高效了</li></ul></li><li>通俗地说<ul><li>首先, 我们知道路由中通常会定义很多不同的页面</li><li>但是这些页面最后都被打包到一个js文件中</li><li>那么多的页面全放在一个js文件中, 这个页面必然会很大</li><li>如果我们一次性从服务器请求下这个页面, 可能会花费一定的事件, 甚至用户的电脑上还出现了短暂空白的情况</li><li>要避免这种情况, 就要使用路由懒加载</li></ul></li><li>路由懒加载做了什么<ul><li>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块, 一个组件打包成一个js文件</li><li>在当这个路由被访问到的时候, 才加载对应的组件</li></ul></li></ul><h3 id="懒加载的方式"><a href="#懒加载的方式" class="headerlink" title="懒加载的方式"></a>懒加载的方式</h3><ul><li>每种方式的使用方法都是改变路由配置 index.js 文件中的导入组件的方式来达到懒加载</li><li>方式一: 结合Vue的异步组件和webpack的代码分析 (这种方式已经很古老了, 不用了嗷)<ul><li>const Home = resolve =&gt; { require.ensure([‘../components/Home.vue’], () =&gt; { resolve(require(‘../components/Home.vue’)) })};</li></ul></li><li>方式二: AMD写法 (比方式一好一点)<ul><li>const Home = resolve =&gt; require([‘../components/Home.vue’], resolve);</li></ul></li><li>方式三: 在ES6中, 我们有更加简单的写法来组织Vue异步组件和Webpack的代码分割 (代码简洁, 推荐)<ul><li>const Home = () =&gt; import(“../components/Home.vue”)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件中的代码</span></span><br><span class="line"><span class="comment">// 引入相关的组件</span></span><br><span class="line"><span class="comment">/* import Home from &quot;../components/Home&quot;;</span></span><br><span class="line"><span class="comment">import About from &quot;../components/About&quot;;</span></span><br><span class="line"><span class="comment">import User from &quot;../components/User&quot;; */</span>  <span class="comment">// 不用这里的引入方法了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用懒加载来引入相关组件</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/Home&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/About&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> User = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../components/User&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><ul><li>嵌套路由是一个很常见的功能<ul><li>比如在home页面中, 我们希望通过 /home/news 和 /home/message 访问一些内容</li><li>一个路径映射一个组件, 访问这两个路径也会分别渲染两个组件</li></ul></li><li>实现嵌套路由有两个步骤<ul><li>第一步: 创建对应的子组件, 并在路由映射中配置对应的子路由<ul><li>注意!!! 嵌套的子路由path的路径前不能加 /</li></ul></li><li>第二步: 在组件内部使用 router-view 标签</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 这里是创建的两个子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in news&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HomeNews&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">news</span>: [<span class="string">&quot;新闻1&quot;</span>, <span class="string">&quot;新闻2&quot;</span>, <span class="string">&quot;新闻3&quot;</span>, <span class="string">&quot;新闻4&quot;</span>],</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in messages&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;HomeMessage&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">messages</span>: [<span class="string">&quot;消息1&quot;</span>, <span class="string">&quot;消息2&quot;</span>, <span class="string">&quot;消息3&quot;</span>, <span class="string">&quot;消息4&quot;</span>],</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是路由配置 index.js 文件</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>,  <span class="comment">// 用的是path, 而不是url, 因为url是一个完整的地址, 我们只需要修改地址中的一部分, 所以用path</span></span><br><span class="line">    <span class="attr">component</span>: Home, <span class="comment">// 挂载组件</span></span><br><span class="line">    <span class="comment">// 在路由的内部添加children 的option来定义子路由, 数组类型</span></span><br><span class="line">    <span class="attr">children</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">redirect</span> : <span class="string">&quot;news&quot;</span> <span class="comment">// 设置默认路由</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        <span class="attr">component</span> : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        <span class="attr">component</span> : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><ul><li>一般来说一个URL长这样: scheme://host.domain:port/path?query#fragment<ul><li>scheme: 协议</li><li>host: 主机</li><li>domain: 域名</li><li>port: 端口号</li><li>path: 路径</li><li>query: 查询</li><li>fragment: 片段, hash</li></ul></li></ul><h3 id="传递参数的方式"><a href="#传递参数的方式" class="headerlink" title="传递参数的方式"></a>传递参数的方式</h3><ul><li>传递参数主要有两种类型: params 和 query</li><li>params的类型<ul><li>配置路由格式: /router/:id</li><li>传递的方式: 在path后面跟上对应的值</li><li>传递后形成的路径: /router/123, /router/abc</li><li>前面标题为 传递活动的路由的数据 有详细用法</li></ul></li><li>query的类型<ul><li>配置路由格式: /router, 也就是普通配置</li><li>传递的方式: 对象中使用query的key作为传递方式</li><li>传递后形成的路径: /router?id=123, /router?id=abc</li><li>具体操作<ul><li>第一步, 用v-bind为想要传递的router-link标签的 to 属性进行属性绑定, 值为一个对象, 对象中有两个属性, 第一个是path, 值为要传递的路由路径, 第二个为query, 值为一个对象, 里面为要传递的数据</li><li>第二步, 在对应的子组件中, 在组件构造器中computed中使用 $route.query 来接收传递过来的数据,</li><li>第三步, 处理数据, 使用数据</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 第一步 这里是根组件的代码</span><br><span class="line">&lt;router-link :to=&quot;&#123; path: &#x27;/profile&#x27;, query: &#123; name: &#x27;xiaoLam&#x27;, age: 18, height: 1.7 &#125;&#125;&quot; tag=&quot;button&quot;&gt;档案&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是Profile组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是Profile里的信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      // 使用数据</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, key) in userData&quot;</span>&gt;</span>&#123;&#123; key &#125;&#125; : &#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">name</span>: <span class="string">&quot;Profile&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">userData</span>(<span class="params"></span>)</span> &#123;  <span class="comment">// 接收传递过来的数据</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// 这里的$route对象是Vue中prototype中的对象, 这个对象是当前活跃的路由组件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">return</span> <span class="built_in">this</span>.$route.query;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和 $router 的区别"></a>$route 和 $router 的区别</h3><ul><li>$router本质是VueRouter实例, 就是一个对象包含所有的路由, 想要导航到不同的URL, 则使用 $router.push() 方法</li><li>$route为当前活跃的路由组件对象</li></ul><h3 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h3><ul><li>为什么我们可以在各个组件中使用 $router 和 $route?<ul><li>是因为所有组件都是来自, Vue类的原型prototype</li><li>而Vue类的原型prototype中就定义了, $router 和 $route, 而且通过一些方法将所有的路由赋值给了$router, 将当前活跃的路由组件赋值给了$route</li><li>所以我们可以在组件中使用这两个属性</li></ul></li><li>为什么我们可以在组件模板中中使用  router-link  和  router-view  这两个标签<ul><li>是因为Vue在全局中注册了这两个组件</li></ul></li></ul><h3 id="为什么要使用导航守卫"><a href="#为什么要使用导航守卫" class="headerlink" title="为什么要使用导航守卫"></a>为什么要使用导航守卫</h3><ul><li>需求, 在一个SPA应用中, 如何修改网页的标题呢?<ul><li>网页标题是通过 title 标签来现实的, 但是SPA只有一个固定的HTML, 切换不同的页面的时候, 标题并不会改变</li><li>但是我们可以通过JavaScript中 document.title来修改 title 中的内容 window.document.title = “新的标题” (window可以省略)</li><li>那么在Vue项目中, 在哪里修改? 什么时候修改比较合适呢?</li></ul></li><li>普通的修改方式<ul><li>很容易想到的修改标题的位置是每一个路由对应的组件.vue文件中</li><li>通过生命周期函数, 执行对应的代码来修改即可</li><li>但是当页面较多的时候, 这种方式不容易维护(因为要在多个页面执行类似的代码)</li></ul></li><li>使用导航守卫<ul><li>什么是导航守卫<ul><li>vue-router 提供的导航守卫主要用来监听路由的进入和离开的<ul><li>beforEach 守卫函数, 会在路由即将改变前触发, 这个守卫函数需要传入一个函数作为参数<ul><li>这个传入的函数包含三个参数, to, from, next</li><li>to : 即将要进入的目标的路由对象</li><li>from : 当前导航即将要离开的路由对象</li><li>next : 调用了该方法后, 才能进入下一个钩子, 前置守卫函数必须调用这个方法</li></ul></li><li>afterEach 守卫函数, 会在路由改变后触发, 这个守卫函数也需要传入一个函数作为参数<ul><li>这个传入的函数包含两个参数, to , from</li><li>这两个参数的含义与beforEach中的函数的参数含义相同</li><li>后置守卫函数不需要调用next</li></ul></li></ul></li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 普通的修改方式</span><br><span class="line">// 这里是vue组件中的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 我们可以通过Vue的生命周期函数来修改 document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 生命周期函数有很多，这里只使用了created函数， 其会在为路由创建的时候调用</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 但是这样的做的话, 每一个组件都需要添加一个created生命周期函数, 代码重复度很高, 所以我们可以通过在路由配置index.js文件中通过导航守卫, 来修改document.title</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.title = <span class="string">&quot;首页&quot;</span>;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导航守卫写法</span></span><br><span class="line"><span class="comment">// 通过 路由实例中的 beforeEach 方法来监听路由即将改变前事件</span></span><br><span class="line"><span class="comment">// 这个方法需要传入一个参数, 这个参数是一个函数</span></span><br><span class="line"><span class="comment">// 这个函数包含三个参数, 第一个参数为to, 第二个参数为from, 第三个参数为next(其本质是一个函数)</span></span><br><span class="line"><span class="comment">// to指要跳转到的路由, from指从哪个路由跳转, next指进行下一步操作, [注]必须调用next函数,进行下一步,否则路由不会跳转了</span></span><br><span class="line"><span class="comment">// to和from都是是一个路由对象里面包含整个路由的所有信息, 包括其父路由</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在路由嵌套的话, 直接用meta是拿不到元数据的</span></span><br><span class="line">  <span class="comment">// 要通过to对象中的metched数组中下标为0的数据中的meta对象来获取预先在路由中设置的元数据</span></span><br><span class="line">  <span class="comment">// meta翻译为元数据（描述数据的数据</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.matched[<span class="number">0</span>].meta.title;</span><br><span class="line">  next(); <span class="comment">// 调用next函数进行下一步</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="导航守卫补充"><a href="#导航守卫补充" class="headerlink" title="导航守卫补充"></a>导航守卫补充</h3><ul><li>补充一: 上面已经提到了, 后置守卫函数afterEach 是不需要主动调用next()函数的</li><li>补充二: next()函数里面也是可以传入参数的, 具体可以浏览 vue-router 的官网</li><li>补充三: 上面所说的两个导航守卫都是全局守卫<ul><li>导航守卫还有路由独享的守卫和组件内守卫</li></ul></li></ul><h3 id="keep-alive组件"><a href="#keep-alive组件" class="headerlink" title="keep-alive组件"></a>keep-alive组件</h3><ul><li>keep-alive是Vue内置的一个组件, 可以使被包含的组件保留状态, 或者避免重新渲染<ul><li>keep-alive组件有两个生命周期钩子函数<ul><li>activated(), 这个函数会在组件进入活跃的时候调用</li><li>deactivated(), 这个函数会在组件离开活跃之前的时候调用</li><li>注意, 这两个函数只能在存在keep-alive组件的情况下使用</li></ul></li></ul></li></ul><h3 id="如何实现切换路由的时候保留组件状态"><a href="#如何实现切换路由的时候保留组件状态" class="headerlink" title="如何实现切换路由的时候保留组件状态"></a>如何实现切换路由的时候保留组件状态</h3><ul><li>首先: 如果组件中具有组件嵌套, 而且有自动跳转默认组件的话, 需要在 路由配置 index.js文件中取消自动跳转</li><li>实现思路: 在组件中的data中存储离开路由前的路由路径, 在再次回到该路由的时候再将路由设置为离开路由前的路由路径达到保留组件状态的效果</li><li>具体操作<ul><li>第一步: 在组件的data中存储默认的路由路径</li><li>第二步, 通过keep-alive中的activated() 函数, 在组件进入活跃的时候, 使用 $router.push() 方法, 将路由路径设置为默认路由路径</li><li>第三步, 通过导航守卫中的组件内守卫, beforeRouteLeave(to, from, next){} 将当前路由路径赋值给data中存储的默认路由路径</li><li>这样就可以达到切换路由的时候保留组件状态的效果</li><li>以后会有更好的方法达到这个效果</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由配置文件 index.js 中的代码</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">children</span> : [</span><br><span class="line">      <span class="comment">// 要实现保留组件状态就不能自动跳转, 取消自动跳转</span></span><br><span class="line">      <span class="comment">/* &#123;</span></span><br><span class="line"><span class="comment">        path : &quot;&quot;,</span></span><br><span class="line"><span class="comment">        redirect : &quot;news&quot;</span></span><br><span class="line"><span class="comment">      &#125;, */</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;news&quot;</span>,  <span class="comment">// 注意嵌套在路由里面的路由路径前面不能加 /</span></span><br><span class="line">        <span class="attr">component</span> : HomeNews</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span> : <span class="string">&quot;message&quot;</span>,</span><br><span class="line">        <span class="attr">component</span> : HomeMessage</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">name</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;这里是首页&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">path</span>: <span class="string">&quot;home/news&quot;</span>, <span class="comment">// 设置路由默认路径</span></span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 以下代码是实现如何在切换组件的时候 保留组件状态</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 首先在组件的data中记录当前路由的路径</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 在路由设置文件 index.js文件中取消自动跳转</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用keep-alive组件中的 activated() 生命周期钩子函数 在路由创建的时候, 使用 $router.push 方法设置路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path); <span class="comment">// 使用$router.push方法设置路径</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用导航守卫中的组件内守卫, 记录离开当前组件时候的路由路径</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path; <span class="comment">// 记录离开当前组件时的路由路径</span></span></span><br><span class="line"><span class="javascript">    next();</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="keep-alive中的两个重要属性"><a href="#keep-alive中的两个重要属性" class="headerlink" title="keep-alive中的两个重要属性"></a>keep-alive中的两个重要属性</h3><ul><li>keep-alive可以使被包含的组件保留状态, 或者避免重新渲染</li><li>但是我们有些组件就是要频繁的销毁和重新创建</li><li>这个时候就可以用到keep-alive标签中的两个重要的属性了<ul><li>include: 值为字符串或者正则表达式, 只有匹配的组件才会被缓存</li><li>exclude: 值为字符串或者正则表达式, 匹配的组件都不会被缓存</li><li>注意, 有关正则表达式的代码都不能随意加括号</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 keep-alive 标签将router-view标签 包起来 就可以让组件不被销毁 也就是保留组件状态 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果某些组件就是需要频繁的销毁和创建, 那么就用到了keep-alive中的exclude属性了 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意与正则表达式相关的代码不能随意加空格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">&quot;Profile,User&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-Vue-cil脚手架详解</title>
      <link href="2021/05/25/11-Vue-cil%E8%84%9A%E6%89%8B%E6%9E%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/05/25/11-Vue-cil%E8%84%9A%E6%89%8B%E6%9E%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么时Vue-CLI"><a href="#什么时Vue-CLI" class="headerlink" title="什么时Vue CLI"></a>什么时Vue CLI</h3><ul><li>如果只是写几个Vue的Demo程序, 那么时不需要用Vue CLI的</li><li>如果在开发大型项目的话, 那么就需要, 而且必然需要使用Vue CLI<ul><li>因为在使用Vue.js开发大型应用的时候, 我们需要考虑代码的目录结构,项目结构和部署,热加载,代码单元测试(国内公司少做)等事情</li><li>如果每个项目都要手动完成这些工作,那无疑效率是十分低效的, 所以我们需要使用一些脚手架工具来帮助完成这些繁琐的事情</li></ul></li><li>CLI是什么意思<ul><li>CLI是Command-Line Interface, 翻译过来就是命令行界面, 俗称脚手架</li><li>Vue CLI是官方发布vue.js项目脚手架</li><li>使用vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置</li></ul></li></ul><h3 id="使用Vue-CLI的前提-–-Node"><a href="#使用Vue-CLI的前提-–-Node" class="headerlink" title="使用Vue CLI的前提 – Node"></a>使用Vue CLI的前提 – Node</h3><ul><li>安装NodeJS<ul><li>NPM安装 (推荐)</li><li>官网安装</li></ul></li><li>检测安装的NodeJS版本<ul><li>使用脚手架需要Node环境8.9以上的版本</li></ul></li><li>什么是NPM<ul><li>NPM 全称是 Node Package Manager</li><li>就是一个NodeJS包管理和分发工具, 已经成为了非官方的发布Node模块的标准</li><li>后续会经常使用NPM安装一些开发过程的依赖包</li></ul></li></ul><h3 id="使用Vue-CLI的前提-–Webpack"><a href="#使用Vue-CLI的前提-–Webpack" class="headerlink" title="使用Vue CLI的前提 –Webpack"></a>使用Vue CLI的前提 –Webpack</h3><ul><li>Vue.js官方脚手架工具就是使用webpack模板的<ul><li>webpack可以对所有资源进行压缩等优化操作</li><li>在开发过程中提供了一套完整的功能, 是开发变得更加高效</li></ul></li><li>webpack的全局安装<ul><li>npm install webpack -g</li></ul></li></ul><h3 id="Vue-CLI的使用"><a href="#Vue-CLI的使用" class="headerlink" title="Vue CLI的使用"></a>Vue CLI的使用</h3><ul><li><p>安装Vue脚手架</p><ul><li>npm install @vue/cli -g</li><li>注意默认安装的是Vue CLI4的版本, 如果需要安装Vue CLI2的方式初始化项目语法是不可以的</li></ul></li><li><p>如果需要用Vue CLI2的方式搭建脚手架</p><ul><li>Vue CLI &gt;= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：</li><li>npm install -g @vue/cli-init</li></ul></li><li><p>Vue CLI2初始化项目</p><ul><li>vue init webpack my-project (my-project指的是项目名字)</li></ul></li><li><p>Vue CLI&gt;=3 初始化项目</p><ul><li>vue create my-project (my-project指的是项目名字)</li></ul></li></ul><h3 id="为了深入地学习脚手架-本文会交替编写Vue-CLI2-和-Vue-CLI3"><a href="#为了深入地学习脚手架-本文会交替编写Vue-CLI2-和-Vue-CLI3" class="headerlink" title="为了深入地学习脚手架, 本文会交替编写Vue CLI2 和 Vue CLI3"></a>为了深入地学习脚手架, 本文会交替编写Vue CLI2 和 Vue CLI3</h3><ul><li>Vue CLI2 初始化项目详解</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令行输入</span></span><br><span class="line">vue init webpack vuecli2test  <span class="comment">// 意思是在该文件目录下 创建一个vuecli2test的项目</span></span><br><span class="line">Project name <span class="comment">// 项目名字, 默认是跟上面创建的项目名字相同</span></span><br><span class="line">Project description <span class="comment">// 项目描述</span></span><br><span class="line">Auther <span class="comment">// 项目作者</span></span><br><span class="line">Vue build <span class="comment">// 项目运行的vue版本, 选择是运行时版本还是完整版本</span></span><br><span class="line">Install vue-router? <span class="comment">// 是否安装vue-router 即是vue路由</span></span><br><span class="line">Use ESLint to list your code? <span class="comment">// 是否使用严格模式下的js代码</span></span><br><span class="line"><span class="built_in">Set</span> up unit test <span class="comment">// 是否使用代码单元测试(国内少做)</span></span><br><span class="line">Setup e2e tests <span class="keyword">with</span> Nightwatch <span class="comment">// 是否使用e2e测试</span></span><br><span class="line">Should we run <span class="string">`npm install`</span> <span class="keyword">for</span> you after the project has been created? (recommended)  <span class="comment">// 选择npm安装或者yarn安装</span></span><br></pre></td></tr></table></figure><h3 id="Vue-CLI2-初始化项目的目录结构详解"><a href="#Vue-CLI2-初始化项目的目录结构详解" class="headerlink" title="Vue CLI2 初始化项目的目录结构详解"></a>Vue CLI2 初始化项目的目录结构详解</h3><ul><li>build文件夹和config文件夹: 里面存放的是webpack的相关配置</li><li>node_modules文件夹: 里面存放的是node的模块包</li><li>src文件夹: 里面存放的是源码, 是以后写代码的地方</li><li>static文件夹: 里面存放的是静态文件, 即是打包后会原封不动地加入到dist的文件</li><li>.babelrc文件: 这个是与配置ES代码相关的文件</li><li>.editorconfig文件: 这个是规定项目代码规范格式相关的文件, 比如项目代码的缩进等等</li><li>.gitignore文件: 这个是与上传项目到服务器有关的文件, 里面编写的内容是, 规定上传git仓库的时候要忽略的文件</li><li>.postcssrc.js文件: 这个文件是与样式打包有关的文件</li><li>index.html文件: 这个文件是入口html文件</li><li>package.json文件: 这个文件记录了这个项目所需要的各种模块，以及项目的配置信息</li><li>package-lock.json文件: 这个文件是记录当前状态下实际(注意是实际)安装的各个npm package的具体来源和版本号。</li><li>README.md文件: 这个文件是用于描述这个项目的</li></ul><h3 id="关于-ESLint-严格模式"><a href="#关于-ESLint-严格模式" class="headerlink" title="关于 ESLint 严格模式"></a>关于 ESLint 严格模式</h3><ul><li>如果在初始化Vue CLI的过程中<ul><li>询问Use ESLint to list your code?的时候, 选择使用了其中一个规范</li><li>那么在编写js代码的时候, 就要严格地遵循该规范, 如果有不遵循规范的地方, 运行本地服务器模块, 或者打包的时候, 会报错. 但是这个规范很不灵活, 不人性化, 所以一般都不会开启, 但是有些公司会要求开启, 那就要慢慢适应了</li></ul></li><li>如何关闭 ESLint 严格模式<ul><li>在当前项目中找到 config 文件夹下的 index.js 文件</li><li>将里面的useEslint: true 改为 useEslint: false 即可</li></ul></li></ul><h3 id="Runtime-Compiler-和-Runtime-only的区别"><a href="#Runtime-Compiler-和-Runtime-only的区别" class="headerlink" title="Runtime-Compiler 和 Runtime-only的区别"></a>Runtime-Compiler 和 Runtime-only的区别</h3><ul><li>这两者最大的区别其实就是Runtime-Compiler具有解析template的功能, 而Runtime-only没有这个功能<ul><li>Runtime-Compiler解析代码的过程为<ul><li>template -&gt; ast -&gt; render -&gt; vDOM(虚拟DOM) -&gt; UI(真实渲染在页面中的DOM)</li></ul></li><li>Runtime-only解析代码的过程为<ul><li>render -&gt; vDOM(虚拟DOM) -&gt; UI(真实渲染在页面中的DOM)</li></ul></li></ul></li><li>很明显runtime-only解析代码的时候是跳过了template -&gt; ast 的过程的<ul><li>所以runtime-only比runtime-compiler更轻量(大小小了6KB), 而且代码执行效率更高, 因为解析的时候没有 template -&gt; ast 的过程</li></ul></li><li>但是我们的.vue文件中是带有template模板的, 在runtime-only中是什么来解析template模板的呢?<ul><li>是由 vue-template-compiler 模块来解析的, 可以在package.json文件中找到该模块</li><li>.vue文件中的template模块, 在传入main.js文件中的时候, 已经被vue-template-compiler模块解析为一个 render对象了</li><li>所以我们在实际开发中, 都是选用 runtime-only , 因为它更小更效率</li></ul></li></ul><h3 id="render函数的使用"><a href="#render函数的使用" class="headerlink" title="render函数的使用"></a>render函数的使用</h3><ul><li>1.使用方法一 (基本不会用这种方法)<ul><li>1.1 基本使用<ul><li>return createElement(“标签名”, {属性对象(可以不传)}, [“内容数组”])</li></ul></li><li>1.2 render函数嵌套<ul><li>return createElement(“标签名”,<br>{属性对象(可以不传)},<br>[“内容”,createElement(“标签名”,{属性对象(可以不传)},[“内容数组”])])</li></ul></li></ul></li><li>2.使用方法二<ul><li>传入一个组件对象<ul><li>return createElement(App);</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件对象</span></span><br><span class="line"><span class="keyword">const</span> cpn = &#123;</span><br><span class="line">  <span class="attr">template</span> : <span class="string">`&lt;h2&gt;&#123;&#123;message&#125;&#125;&lt;/h2&gt;`</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">message</span> : <span class="string">&quot;你好你好&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span> : <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 使用方法一: </span></span><br><span class="line">    <span class="comment">// 1.1 基本使用 return createElement(&quot;标签名&quot;, &#123;属性对象(可以不传)&#125;, [&quot;内容数组&quot;])</span></span><br><span class="line">    <span class="comment">// return createElement(&quot;h2&quot;, &#123;class : &quot;box&quot;&#125;, [&quot;你好你好我是render的内容&quot;])</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.2 嵌套render函数</span></span><br><span class="line">    <span class="comment">/* return createElement(&quot;h2&quot;,</span></span><br><span class="line"><span class="comment">    &#123;class : &quot;box&quot;&#125;, </span></span><br><span class="line"><span class="comment">    [&quot;你好你好&quot;, createElement(&quot;button&quot;,[&quot;我是按钮&quot;])]) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 使用方法二: 传入一个组件对象</span></span><br><span class="line">    <span class="keyword">return</span> createElement(cpn);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="认识Vue-CLI3"><a href="#认识Vue-CLI3" class="headerlink" title="认识Vue CLI3"></a>认识Vue CLI3</h3><ul><li><p>vue-cli&gt;=3 和 vue-cli2 版本的区别</p><ul><li>vue-cli&gt;=3 是基于webpack4 打造的, vue-cli2 是基于webpack3 打造的</li><li>vue-cli&gt;=3 的设计原则是”0配置”, 移除了根目录下的配置文件, build和config等目录</li><li>vue-cli&gt;=3 提供了vue ui 命令, 也就是提供了可视化设置, 更加人性化, 更加方便修改设置了</li><li>移除了static静态文件夹, 新增了public文件夹(这个文件夹里面的东西打包的时候也会原封不动地打包进dist中), 并且将index.html移动到了public文件夹中</li></ul></li><li><p>使用vue-cli&gt;=3 初始化项目</p><ul><li><ol><li>选择配置方式</li></ol></li><li><ol start="2"><li>选择自己需要的配置(按空格选中或者反选), 选择完毕后直接敲回车进入下一步</li></ol></li><li><ol start="3"><li>选择对应的配置, 是单独生成文件还是放在package.json文件中, 建议单独生成文件</li></ol></li><li><ol start="4"><li>是否将刚才的选择配置保存下来</li></ol><ul><li>如果选择是, 那么就会让你填入配置的名称, 在下次初始化项目的时候, 在第1步, 选择配置方式的步骤中, 就会出现保存下来的配置</li></ul></li><li><ol start="5"><li>选择npm安装还是yran安装</li></ol></li></ul></li></ul><h3 id="vue-cli3-初始化项目的目录结构详解"><a href="#vue-cli3-初始化项目的目录结构详解" class="headerlink" title="vue-cli3 初始化项目的目录结构详解"></a>vue-cli3 初始化项目的目录结构详解</h3><ul><li>node_modules文件夹: 储存node模块包</li><li>public文件夹: 相当于vue-cli2中的static静态文件夹, 在打包项目的时候, 会将里面的文件原封不动地添加到dist中, vue-cli3将index.html也放入了这个文件夹中</li><li>src文件夹: 存放源码的文件夹<ul><li>assets文件夹: 放资源的, 图片logo等</li></ul></li><li>.browserslistrc文件: 这个文件存放关于浏览器兼容的信息, 比如哪些浏览器需要兼容, 哪些浏览器不去兼容</li><li>.gitignore文件: 这个文件是存放关于上传项目的信息的</li><li>babel.config.js文件: 关于ES语法转换的</li><li>postcss.config.js文件: 关于样式转换的</li><li>package.json文件: 记录node模块版本信息</li><li>package-lock.json文件: 记录实际的node模块版本信息</li><li>README.md文件: 项目说明文件</li></ul><h3 id="vue-cli3-与vue-cli2-中的main-js-的区别"><a href="#vue-cli3-与vue-cli2-中的main-js-的区别" class="headerlink" title="vue-cli3 与vue-cli2 中的main.js 的区别"></a>vue-cli3 与vue-cli2 中的main.js 的区别</h3><ul><li>vue-cli3中将 el: “#app” 去除了, 添加上了 .$mount(‘#app’)</li><li>实际上这两个东西是一样的作用</li><li>el: “#app” 在代码的解析的时候也会转换成 .$mount(‘#app’)</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 在这里用链式操作, 添加上 .$mount(&#x27;#app&#x27;) 与在Vue实例中的 el : &quot;#app&quot; 是一样的作用</span></span><br></pre></td></tr></table></figure><h3 id="vue-cli-gt-3的配置文件去哪里了-要如何修改我们项目的配置呢"><a href="#vue-cli-gt-3的配置文件去哪里了-要如何修改我们项目的配置呢" class="headerlink" title="vue-cli&gt;=3的配置文件去哪里了? 要如何修改我们项目的配置呢?"></a>vue-cli&gt;=3的配置文件去哪里了? 要如何修改我们项目的配置呢?</h3><ul><li><p>方法一: 要修改项目的配置, 可以在终端的命令行输入 vue ui 进入项目配置的可视化界面</p><ul><li>我们在什么时候安装了 vue ui 呢?<ul><li>在我们全局安装vue/cli 的同时安装了vue 和安装了vue ui这个模块</li><li>所以我们在任何目录下都可以执行 vue ui 这个命令行</li></ul></li><li>在vue ui 可视化界面中导入我们的项目, 就可以对项目的插件, 依赖和配置进行修改了</li></ul></li><li><p>方法二: 在项目的根目录中按照路径 node_modules/@vue/cli-service 就可以找到项目的配置文件 webpack.config.js</p><ul><li>在webpack.config.js 文件中, 可以看到我们引用的配置在 当前文件夹中的 lib/Service中(一般不要随意修改node_modules中的文件)</li></ul></li><li><p>方法三: 在项目的根目录中新建一个名为 vue.config.js(名字是固定的不可以修改) 的文件</p><ul><li>在该文件中编写想要修改的配置</li><li>在vue编译的时候, 就会在根目录中寻找这个文件, 如果找到了就会将文件中的配置与原本的配置进行合并</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-Vue组件化开发深入</title>
      <link href="2021/05/25/10-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%B7%B1%E5%85%A5/"/>
      <url>2021/05/25/10-Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%B7%B1%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><ul><li><p>为什么要使用slot插槽</p><ul><li>组件的插槽是为了让我们封装的组件更加具有扩展性</li><li>让使用者可以灵活地决定组件内部的内容到底展示什么</li><li>网页和网页间每一个组件有很多的区别, 也有很多共性, 如果我们为每一个网页都去单独地封装一个组件是不合适的, 所以我们需要slot插槽</li></ul></li><li><p>如何封装一个灵活的组件</p><ul><li>将共性(相同的地方)抽取放到组件中, 将不同的地方暴露为插槽</li><li>预留了插槽, 就可以让使用者根据自己的需求, 决定插槽内的内容</li></ul></li><li><p>slot的基本使用</p><ul><li>在子组件中, 用特殊的元素标签slot就可以为子组件创建一个插槽</li><li>插槽中插入的内容是什么由父组件来决定</li></ul></li><li><p>slot的注意点</p><ul><li>slot的默认值, 在父组件中没有写入要插入的内容的话, 就会默认显示slot的默认值</li><li>如果父组件中一次性插入多个元素, 那么所有的元素都会进行替换</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在组件的标签中填入要替换slot占位的元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果一次性填入多个替换的元素, 所有的替换元素都会进行替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>我是i<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是替换的p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>我是替换的span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果标签内没有填入要替换的slot占位的元素, slot会使用默认的元素替换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在组件中使用solt标签占位 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在slot标签中填入默认的元素, 默认元素会在子组件标签没有填入替换的元素的时候显示出来 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>我是默认的按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="具名slot的使用"><a href="#具名slot的使用" class="headerlink" title="具名slot的使用"></a>具名slot的使用</h3><ul><li>当子组件的功能复杂时, 子组件的插槽可能由很多个, 那么在父组件中给插槽插入内容的时候, 如何区分插入的是哪一个插槽呢?<ul><li>此时需要给插槽起一个名字, 添加一个name属性</li><li>然后在插入的元素中添加slot属性, 值为需要替换的插槽的name值</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用子组件的时候, 给需要替换的添加slot属性, 值为需要替换的slot标签的name值, 即可定向替换元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>替换中间的<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 给插槽标签添加name属性 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编译的作用域"><a href="#编译的作用域" class="headerlink" title="编译的作用域"></a>编译的作用域</h3><ul><li>在组件模板中使用的所用东西, 来自该组件</li><li>官方的准则: 父组件模板的所有东西都会在父级作用域内编译, 子级组件模板的所有东西都会在子级作用域内编译</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在这里使用的isShow数据是来自根组件的,因为这里是app根组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在这里使用的isShow数据是来自cpn组件的, 因为这里是cpn子组件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>我是span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">isShow</span>: <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域插槽的使用"><a href="#作用域插槽的使用" class="headerlink" title="作用域插槽的使用"></a>作用域插槽的使用</h3><ul><li>总结起来就是一句话, 父组件替换插槽的标签, 但是内容由子组件来提供</li><li>就是父组件来决定如何渲染子组件的内容</li><li>如何使用作用域插槽<ul><li>子组件模板中, 通过给slot标签添加v-bind:自定义名称=”想要暴露的数据” 属性来发送子组件的数据</li><li>在父组件中的子组件标签中嵌套一个一个template标签(Vue2.5.x以后可以使用其他的标签比如div等)</li><li>在这个template标签中添加 slot-scope=”也是自定义的名字” 来接收slot标签发送的数据</li><li>在template标签内就可以使用子组件发送来的数据了</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认是按照子组件模板中设定的模板渲染 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 如果想在父组件中其他的形式展示子组件的内容, 就要使用作用域插槽 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在子组件标签中嵌套一个template标签(Vue2.5.x以后可以使用其他的标签比如div等) --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在该标签中添加 slot-scope=&quot;也是自定义的名字&quot; 来接收slot标签发送的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;acceptdata&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这个标签内就可以使用子组件发送来的数据了 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;span v-for=&quot;item in acceptdata.cpndata&quot;&gt; &#123;&#123;item&#125;&#125; - &lt;/span&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;acceptdata.cpndata.join(&quot; - &quot;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 通过slot标签中添加 v-bind:自定义名称=&quot;想要暴露的数据&quot; 属性来发送子组件的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:cpndata</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">cpn</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">pLanguages</span>: [<span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>, <span class="string">&quot;python&quot;</span>]</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-Vue的组件化开发</title>
      <link href="2021/05/25/09-Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
      <url>2021/05/25/09-Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h3><ul><li><p>将一个复杂的问题, 拆解为很多个可以处理的小问题, 再将其放到整体当中,大问题就可以迎刃而解  其实就是 动态规划问题</p></li><li><p>组件化也是类似的思想</p><ul><li>如果将一个页面中所有的处理逻辑全部放在一起,处理起来就会变得非常复杂, 而且不利于后续的管理以及扩展, 不利于维护</li><li>如果将一个页面拆分成一个个效地功能块, 每个功能块完成属于自己的部分的独立功能, 那么之后整个页面的管理和维护就变得非常容易了</li></ul></li><li><p>组件化是Vue.js中的重要思想, 它提供了一种抽象, 让我们开发出一个个独立的可以复用的小组件来组成我们的页面</p></li><li><p>任何的应用都可以被抽象成一个组件树</p></li><li><p>组件化思想的应用</p><ul><li>有了组件化的思想, 在以后的开发中就要充分地利用组件化</li><li>尽可能地将页面拆分成一个个小的, 可以复用的组件</li><li>这样可以方便代码的管理和维护,代码的扩展性也会大大增强</li></ul></li></ul><h3 id="注册组件的基本步骤"><a href="#注册组件的基本步骤" class="headerlink" title="注册组件的基本步骤"></a>注册组件的基本步骤</h3><ul><li><p>组件的使用分成三个步骤</p><ul><li>创建组件构造器<ul><li>调用Vue.extend()方法创建组件构造器</li></ul></li><li>注册组件<ul><li>调用Vue.component()方法注册组件</li></ul></li><li>使用组件<ul><li>在Vue实例的作用范围内使用组件</li></ul></li></ul></li><li><p>注意: 前两个步骤代码的编写要写在 创建 new Vue() 之前</p></li></ul><h3 id="注册组件步骤解析"><a href="#注册组件步骤解析" class="headerlink" title="注册组件步骤解析"></a>注册组件步骤解析</h3><ul><li><ol><li>Vue.extend()</li></ol><ul><li>调用Vue.extend() 创建的是一个组件构造器</li><li>在创建组件构造器的时候, 传入template 代表自定义组件的模板</li><li>改模板就是在使用到组件的地方, 要显示的html代码</li><li>事实上,这种写法在Vue2.x的文档中几乎看不到了,都是使用语法糖</li></ul></li><li><ol start="2"><li>Vue.component()</li></ol><ul><li>调用Vue.component() 是将创建的组件构造器注册为一个组件, 并给它一个标签名称</li><li>Vue.component() 需要传递两个参数: 1. 注册组件的标签名 2. 组件构造器</li></ul></li><li><ol start="3"><li>组件必须挂载在某个Vue实例中, 否则不会生效</li></ol></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3. 使用组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">my-cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 1. 创建组件构造器</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const cpn = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    `</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 2. 注册组件</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  Vue.component(&#x27;my-cpn&#x27;, cpn)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 以上两步要写在 new Vue实例之前</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    data: &#123;&#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;);</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="全局组件和局部组件-开发中常用的是局部组件"><a href="#全局组件和局部组件-开发中常用的是局部组件" class="headerlink" title="全局组件和局部组件 (开发中常用的是局部组件)"></a>全局组件和局部组件 (开发中常用的是局部组件)</h3><ul><li>全局组件就是在全局注册的组件, 全局组件可以在多个Vue实例中使用</li><li>局部组件就是在Vue实例对象中注册的组件, 局部组件只能在当前的Vue实例下面使用, 在其他的Vue实例下使用会报错<ul><li>局部组件是在Vue实例下的一个叫 components 的 option下注册的, components值是一个对象那个, 里面写入 组件名(就是在html中使用的标签名) : 组件构造器 即可注册组件</li></ul></li><li>注意, 组件构造器和全局注册组件的代码要写在 创建Vue实例的代码之前</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mycpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">mycpn1</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 局部的组件 在这里无效 而且会报错--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;mycpn2&gt;&lt;/mycpn2&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1. 创建组件构造器</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn1 = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;我是标题111&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;p&gt;我是内容111, 你好你好&lt;/p&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn2 = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;我是标题222&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;p&gt;我是内容222, 你好你好&lt;/p&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 2. 注册组件 (全局组件)</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 全局组件可以在多个Vue实例下使用</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;mycpn1&#x27;</span>, cpn1)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app1&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在实例化的Vue中注册组件就是 局部组件, 局部组件只能在当前的Vue实例中使用, 不能再其他的Vue实例中使用</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在 components option中定义局部组件</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">mycpn2</span>: cpn2 <span class="comment">// 组件名(就是在html中使用的标签名) : 组件构造器</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app2 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app2&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue组件的父组件和子组件"><a href="#Vue组件的父组件和子组件" class="headerlink" title="Vue组件的父组件和子组件"></a>Vue组件的父组件和子组件</h3><ul><li>子组件的注册组件代码可以写在父组件的组件构造器的名为components的option中, 子组件的注册完成后, 子组件的标签名就可以写入父组件的template中</li><li>简单来说, 就是组件在哪里注册就只能在哪里使用, 浏览器解析组件标签的时候, 会先从当前的组件构造器中的components中查找是否有注册该标签名, 如果找到了就开始渲染, 如果没有找到就在全局的Vue.component中查找, 如果找到就渲染, 如果都没有找到的话就会报错</li><li>注意, 子组件的组件构造器要写在 父组件的组件构造器之前, 否则按照浏览器解析代码的顺序, 会找不到子组件, 就会报错</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">fathercpn</span>&gt;</span><span class="tag">&lt;/<span class="name">fathercpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 组件1</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const son = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是子内容,呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 组件2</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 注意, 子组件的组件构造器要写在父组件的组件构造器之前</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const father = Vue.extend(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是父标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是父内容,哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    在这里使用子组件</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">soncpn</span>&gt;</span><span class="tag">&lt;/<span class="name">soncpn</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    // 子组件可以在父组件的内部注册</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    // 注册后就可以在父组件的template中使用</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      soncpn: son</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 这个app可以看作是root组件(根组件)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      fathercpn: father</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注册组件的语法糖"><a href="#注册组件的语法糖" class="headerlink" title="注册组件的语法糖"></a>注册组件的语法糖</h3><ul><li>传统注册组件的方式, 有些繁琐</li><li>Vue为了见过这个过程, 提供了注册的语法糖</li><li>主要是省去了调用Vue.extend()的这个步骤, 可以将一个对象当作参数传入component中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 1. 全局注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  // 将组件构造器中调用Vue.extend方法的步骤省略, 而是直接将一个对象代替传入Vue.component中</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  Vue.component(&#x27;cpn1&#x27;, &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题111<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容111, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  const app = new Vue(&#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    el: &quot;#app&quot;,</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    components: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      // 2. 局部注册组件的语法糖</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      // 跟全局注册组件的语法糖差不多, 也是直接将一个对象传入</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      cpn2: &#123;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">        template: `<span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题222<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容222, 你好你好<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>`</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">      &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    &#125;</span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  &#125;)</span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件模板的分离写法"><a href="#组件模板的分离写法" class="headerlink" title="组件模板的分离写法"></a>组件模板的分离写法</h3><ul><li>template模板如果写在js代码中不优雅不好看</li><li>将其中的HTML代码分离出来,然后挂载到对应的组件上</li><li>Vue提供了两种方案来定义HTML模块内容<ul><li>script标签<ul><li>注意script标签需要定义type类型为 text/x-template</li><li>并且定义id属性来绑定组件的标签名</li></ul></li><li>template标签<ul><li>定义id属性来绑定组件的标签名</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组件模板的分离写法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1. script标签写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题111<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. template标签写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题222<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 将定义的模板的id绑定到标签名中</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn1&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn2&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn2&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件中的数据存放问题"><a href="#组件中的数据存放问题" class="headerlink" title="组件中的数据存放问题"></a>组件中的数据存放问题</h3><ul><li>组件可以访问Vue中的数据吗?<ul><li>不可以</li><li>组件是一个单独功能模块的封装</li><li>这个模块有属于自己的HTML模板, 也会有属于自己的数据data</li></ul></li><li>组件中的数据是保存在自身的一个data属性中的(组件也可以有自己的methods等等option,以后会用到)<ul><li>这个data属性必须是一个函数</li><li>函数返回一个对象, 对象内部保存数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件保存的数据也是用mustache语法引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn1&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 组件中的数据要存放在组件的注册的data中, 而且这个data必须是一个函数, 函数返回一个对象, 对象内写入数据</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 返回一个对象</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 对象内写入数据</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件中的data为什么一定要是一个对象"><a href="#组件中的data为什么一定要是一个对象" class="headerlink" title="组件中的data为什么一定要是一个对象"></a>组件中的data为什么一定要是一个对象</h3><ul><li>就是为了防止多次引用组件的时候, 组件和组件之间共用一个data, 造成变量泄露</li><li>Vue已经考虑了这个问题, 所以这里必须写函数, 利用函数的作用域, 成为一个闭包, 防止变量泄露</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">counter</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;counter&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1. 注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;counter&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#counter&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里为什么要是一个函数?</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 就是为了防止多次引用组件的时候, 组件和组件之间共用一个data, 造成变量泄露</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Vue已经考虑了这个问题, 所以这里必须写函数, 利用函数的作用域, 成为一个闭包, 防止变量泄露</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num++</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num--</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件通讯-父组件向子组件传递数据"><a href="#组件通讯-父组件向子组件传递数据" class="headerlink" title="组件通讯-父组件向子组件传递数据"></a>组件通讯-父组件向子组件传递数据</h3><ul><li>在Vue中子组件是不可以直接引用父组件或者Vue实例中的数据的</li><li>但是在开发中, 往往一些数据需要从上层传递到下层<ul><li>比如在一个页面中, 从服务器请求到很多数据, 包括大组件的数据和小组件的数据, 他们都存储在大组件的data中</li><li>其中一部分数据, 并非是整个页面的大组件来展示的, 而是通过子组件来展示</li><li>这时, 并不会让子组件再次发送一个网络请求, 这样会大大加大服务器的压力的, 此时会让大组件(父组件)将苏剧传递给小组件(子组件)</li></ul></li><li>父组件向子组件传递数据的方法<ul><li>通过props向子组件传递数据<ul><li>props的写法也分有数组写法和对象写法 (我们一般用对象写法)</li><li>对象的写法可以设置 传入的数据类型, 是否必须传入, 默认值等等</li><li>对象的写法中, 如果type的值为0的时候, 则可以传入任何类型的值</li></ul></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传递数据要子组件的标签中用 v-bind 链接数据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:sonmessage</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:sonmovies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在通过子组件标签链接数据后, 就可以在子组件的html模板中用mustache语法使用数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sonmessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in sonmovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 这里是子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn =  &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 子组件向父组件拿数据, 用props</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里用数组形式, 数组里面传入新的数据名</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// props: [&quot;sonmessage&quot;, &quot;sonmovies&quot;]</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里使用对象形式, 对象形式可以设置传入的数据的类型, 默认值, 是否必须传入等等</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 简单地设置数据类型</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* sonmessage : String,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      sonmovies: Array */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 传入一个对象可以有更多的操作</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">sonmessage</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置数据的类型</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置是否必须传入</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>, <span class="comment">// true表示必须传入, false表示不是必须传入</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 设置默认值</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="string">&quot;你好我是默认值&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="attr">sonmovies</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意如果传入的数据类型是数组或者对象的话, 设置默认值default必须是一个函数, 函数返回一个默认的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> [<span class="string">&quot;我是默认的数据&quot;</span>, <span class="string">&quot;我也是默认的数据&quot;</span>]</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里是父组件的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好你好&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">movies</span>: [<span class="string">&quot;海王&quot;</span>, <span class="string">&quot;海贼王&quot;</span>, <span class="string">&quot;海尔兄弟&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span> : &#123;</span></span><br><span class="line"><span class="javascript">      cpn</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="父组件向子组件传递数据时props中的驼峰标识"><a href="#父组件向子组件传递数据时props中的驼峰标识" class="headerlink" title="父组件向子组件传递数据时props中的驼峰标识"></a>父组件向子组件传递数据时props中的驼峰标识</h3><ul><li>因为HTML代码时不区分大小写的, 所以不能使用驼峰命名法, 而JS代码时严格区分大小写的, 所以就会导致这个问题</li><li>记住在HTML代码中用短线命名, 在JS代码中使用驼峰命名 就OK啦~</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意这里不能使用驼峰命名法了, 要将props中的驼峰命名的转换为短线命名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">:son-message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:son-person</span>=<span class="string">&quot;person&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的数据, 要与props中的数据名一致 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sonMessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;sonPerson&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#cpn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">sonMessage</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">sonPerson</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">        <span class="keyword">default</span> () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;&#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;我是传入的数据&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">person</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">22</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      cpn</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h3><ul><li>需要使用自定义事件传递</li><li>什么时候需要自定义事件呢?<ul><li>当子组件需要向父组件传递数据的时候, 就要用到自定义事件了</li><li>v-on不仅仅可以监听DOM事件, 也可以用域监听组件间的自定义事件</li></ul></li><li>自定义事件的流程<ul><li>在子组件中, 通过$emit()来发射数据<ul><li>$emit() 中有两个参数, 第一个参数是自定义事件的名字, 第二个参数是需要发送的数据</li></ul></li><li>在父组件中, 通过v-on来监听自定义事件, 接收数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需求: 计数器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 操作在子组件中完成 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 展示交给父组件完成 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在这里用v-on监听接收子组件发射数据的自定义事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">btn</span> @<span class="attr">num-de</span>=<span class="string">&quot;decreNum&quot;</span> @<span class="attr">num-in</span>=<span class="string">&quot;increNum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">btn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置点击后触发发射数据事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件模块</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> btn = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#btn&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 用$emit()发射数据</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;num-de&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&quot;num-in&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 父组件模块</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      btn</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处理接收来的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increNum</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num++</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decreNum</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num--</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="子组件接收来自父组件的数据-通过子组件修改父组件的数据案例"><a href="#子组件接收来自父组件的数据-通过子组件修改父组件的数据案例" class="headerlink" title="子组件接收来自父组件的数据, 通过子组件修改父组件的数据案例"></a>子组件接收来自父组件的数据, 通过子组件修改父组件的数据案例</h3><ul><li>注意!!! 子组件不要直接修改props中来自父组件的数据, 会报错的<ul><li>正确做法是, 子组件修改子组件中data的数据, 然后将data中的数据通过自定义事件发送给父组件, 父组件处理接收的数据, 修改父组件自身的数据</li><li>以下的代码请注意看注释</li><li>以下代码实现的过程为, 从父组件通过props向子组件发送数据, 子组件接收数据, 子组件设置自己的data数据, 子组件修改自己的data数据, 子组件通过自定义事件向父组件发送自己的data数据, 父组件接收数据, 父组件修改自己的data数据, 同步修改了props向子组件发送的数据</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 根组件模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> <span class="attr">:sonnum1</span>=<span class="string">&quot;num1&quot;</span> <span class="attr">:sonnum2</span>=<span class="string">&quot;num2&quot;</span> @<span class="attr">parchangenum1</span>=<span class="string">&quot;parentnum1&quot;</span> @<span class="attr">parchangenum2</span>=<span class="string">&quot;parentnum2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 注意嗷!!! 子组件里不要直接修改props中来自父组件的数据 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;input type=&quot;number&quot; v-model=&quot;num1&quot;&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;num1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;changenum1&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- props 是接收的来自父组件的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props : &#123;&#123;sonnum1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- data 是子组件自身的数据 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data : &#123;&#123;num1&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;input type=&quot;number&quot; v-model=&quot;num2&quot;&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;num2&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;changenum2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>props : &#123;&#123;sonnum2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>data : &#123;&#123;num2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 接收来自根组件的数据</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">sonnum1</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 在做这个案例的时候, 发现了一个很有趣的现象, 如果将这里的type的值设置为 0 , 那么这个sonnum1 就可以接收任何类型的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">sonnum2</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">type</span>: <span class="built_in">Number</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 子组件的data必须是一个函数, 防止变量泄露</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">num1</span>: <span class="built_in">this</span>.sonnum1,</span></span><br><span class="line"><span class="javascript">          <span class="attr">num2</span>: <span class="built_in">this</span>.sonnum2</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">changenum1</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 处理num1, 然后向根组件发送</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = event.target.value;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum1&quot;</span>, <span class="built_in">this</span>.num1);</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 处理num2, 然后向根组件发送</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = <span class="built_in">this</span>.num1 * <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum2&quot;</span>, <span class="built_in">this</span>.num2);</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">changenum2</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = event.target.value;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum2&quot;</span>, <span class="built_in">this</span>.num2)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = <span class="built_in">this</span>.num2 / <span class="number">100</span>;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&quot;parchangenum1&quot;</span>, <span class="built_in">this</span>.num1)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num1</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">num2</span>: <span class="number">2</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        son</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 父组件处理从子组件接收来的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">parentnum1</span>(<span class="params">num</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num1 = <span class="built_in">parseFloat</span>(num)</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">parentnum2</span>(<span class="params">num</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num2 = <span class="built_in">parseFloat</span>(num)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件访问-父组件访问子组件-通过-children-和-refs"><a href="#组件访问-父组件访问子组件-通过-children-和-refs" class="headerlink" title="组件访问-父组件访问子组件, 通过$children 和 $refs"></a>组件访问-父组件访问子组件, 通过$children 和 $refs</h3><ul><li>$children 是一个数组, 里面包含的的是父组件中包含的所有子组件<ul><li>想要通过children访问某一个特定的子组件只能通过数组的下标来访问(这样的方法很不灵活), 所以children访问子组件的方法很少用</li></ul></li><li>$refs 是一个对象, 对象里面包含的是在父组件中 有ref属性注册的子组件, 没有ref属性的子组件不会被包含在内; 如果没有子组件设置ref属性, $refs就是一个空对象<ul><li>想要通过refs访问某一个特定的子组件, 需要在子组件的ref属性设置值, 通过这个设置值来访问这个子组件 </li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span> <span class="attr">ref</span>=<span class="string">&quot;son1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过这个按钮来触发事件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> son = &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">name</span>: <span class="string">&quot;子组件数据&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">showMessage</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;子组件方法&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        son</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 1. 通过children获取所有的子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 获取的是所有的子组件组成的一个数组</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 想要获取某个特定的子组件, 只能使用数组的下标获取(这样很不灵活, 所以使用children获取子组件的方法很少用)</span></span></span><br><span class="line"><span class="javascript">          <span class="comment">/* console.log(this.$children);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.$children[0].showMessage(); // 通过$children 使用某个下标的子组件的方法</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          console.log(this.$children[0].name); // 通过$children 获取某个下标的子组件的数据 */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          <span class="comment">// 2. 通过$refs 获取某个特定的子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs); <span class="comment">// $refs 获得的是一个对象, 里面包含通过标签属性ref注册的子组件 可以通过属性ref的值来获取特定的一个子组件</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$refs.son1.showMessage(); <span class="comment">//通过refs调用ref值为son1的子组件的方法</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.son1.name); <span class="comment">// 通过refs获取ref值为son1的子组件中的数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件访问-子组件访问父组件-通过-parent-和-root"><a href="#组件访问-子组件访问父组件-通过-parent-和-root" class="headerlink" title="组件访问-子组件访问父组件, 通过$parent 和 $root"></a>组件访问-子组件访问父组件, 通过$parent 和 $root</h3><ul><li>$parent 可以访问当前子组件上一级的父组件</li><li>$root 可以访问当前子组件的最上级根组件</li><li>这两个方法不是很常用, 因为Vue最大的优点是能够组件化分离, 如果组件用了$parent 或者 ​$root 方法的话就大大地减低了Vue的组件性</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">son</span>&gt;</span><span class="tag">&lt;/<span class="name">son</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是son组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sonBtnClick&quot;</span>&gt;</span>我是son按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sonchild</span>&gt;</span><span class="tag">&lt;/<span class="name">sonchild</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;sonchild&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是sonchild组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sonChildBtnClick&quot;</span>&gt;</span>我是sonchild按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;我是根组件的数据&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">son</span>: &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">template</span>: <span class="string">&quot;#son&quot;</span>,</span></span><br><span class="line"><span class="javascript">          <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">message</span>: <span class="string">&quot;我是son组件的数据&quot;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">sonBtnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 通过parent访问父组件</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent);</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 通过parent访问父组件的数据</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">sonchild</span>: &#123;</span></span><br><span class="line"><span class="javascript">              <span class="attr">template</span>: <span class="string">&quot;#sonchild&quot;</span>,</span></span><br><span class="line"><span class="javascript">              <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">sonChildBtnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 通过 $root 访问根组件</span></span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root);</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 通过$parent 访问父组件</span></span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent);</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.message);</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">              &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-Vue中v-model数据双向绑定</title>
      <link href="2021/05/25/08-Vue%E4%B8%ADv-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>2021/05/25/08-Vue%E4%B8%ADv-model%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="v-model的基本使用"><a href="#v-model的基本使用" class="headerlink" title="v-model的基本使用"></a>v-model的基本使用</h3><ul><li>在input框中添加指令, v-model, 值为需要绑定的data数据</li><li>这样的话, 修改input框中的内容, data中的内容也会响应式改变</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好呀&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><ul><li>v-model其实是一个语法糖, 它的背后本质是包含两个操作<ul><li><ol><li>v-bind绑定一个value属性</li></ol></li><li><ol start="2"><li>v-on 指令给当前元素绑定input事件</li></ol></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合radio的使用"><a href="#v-model结合radio的使用" class="headerlink" title="v-model结合radio的使用"></a>v-model结合radio的使用</h3><ul><li>在给input的radio设置v-model指令后, 不需要设置相同的name值就可以达到单选的效果</li><li>在使用v-model绑定radio单选按钮到data数据中的时候, 每次点击单选按钮都会将单选按钮是否选择传入data数据中, 已选传入true, 没选则传入false</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在给input的radio设置v-model指令后, 不需要设置相同的name值就可以达到单选的效果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">sex</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合checkbox使用"><a href="#v-model结合checkbox使用" class="headerlink" title="v-model结合checkbox使用"></a>v-model结合checkbox使用</h3><ul><li>结合单选checkbox使用<ul><li>与单选checkbox结合使用的时候, 一般给绑定的data数据声明为boolean值, 记录单选框是否有被选中</li></ul></li><li>结合多选checkbox使用<ul><li>与多选checkbox结合使用的时候, 一般给绑定的data数据声明为一个数组, 因为每次点击checkbox的时候,如果选中则会将其value值传入data数据, 如果没有选中, 则会将对应的data数据删除, 这样就可以记录用户选择了什么</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择是: &#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;网球&quot;</span>&gt;</span>网球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好有: &#123;&#123;hobby&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">isAgree</span>: <span class="literal">false</span>, <span class="comment">//单选框绑定为boolean值</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">hobby</span>: [] <span class="comment">// 多选框绑定为一个数组</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的值绑定"><a href="#v-model的值绑定" class="headerlink" title="v-model的值绑定"></a>v-model的值绑定</h3><ul><li>实质上就是动态地给value赋值</li><li>在真实开发中, input的值是从服务器中获取或者定义在data中的</li><li>所以要通过v-bind:value动态地给value绑定值</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-model的值绑定概念 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 遍历请求来的数据创建input --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in orginHobby&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过v-model将input绑定在用于记录用户选择的数据中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">hobby</span>: [],  <span class="comment">// 这里是用于记录用户选中的数据的</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">orginHobby</span>: [<span class="string">&quot;篮球&quot;</span>, <span class="string">&quot;乒乓球&quot;</span>, <span class="string">&quot;羽毛球&quot;</span>, <span class="string">&quot;网球&quot;</span>, <span class="string">&quot;高尔夫球&quot;</span>, <span class="string">&quot;台球&quot;</span>] <span class="comment">// 这里可以看作是从服务器中请求来的需要渲染在页面上的数据</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model结合select使用"><a href="#v-model结合select使用" class="headerlink" title="v-model结合select使用"></a>v-model结合select使用</h3><ul><li>select单选<ul><li>v-model绑定的是一个值</li><li>当选中option中的一个时, 就会将它的value值传入绑定的data中</li></ul></li><li>select多选<ul><li>用multiple属性将select转换为多选</li><li>v-model绑定的是一个数组</li><li>当选中多个值的时候, 就会将选中的option传入绑定的data数组中</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;frult&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;frult&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你选择的水果是: &#123;&#123;frult&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- select设置为多选 用multiple属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;frults&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;frults&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;榴莲&quot;</span>&gt;</span>榴莲<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>你选择的水果有: &#123;&#123;frults&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">frult</span>: <span class="string">&quot;苹果&quot;</span>, <span class="comment">// 如果是单选的select 就设置为一个字符串就好了</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">frults</span>: [] <span class="comment">// 如果是多选的select 就设置为一个数组</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-model的修饰符"><a href="#v-model的修饰符" class="headerlink" title="v-model的修饰符"></a>v-model的修饰符</h3><ul><li><p>lazy修饰符</p><ul><li>默认情况下, v-model默认是在input事件中同步输入框的数据的</li><li>也就是说数据一旦发生变化, data中的数据就会立即变化, 这样会降低性能</li><li>在v-model指令加上lazy修饰符, 就可以让data数据在input框失去焦点或者用户敲下回车的时候才会更新</li></ul></li><li><p>number修饰符</p><ul><li>默认情况下,在输入框中无论用户输入的是字符串还是数字, 存储在data中的时候都会被Vue转换为字符串类型</li><li>如果想要处理的是数字类型, 那么最好将内容存储为数字类型</li><li>number修饰符可以将传入的内容转成数字类型</li></ul></li><li><p>trim修饰符</p><ul><li>如果输入的内容首尾有空格, 我们希望去除的话</li><li>trim修饰符可以过滤内容左右两边的空格</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.修饰符: lazy --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2.修饰符: number --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125; &#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3.修饰符: trim --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">age</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">name</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-Vue中循环遍历v-for</title>
      <link href="2021/05/25/07-Vue%E4%B8%AD%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86v-for/"/>
      <url>2021/05/25/07-Vue%E4%B8%AD%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86v-for/</url>
      
        <content type="html"><![CDATA[<h3 id="v-for循环遍历数组"><a href="#v-for循环遍历数组" class="headerlink" title="v-for循环遍历数组"></a>v-for循环遍历数组</h3><ul><li>v-for循环遍历一个数组, 没有使用索引值(下标值) v-for=”item in arr”</li><li>v-for循环遍历一个数组, 使用索引值(下标值) v-for=”(item, index) in arr”</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-for循环遍历一个数组, 没有使用索引值(下标值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for循环遍历一个数组, 使用索引值(下标值) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in names&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125; &#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">names</span>: [<span class="string">&quot;xiaoLam&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;jams&quot;</span>, <span class="string">&quot;copo&quot;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-for循环遍历对象"><a href="#v-for循环遍历对象" class="headerlink" title="v-for循环遍历对象"></a>v-for循环遍历对象</h3><ul><li>v-for=”value in obj” 遍历obj对象中的值value</li><li>v-for=”(value,key) in obj” 遍历obj对象中的值value和键key</li><li>v-for=”(value, key, index) in obj” 遍历obj对象中的值value和键key和下标index(很少用)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;value in obj&quot; 遍历obj对象中的值value --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;(value,key) in obj&quot; 遍历obj对象中的值value和键key --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;,&#123;&#123;key&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- v-for=&quot;(value, key, index) in obj&quot; 遍历obj对象中的值value和键key和下标index(很少用) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in obj&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;, &#123;&#123;key&#125;&#125;, &#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">obj</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">name</span>: <span class="string">&quot;xiaoLam&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">age</span>: <span class="number">18</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">tall</span>: <span class="number">1.70</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件的key属性"><a href="#组件的key属性" class="headerlink" title="组件的key属性"></a>组件的key属性</h3><ul><li>官方推荐在使用v-for的时候, 给对应的元素添加一个 :key 属性</li><li>key属性是Vue的虚拟DOM的Diff算法中用来识别元素唯一性的属性</li><li>添加这个 :key属性的好处<ul><li>这个其实和Vue的虚拟DOM的Diff算法有关系</li><li>当某一层有很多相同的节点时, 也就是列表节点时,当我们希望插入一个新的节点时, 比如希望在B和C之间插入一个F, Diff算法默认的做法时这样的: 把C更新为F, 把D更新为C, 把E更新为D, 最后再插入一个E, 这样的做法效率时很低的</li></ul></li><li>所以我们需要使用key来给每个节点做一个唯一的标识<ul><li>Diff算法就可以正确地识别这个节点</li><li>然后找到正确地位置区插入新的节点</li></ul></li><li>一句话, key地作用主要就是为了高效地更新虚拟DOM</li><li>:key一定要写入唯一的, 能对应标签的值, 否则没有意义</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-Vue中响应式数组方法</title>
      <link href="2021/05/25/06-Vue%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/25/06-Vue%E4%B8%AD%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="数组中的哪些方法是响应式的"><a href="#数组中的哪些方法是响应式的" class="headerlink" title="数组中的哪些方法是响应式的"></a>数组中的哪些方法是响应式的</h3><ul><li>push(), pop(), shift(), unshift(), splice(), sort(), reverse() 这些方法是响应式的</li><li>修改数组中的数据不是响应式的! </li><li>如果想要修改数组中的数据也有响应式 则需要用splice() 方法</li><li>或者使用Vue的set()方法 set(要修改的数组, 要修改的数据的下标, 修改后的数据)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in arr&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">arr</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 数组中哪些方法是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1. push() 在数组的最后添加数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.push(&#x27;aaa&#x27;);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2. pop() 删除数组的最后一个数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.pop();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3. shift() 删除数组中的第一个数据 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.shift();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 4. unshift() 在数组中的最前面添加数据, 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.unshift(&quot;aaa&quot;);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 5. splice() 删除数组元素, 修改数组元素, 向数组插入元素 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这个方法一共有三或以上的参数, 第一个参数是从第几个索引号开始, 第二个参数是要修改多少个数据, 后面的参数是要插入或者要修改的参数</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 删除数据, 第一个参数传入从第几个索引号开始删除, 第二个参数传入要删除的数据个数, 如果第二个参数不传入的话, 就是删除第一个参数往后的所有数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 1);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 替换数据, 第一个参数传入从第几个索引号开始替换, 第二个参数传入要替换多少个数据, 后面的参数是要替换后的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 2, &quot;aaa&quot;, &quot;bbb&quot;);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 插入数据, 第一个参数传入从第一个索引号开始插入, 第二个参数传入0, 后面的参数是要插入的数据</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.splice(0, 0, &quot;aaa&quot;, &quot;bbb&quot;)</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 6. sort() 排列数组 参数是一个function 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.sort();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 7. reverse() 翻转数组, 是响应式的</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr.reverse();</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 注意: 修改数组中的数据不是响应式的!!!</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// this.arr[0] = &quot;aaa&quot;;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 想要响应式</span></span></span><br><span class="line"><span class="javascript">        Vue.set(<span class="built_in">this</span>.arr, <span class="number">0</span>, <span class="string">&quot;aaa&quot;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-Vue中逻辑语句v-if/v-else-if/v-else</title>
      <link href="2021/05/25/05-Vue%E4%B8%AD%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5v-if-v-else-if-v-else/"/>
      <url>2021/05/25/05-Vue%E4%B8%AD%E9%80%BB%E8%BE%91%E8%AF%AD%E5%8F%A5v-if-v-else-if-v-else/</url>
      
        <content type="html"><![CDATA[<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul><li>指令的值可以是一个布尔值, 也可以是一个判断条件</li><li>用于决定一个标签元素是否在页面中渲染</li><li>如果值为真, 则指令的标签会加载在页面中, 为false则不会加载在页面中(不会存在)</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-if基本使用, 如果值为true则会加载该标签, 为false则不会加载该标签(这个标签不会存在) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;false&quot;</span>&gt;</span>&#123;&#123;meassage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">meassage</span>: <span class="string">&quot;你好你好&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-else"><a href="#v-if-和-v-else" class="headerlink" title="v-if 和 v-else"></a>v-if 和 v-else</h3><ul><li>如果v-if的值为真则会加载 v-if的标签, 否则会加载v-else 的标签</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>v-if为假的时候,显示的div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-if-和-v-else-if-和-v-else"><a href="#v-if-和-v-else-if-和-v-else" class="headerlink" title="v-if 和 v-else-if 和 v-else"></a>v-if 和 v-else-if 和 v-else</h3><ul><li>如果有多种情况需要判断的的话, 可以用v-else-if 指令写更多的情况, 但是一般不会将判断的过程写在页面的标签指令中, 而是写在 computed 计算属性中, 这样代码更好看</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;scort&gt;=90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;scort&gt;=80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;scort&gt;=60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果进行复杂的判断的话 不会像上面那样写 而是将判断条件写在computed中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">scort</span>: <span class="number">55</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">result</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showMeassage = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">90</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;优秀&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">80</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;良好&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.scort &gt;= <span class="number">60</span>) &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;及格&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          showMeassage = <span class="string">&quot;不及格&quot;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> showMeassage;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul><li>v-show是用来决定元素是否在dom中显示的, 如果值为false,则会在对应的元素加上行内样式, display=”none”</li><li>与v-if的区别是, v-if是用来决定元素是否在dom中渲染, 如果值为false, 那么对应的元素则不会被渲染出来</li><li>开发中, 如果元素在页面中的切换很频繁, 那么就使用v-show, 如果元素在页面中只切换一次的话就用v-if, 开发中v-if常用一点</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-if是用来决定元素是否在dom中渲染, 如果值为false, 那么对应的元素则不会被渲染出来 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-show是用来决定元素是否在dom中显示的, 如果值为false,则会在对应的元素加上行内样式, display=&quot;none&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&quot;你好呀&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">isShow</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-Vue中computed计算属性</title>
      <link href="2021/05/25/04-Vue%E4%B8%ADcomputed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
      <url>2021/05/25/04-Vue%E4%B8%ADcomputed%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="计算属性-computed"><a href="#计算属性-computed" class="headerlink" title="计算属性 computed"></a>计算属性 computed</h3><ul><li>什么是计算属性, 在某些情况下, 需要将数据先进行转化后再进行显示, 或者需要将多个数据结合后再进行显示, 那么就需要将属性进行处理, 这就叫做计算属性</li><li>在进行变量的操作的时候 将操作写到computed对象中, return 计算的结果</li><li>定义名字的时候尽量与methods的方法区别开来, methods中定义名字用动词, computed中定义名字用名词</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 定义好后直接mustache语法调用即可 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">lastName</span>: <span class="string">&quot;bulaen&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 计算属性 computed</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>computed 和 methods 其实都可以实现功能, 但是为什么要分开呢?</li><li>实际上, 虽然computed 和methods 都可以实现功能, 但是它们两个内部进行的操作是不一样的</li><li>computed 计算属性会进行缓存, 多次调用里面的函数, 只会计算一次, 而methods不会进行缓存, 多次调用的话, 会调用多次</li></ul><h3 id="computed计算属性的set和get"><a href="#computed计算属性的set和get" class="headerlink" title="computed计算属性的set和get"></a>computed计算属性的set和get</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- computed 是一个属性, 而不是一个函数, 所以mustache语法中不需要加括号调用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">firstName</span>: <span class="string">&quot;kobe&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">lastName</span>: <span class="string">&quot;bulan&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 完整写法 完整写法一般是传入一个对象, 对象里面有两个函数, set 和 get</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* fullName: &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        // set函数用来设置属性, 但是在计算属性中, 一般只用get函数, 不用set函数 </span></span></span><br><span class="line"><span class="comment"><span class="javascript">        set: function (newValue) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          // set函数一般有一个形参用于接收传递进来的参数</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          const names = newValue.split(&quot; &quot;);</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.firstName = names[0];</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          this.lastName = names[1];</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;,</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        get: function () &#123;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">          return this.firstName + &quot; &quot; + this.lastName;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="javascript">      &#125; */</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// computed 中一般不会用来设置属性, 所以只写get函数, 所以省略写法可以这样写</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">fullName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="methods和computed的区别"><a href="#methods和computed的区别" class="headerlink" title="methods和computed的区别"></a>methods和computed的区别</h3><ul><li>methods是函数方法, 如果调用多少次就会调用多少次</li><li>computed是计算属性, 具有缓存机制, 在数据没有改变的情况下, 只会调用一次</li><li>所以在对数据进行处理的话就用computed计算属性, 而对事件的绑定则使用methods方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-Vue中v-on事件监听</title>
      <link href="2021/05/25/03-Vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/"/>
      <url>2021/05/25/03-Vue%E4%B8%ADv-on%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="v-on指令的基本使用"><a href="#v-on指令的基本使用" class="headerlink" title="v-on指令的基本使用"></a>v-on指令的基本使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button v-on:click=&quot;counter++&quot;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="comment">  &lt;button v-on:click=&quot;counter--&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;</span></span><br><span class="line"><span class="comment">  &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 语法糖 @写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">counter</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.counter++</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.counter--</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on的参数传递问题"><a href="#v-on的参数传递问题" class="headerlink" title="v-on的参数传递问题"></a>v-on的参数传递问题</h3><ul><li>第一种情况, 如果方法本身不需要传入参数, 调用方法的时候小括号可以省略</li><li>第二种情况, 如果方法本身需要传入参数, 但是调用方法的时候没有省略小括号, 也没有传入参数, 那么方法内的变量就是undefined<ul><li>如果省略了小括号, 但是这个方法本事是需要一个参数传入的, 那么Vue就会默认将浏览器生成的事件对象当作参数传入</li></ul></li><li>第三种情况, 如果方法既需要传入一个参数, 又需要传入浏览器生成的事件对象event, 那么要获取这个事件对象event, 就用 $event</li><li>传入参数的注意事项, 如果传入的参数带引号, 那么这个参数表示一个字符串, 如果这个参数没有引号, 那么这个参数表示一个变量, 注意Vue中的变量都需要在data中定义, 不然会报错<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 情况1, 方法本身不需要传递参数, 调用方法时的小括号可以省略 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn1()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn1&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 情况2, 方法本身需要传递一个参数, 调用方法的时候没有省略小括号, 也没有传入参数, 那么这个形参就为undefined --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2(&#x27;abc&#x27;)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里就是没有省略小括号, 也没有传入参数, 那么就是undefined --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2()&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果省略了小括号, 但是这个方法本事是需要一个参数传入的, 那么Vue就会默认将浏览器生成的事件对象当作参数传入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn2&quot;</span>&gt;</span>按钮4<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 情况3, 如果在定义方法的时候, 既需要传入一个参数, 又需要传入浏览器产生的event对象 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 那么要获取这个这个event对象, 就用 $event --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传入参数的时候注意引号的问题, 有引号表示字符串, 没引号代表变量, $event代表浏览器产生的event对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clickBtn3(&#x27;abc&#x27;, $event)&quot;</span>&gt;</span>按钮5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn1</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;按钮1被按了&quot;</span>);</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn2</span>(<span class="params">event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickBtn3</span>(<span class="params">abc, event</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(abc, event);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="v-on的修饰符"><a href="#v-on的修饰符" class="headerlink" title="v-on的修饰符"></a>v-on的修饰符</h3><ul><li>修饰符是 .修饰符 这样的格式 写在事件类型的后面的</li><li>停止冒泡修饰符 .stop  例如 @click.stop=()</li><li>阻止默认行为 .prevent</li><li>既想停止冒泡 又想阻止默认行为, 那么就要用修饰符串联语法 .stop.prevent</li><li>想要当事件是从特定的键触发时才触发回调, 那么就用键修饰符, 也可以用键的ASCII码 例如 键修饰符 .enter  ASCII码修饰符 .13</li><li>想要监听组件的事件, 必须加上修饰符 .native</li><li>想要事件只能触发一次 就用 .once 修饰符</li><li>示例代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span></span><br><span class="line">  我是div文字</span><br><span class="line">  <span class="comment">&lt;!-- 如果要阻止事件冒泡, 那么就给事件添加修饰符.stop --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>我是btn文字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 既想要阻止事件冒泡, 又想要阻止标签的默认行为, 那么就需要串联修饰符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;aClick&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果要阻止标签的默认行为, 就给事件添加修饰符.prevent --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;aClick&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果只当事件是从特定的键触发时才触发回调, 那么就用键修饰符, 也可以用键的ASCII码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;enterOn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.13</span>=<span class="string">&quot;enterOn&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 如果想要事件只执行一次, 那么就用修饰符.once --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>只能点击一次<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">divClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;divClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;btnClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;aClick&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">enterOn</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;enterOn&quot;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-VueMustache语法与一些指令</title>
      <link href="2021/05/25/02-VueMustache%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4/"/>
      <url>2021/05/25/02-VueMustache%E8%AF%AD%E6%B3%95%E4%B8%8E%E4%B8%80%E4%BA%9B%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="Mustache语法"><a href="#Mustache语法" class="headerlink" title="Mustache语法"></a>Mustache语法</h4><ul><li>又称大胡子语法 就是用两个大括号来包裹变量 从而挂钩Vue去解析里面的代码</li><li>比如</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mustache语法中不仅仅可以直接写变量, 还可以写一些简单的表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName + &#x27; &#x27; + lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;first&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter * 2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-once指令-不是很常用"><a href="#v-once指令-不是很常用" class="headerlink" title="v-once指令 (不是很常用)"></a>v-once指令 (不是很常用)</h4><ul><li>在某些情况下, 有一些元素我们不想它响应式地根据数据的改变而改变的时候, 给这个元素加上v-once指令后, 它就只会渲染一次, 之后就不会再渲染</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> // 这个元素会动态响应渲染</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> // 这个元素不会动态响应渲染</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-html指令"><a href="#v-html指令" class="headerlink" title="v-html指令"></a>v-html指令</h4><ul><li>有时候服务器端传过来的数据并不是一个字符串 而是一个html标签, 这个时候就可以用v-html指令来渲染这个标签</li><li>v-html指令不用Mustache语法, 这是为了安全的考虑 而且这个指令一般用于信任的数据<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;url&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-html</span>=<span class="string">&quot;url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">url</span>: <span class="string">&quot;&lt;a href=&#x27;http://www.baidu.com&#x27;&gt;百度一下&lt;/a&gt;&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="v-test指令"><a href="#v-test指令" class="headerlink" title="v-test指令"></a>v-test指令</h4><ul><li>因为会覆盖原来标签里面的内容,而且不能进行字符串的拼接, 所有很少使用</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟Mustache语法差不多, 但是Mustache语法用得多, 因为v-text使用不灵活, 会覆盖原来标签里面的东西 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-test</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-pre指令"><a href="#v-pre指令" class="headerlink" title="v-pre指令"></a>v-pre指令</h4><ul><li>把标签里面的东西原封不动的显示在页面, 带有这个指令的标签不进行Vue的处理</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个标签里面的东西就不会进入Vue渲染了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">message</span>: <span class="string">&quot;你好&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-cloak指令"><a href="#v-cloak指令" class="headerlink" title="v-cloak指令"></a>v-cloak指令</h4><ul><li>在某些情况下, 浏览器可能会直接显示出未经过Vue渲染的代码</li><li>v-cloak指令会在vue渲染之前存在, 而在vue渲染之后自动删除</li><li>利用这个特性, 可以将代码通过CSS的属性选择器先把代码隐藏起来, 在vue渲染之后删除了这个指令, 代码自动就显示出来了, 增强用户体验, 但是以后vue的代码会有更好的方法解决这个问题,所以这个指令也不常用</li></ul><h4 id="v-bind指令"><a href="#v-bind指令" class="headerlink" title="v-bind指令"></a>v-bind指令</h4><ul><li>想要动态绑定标签的属性值, 不能直接用mustache语法, 而要用v-bind指令前缀</li><li>v-bind指令的语法糖是 :</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 想要动态绑定标签的属性, 不可以直接用mustache语法, 而要用v-bind前缀 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 语法糖写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgUrl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- a标签也一样 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;aHerf&quot;</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">imgUrl</span>: <span class="string">&quot;https://cn.vuejs.org/images/logo.png&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">aHerf</span>: <span class="string">&quot;https://www.baidu.com&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-bind指令的对象语法-用得较多"><a href="#v-bind指令的对象语法-用得较多" class="headerlink" title="v-bind指令的对象语法 (用得较多)"></a>v-bind指令的对象语法 (用得较多)</h4><ul><li>v-bind还可以动态地绑定class, 达到动态绑定样式的效果</li><li>动态绑定的class, 里面传入一个对象, 键值对的形式 {key:value},key是一个类名,value是一个布尔值, 为true则为这个class添加这个key, 反之则不添加</li><li>动态绑定的class, 和静态的class可以共存的, 动态绑定的class不会覆盖静态的class</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- v-bind还可以动态地绑定class, 达到动态绑定样式的效果 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 动态绑定的class, 里面传入一个对象, 键值对的形式 &#123;key:value&#125;,value是一个布尔值, 为true则为这个class添加这个key, 反之则不添加 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active : isActive, line : isLine&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 动态绑定的class, 和静态的class可以共存的, 动态绑定的class不会覆盖静态的class --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active : isActive, line : isLine&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick()&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果class的内容过于复杂的话, 可以将class的内容放入methods中 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">isLine</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">btnClick</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">getClasses</span> : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 调用这个方法的时候返回一个对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;<span class="attr">active</span> : <span class="built_in">this</span>.isActive, <span class="attr">line</span> : <span class="built_in">this</span>.isLine&#125; <span class="comment">// 方法中调用变量记得要加this</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="v-bind绑定class的数组写法-不常用"><a href="#v-bind绑定class的数组写法-不常用" class="headerlink" title="v-bind绑定class的数组写法 (不常用)"></a>v-bind绑定class的数组写法 (不常用)</h4><ul><li>特点跟对象写法差不多</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 数组写法 跟对象写法差不多 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[active , line]&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意数组中的元素加引号和不加引号的区别, 加引号表示一个字符串, 不加引号表示一个变量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;, &#x27;line&#x27;]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟对象一样如果class过于复杂也可以, 写到methods里面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">active</span>: <span class="string">&quot;aaa&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">line</span>: <span class="string">&quot;bbb&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">getClasses</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> [<span class="built_in">this</span>.active, <span class="built_in">this</span>.line] <span class="comment">// 方法中调用变量记得加this</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用v-bind动态绑定style-对象写法-常用"><a href="#用v-bind动态绑定style-对象写法-常用" class="headerlink" title="用v-bind动态绑定style (对象写法, 常用)"></a>用v-bind动态绑定style (对象写法, 常用)</h4><ul><li>与动态绑定class写法差不多, 传入一个对象{key(属性名) : value(属性值)}</li><li>动态绑定的与静态编写的不会覆盖</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 跟动态绑定class差不多, 传入一个对象 &#123;key(属性名) : value(属性值)&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:&#x27;100px&#x27;&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 传入参数的时候, 要注意引号的添加, 不加引号代表一个变量, 加了引号代表一个字符串, 绑定多个style用逗号隔开即可 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize: finalSize, background : finalColor&#125;&quot;</span>&gt;</span>你好呀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">finalSize</span>: <span class="string">&quot;100px&quot;</span>, <span class="comment">// 如果这里写的100 ,那么在标签内引入的时候记得要利用字符串拼接加上单位&quot;px&quot;</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">finalColor</span>: <span class="string">&quot;red&quot;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="用v-bind动态绑定style-数组写法-我感觉这个写法很蠢-不常用"><a href="#用v-bind动态绑定style-数组写法-我感觉这个写法很蠢-不常用" class="headerlink" title="用v-bind动态绑定style (数组写法, 我感觉这个写法很蠢, 不常用)"></a>用v-bind动态绑定style (数组写法, 我感觉这个写法很蠢, 不常用)</h4><ul><li>在数组中传入一个一个的对象, 对象是键值对写法, 与对象写法一致</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 数组写法, 数组中传入一个对象,可以传入多个对象,逗号隔开, 对象写的是&#123;key(属性名) : value(属性值)&#125; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">[baseStyle]</span>&gt;</span>你好啊<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">baseStyle</span>: &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">backgroundColor</span>: <span class="string">&quot;red&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-vue学习笔记-vue特点</title>
      <link href="2021/05/12/01-vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E7%89%B9%E7%82%B9/"/>
      <url>2021/05/12/01-vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-vue%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h3><h4 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h4><ul><li>下载vue 可以通过cdn引入vue 也可以下载vue.js本地引入</li><li>vue的基本使用<ul><li>在引入vue后 new Vue({}) 一个vue对象</li><li>这样操作是为了防止XSS,csrf的攻击</li><li>然后就可以在html中进行vue操作了 例如</li><li>例如</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span> : <span class="string">&#x27;#box&#x27;</span>, <span class="comment">//此处写需要进行vue渲染的元素</span></span><br><span class="line">    <span class="attr">data</span> : &#123;</span><br><span class="line">        <span class="comment">// 此处写变量</span></span><br><span class="line">        <span class="attr">myname</span> : <span class="string">&#x27;xiaoLam&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123;20+30&#125;&#125; // 输出50</span><br><span class="line">    &#123;&#123;myname&#125;&#125; // 输出xiaoLam</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="以前的js做法-编程范式-命令式编程"><a href="#以前的js做法-编程范式-命令式编程" class="headerlink" title="以前的js做法 (编程范式: 命令式编程)"></a>以前的js做法 (编程范式: 命令式编程)</h4><ol><li>创建一个div元素,设置id属性</li><li>定义一个变量message</li><li>将这个变量插入div元素中</li><li>如果修改了message的数据</li><li>就要重新将修改后的数据重新插入div</li></ol><h4 id="1-模板语法-编程范式-声明式编程-优点是数据处理和页面渲染分开管理-可以很方便地动态响应数据的改变"><a href="#1-模板语法-编程范式-声明式编程-优点是数据处理和页面渲染分开管理-可以很方便地动态响应数据的改变" class="headerlink" title="1.模板语法 (编程范式: 声明式编程) 优点是数据处理和页面渲染分开管理 可以很方便地动态响应数据的改变"></a>1.模板语法 (编程范式: 声明式编程) 优点是数据处理和页面渲染分开管理 可以很方便地动态响应数据的改变</h4><ul><li>(1) 插值<ul><li>文本插值 使用双大括号<ul><li>在页面中插入文本的时候 需要将想插入的文本方法双层大括号中</li></ul></li><li>插入html标签 (处于安全考虑,只插入信任的内容)<ul><li>在需要插入html标签的元素中添加 v-html属性(其实叫 指令) 值为要插入的键, 例如</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span> : <span class="string">&#x27;#box&#x27;</span>, <span class="comment">//此处写需要将vue对象挂载到哪一个元素</span></span><br><span class="line">    <span class="attr">data</span> : &#123;</span><br><span class="line">        <span class="comment">// 此处写变量 自己定义的属性 也可以是来自网络的数据 网络的数据改变的话, 页面显示的数据动态改变(这个就是响应式的优点)</span></span><br><span class="line">        <span class="attr">myname</span> : <span class="string">&#x27;xiaoLam&#x27;</span>,</span><br><span class="line">        <span class="attr">myhtml</span>: <span class="string">&#x27;&lt;h1&gt;你好你好&lt;/h1&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">    &#123;&#123;20+30&#125;&#125; // 输出50</span><br><span class="line">    &#123;&#123;myname&#125;&#125; // 输出xiaoLam</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&#x27;myhtml&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> // 输出渲染后的myhtml</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(2) 指令: 是带有v- 前缀的特殊属性<ul><li>v-html 插入标签</li><li>v-show 判断是否显示节点 值为布尔值 true表示显示 flase表示隐藏</li><li>v-if 判断是否创建节点 值为布尔值 true表示创建 flase表示不创建</li></ul></li></ul><h4 id="2-class和style"><a href="#2-class和style" class="headerlink" title="2. class和style"></a>2. class和style</h4><ul><li>(1) 绑定HTML class<ul><li>动态绑定class有三种写法<ul><li>三目运算符写法</li><li>对象写法</li><li>数组写法</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">classObj</span>: &#123;</span><br><span class="line">            <span class="attr">a</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">b</span>: <span class="literal">true</span></span><br><span class="line">            <span class="comment">// a, b 为class的名字</span></span><br><span class="line">            <span class="comment">// 对象写法有一个缺点就是不能在没有定义之前创建class</span></span><br><span class="line">            <span class="comment">// 就比如classObj没有定义 c 这个class 那么就不能动态地创建 c 这个class</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">classArr</span>: [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>] <span class="comment">// 要操作数组中的元素也是按照JS的语法来操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;isActive?&#x27;red&#x27;:&#x27;blue&#x27;&quot;</span>&gt;</span>动态绑定class 三目运算符写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObj&quot;</span>&gt;</span>动态绑定class 对象写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classArr&quot;</span>&gt;</span>动态绑定class 数组写法<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>(2) 动态绑定style 跟动态绑定class差不多</li><li>(3) 想要绑定事件就Vue对象中的methods中编写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 添加变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="comment">// 添加方法</span></span><br><span class="line">        <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-for-指令"><a href="#v-for-指令" class="headerlink" title="v-for 指令"></a>v-for 指令</h3><ul><li>可以遍历数组中的元素</li><li>实际上就是JS中的for-in循环 例如:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in movies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  // 这里就可以循环movies数组中的元素 是响应式的,会自动检测movies中的数据, 增删改都会实时更新</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">movies</span>: [<span class="string">&quot;肖申克的救赎&quot;</span>, <span class="string">&quot;少年派&quot;</span>, <span class="string">&quot;星际穿越&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="v-on-添加事件监听指令-语法糖"><a href="#v-on-添加事件监听指令-语法糖" class="headerlink" title="v-on 添加事件监听指令  语法糖 @"></a>v-on 添加事件监听指令  语法糖 @</h3><ul><li>用于给元素添加事件监听</li><li>具体用法<ul><li>给需要的添加的元素添加属性 v-on:事件类型=”触发的函数名称”</li><li>在Vue对象中的methods中编写对应函数</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.counter++; <span class="comment">// 注意要获取data中的变量 需要写this. 否则Vue会在html中查找该名字的元素</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;add被触发了&quot;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">sub</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.counter--;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;sub被触发了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="VUE中的MVVM-model-view-viewModel"><a href="#VUE中的MVVM-model-view-viewModel" class="headerlink" title="VUE中的MVVM (model view viewModel)"></a>VUE中的MVVM (model view viewModel)</h3><ul><li><p>view层</p><ul><li>视图层</li><li>在前端开发中, 通常就是DOM层</li><li>主要作用就是给用户展示各种信息</li></ul></li><li><p>Model层</p><ul><li>数据层</li><li>可以是自己写的固定数据, 可以是从服务器端请求下来的动态数据</li><li>如果是动态数据在VUE中就可以通过ViewModel实时刷新数据</li></ul></li><li><p>viewModel层</p><ul><li>视图模型层</li><li>是view 和 model 之间沟通的桥梁</li><li>一方面实现了Data Binding(数据绑定), 将Model的改变实时地反映在View中</li><li>另一方面 实现了 DOM listener (DOM监听), 当DOM触发事件的时候, 可以改变对应的Data</li></ul></li></ul><h3 id="Vue实例中传入的options"><a href="#Vue实例中传入的options" class="headerlink" title="Vue实例中传入的options"></a>Vue实例中传入的options</h3><ul><li>有很多 现在只学了三个 el , data , methods</li><li>el : 类型string | HTMLElement   作用是决定Vue实例会管理哪一个DOM</li><li>data : 类型Object | Function   是Vue实例对应的数据对象, [注]在组件当中data必须是一个函数</li><li>methods : 类型{[key:string] : Function}  作用是定义属于Vue的一些方法,可以在其他地方调用, 也可以在指令中调用</li></ul><h4 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h4><ul><li>函数 function 在全局运用</li><li>方法 method 与某个实例对象挂钩的函数就是方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
